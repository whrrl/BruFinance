{"version":3,"file":"static/js/1832.f42a234b.chunk.js","mappings":"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","sources":["../node_modules/thirdweb/src/utils/signatures/helpers/parseTypedData.ts","../node_modules/thirdweb/src/wallets/in-app/web/utils/iFrameCommunication/IframeCommunicator.ts","../node_modules/thirdweb/src/wallets/in-app/web/utils/iFrameCommunication/InAppWalletIframeCommunicator.ts","../node_modules/thirdweb/src/wallets/in-app/web/lib/auth/abstract-login.ts","../node_modules/thirdweb/src/wallets/in-app/web/lib/auth/base-login.ts","../node_modules/thirdweb/src/wallets/in-app/web/lib/auth/index.ts","../node_modules/thirdweb/src/wallets/in-app/web/lib/in-app-account.ts","../node_modules/thirdweb/src/rpc/actions/eth_sendRawTransaction.ts","../node_modules/thirdweb/src/wallets/in-app/web/lib/web-connector.ts"],"sourcesContent":["import type { TypedData } from \"abitype\";\nimport type { TypedDataDefinition } from \"viem\";\nimport { type Hex, hexToNumber, isHex } from \"../../encoding/hex.js\";\n\ntype UnknownDomain = unknown & { chainId?: unknown }; // TODO: create our own typed data types so this is cleaner\ntype HexDomain = unknown & { chainId: Hex }; // TODO: create our own typed data types so this is cleaner\n\n/**\n * @internal\n */\nexport function parseTypedData<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n>(\n  typedData: TypedDataDefinition<typedData, primaryType>,\n): TypedDataDefinition<typedData, primaryType> {\n  const domain = typedData.domain as UnknownDomain;\n  if (domain?.chainId !== undefined && isHex(domain.chainId)) {\n    typedData.domain = {\n      ...(typedData.domain as HexDomain),\n      chainId: hexToNumber((typedData.domain as unknown as HexDomain).chainId),\n    } as unknown as TypedDataDefinition<typedData, primaryType>[\"domain\"];\n  }\n  return typedData;\n}\n","type IFrameCommunicatorProps = {\n  link: string;\n  baseUrl: string;\n  iframeId: string;\n  container?: HTMLElement;\n  onIframeInitialize?: () => void;\n};\n\nfunction sleep(seconds: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, seconds * 1000);\n  });\n}\n\nconst iframeBaseStyle = {\n  height: \"100%\",\n  width: \"100%\",\n  border: \"none\",\n  backgroundColor: \"transparent\",\n  colorScheme: \"light\",\n  position: \"fixed\",\n  top: \"0px\",\n  right: \"0px\",\n  zIndex: \"2147483646\",\n  display: \"none\",\n};\n\n// Global var to help track iframe state\nconst isIframeLoaded = new Map<string, boolean>();\n\n/**\n * @internal\n */\n// biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\nexport class IframeCommunicator<T extends { [key: string]: any }> {\n  private iframe: HTMLIFrameElement;\n  private POLLING_INTERVAL_SECONDS = 1.4;\n\n  private iframeBaseUrl;\n  /**\n   * @internal\n   */\n  constructor({\n    link,\n    baseUrl,\n    iframeId,\n    container = document.body,\n    onIframeInitialize,\n  }: IFrameCommunicatorProps) {\n    this.iframeBaseUrl = baseUrl;\n\n    // Creating the IFrame element for communication\n    let iframe = document.getElementById(iframeId) as HTMLIFrameElement | null;\n    const hrefLink = new URL(link);\n    // TODO (ew) - bring back version tracking\n    // const sdkVersion = process.env.THIRDWEB_EWS_SDK_VERSION;\n    // if (!sdkVersion) {\n    //   throw new Error(\"Missing THIRDWEB_EWS_SDK_VERSION env var\");\n    // }\n    // hrefLink.searchParams.set(\"sdkVersion\", sdkVersion);\n    if (!iframe || iframe.src !== hrefLink.href) {\n      // ! Do not update the hrefLink here or it'll cause multiple re-renders\n      if (!iframe) {\n        iframe = document.createElement(\"iframe\");\n        const mergedIframeStyles = {\n          ...iframeBaseStyle,\n        };\n        Object.assign(iframe.style, mergedIframeStyles);\n        iframe.setAttribute(\"id\", iframeId);\n        iframe.setAttribute(\"fetchpriority\", \"high\");\n        container.appendChild(iframe);\n      }\n      iframe.src = hrefLink.href;\n      // iframe.setAttribute(\"data-version\", sdkVersion);\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n      const onIframeLoaded = (event: MessageEvent<any>) => {\n        if (event.data.eventType === \"ewsIframeLoaded\") {\n          window.removeEventListener(\"message\", onIframeLoaded);\n          if (!iframe) {\n            console.warn(\"thirdweb Iframe not found\");\n            return;\n          }\n          this.onIframeLoadHandler(iframe, onIframeInitialize)();\n        }\n      };\n      window.addEventListener(\"message\", onIframeLoaded);\n    }\n    this.iframe = iframe;\n  }\n\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n  protected async onIframeLoadedInitVariables(): Promise<Record<string, any>> {\n    return {};\n  }\n\n  /**\n   * @internal\n   */\n  onIframeLoadHandler(\n    iframe: HTMLIFrameElement,\n    onIframeInitialize?: () => void,\n  ) {\n    return async () => {\n      const channel = new MessageChannel();\n\n      const promise = new Promise((res, rej) => {\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n        channel.port1.onmessage = (event: any) => {\n          const { data } = event;\n          channel.port1.close();\n          if (!data.success) {\n            rej(new Error(data.error));\n          }\n          isIframeLoaded.set(iframe.src, true);\n          if (onIframeInitialize) {\n            onIframeInitialize();\n          }\n          res(true);\n        };\n      });\n\n      const INIT_IFRAME_EVENT = \"initIframe\";\n      iframe?.contentWindow?.postMessage(\n        // ? We initialise the iframe with a bunch\n        // of useful information so that we don't have to pass it\n        // through in each of the future call. This would be where we do it.\n        {\n          eventType: INIT_IFRAME_EVENT,\n          data: await this.onIframeLoadedInitVariables(),\n        },\n        this.iframeBaseUrl,\n        [channel.port2],\n      );\n\n      await promise;\n    };\n  }\n\n  /**\n   * @internal\n   */\n  async call<ReturnData>({\n    procedureName,\n    params,\n    showIframe = false,\n  }: {\n    procedureName: keyof T;\n    params: T[keyof T];\n    showIframe?: boolean;\n  }) {\n    while (!isIframeLoaded.get(this.iframe.src)) {\n      await sleep(this.POLLING_INTERVAL_SECONDS);\n    }\n    if (showIframe) {\n      this.iframe.style.display = \"block\";\n      // magic number to let the display render before performing the animation of the modal in\n      await sleep(0.005);\n    }\n\n    const channel = new MessageChannel();\n    const promise = new Promise<ReturnData>((res, rej) => {\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n      channel.port1.onmessage = async (event: any) => {\n        const { data } = event;\n        channel.port1.close();\n        if (showIframe) {\n          // magic number to let modal fade out before hiding it\n          await sleep(0.1);\n          this.iframe.style.display = \"none\";\n        }\n        if (!data.success) {\n          rej(new Error(data.error));\n        } else {\n          res(data.data);\n        }\n      };\n    });\n\n    this.iframe.contentWindow?.postMessage(\n      { eventType: procedureName, data: params },\n      this.iframeBaseUrl,\n      [channel.port2],\n    );\n    return promise;\n  }\n\n  /**\n   * This has to be called by any iframe that will be removed from the DOM.\n   * Use to make sure that we reset the global loaded state of the particular iframe.src\n   * @internal\n   */\n  destroy() {\n    isIframeLoaded.delete(this.iframe.src);\n  }\n}\n","import { IN_APP_WALLET_PATH } from \"../../../core/constants/settings.js\";\nimport { LocalStorage } from \"../Storage/LocalStorage.js\";\nimport { IframeCommunicator } from \"./IframeCommunicator.js\";\n\n/**\n * @internal\n */\nexport class InAppWalletIframeCommunicator<\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  T extends { [key: string]: any },\n> extends IframeCommunicator<T> {\n  clientId: string;\n  /**\n   * @internal\n   */\n  constructor({ clientId, baseUrl }: { clientId: string; baseUrl: string }) {\n    super({\n      iframeId: IN_APP_WALLET_IFRAME_ID,\n      link: createInAppWalletIframeLink({\n        clientId,\n        path: IN_APP_WALLET_PATH,\n        baseUrl,\n      }).href,\n      baseUrl,\n      container: document.body,\n    });\n    this.clientId = clientId;\n  }\n\n  /**\n   * @internal\n   */\n  override async onIframeLoadedInitVariables() {\n    const localStorage = new LocalStorage({\n      clientId: this.clientId,\n    });\n\n    return {\n      authCookie: await localStorage.getAuthCookie(),\n      deviceShareStored: await localStorage.getDeviceShare(),\n      walletUserId: await localStorage.getWalletUserId(),\n      clientId: this.clientId,\n    };\n  }\n}\n\n// This is the URL and ID tag of the iFrame that we communicate with\n/**\n * @internal\n */\nexport function createInAppWalletIframeLink({\n  clientId,\n  baseUrl,\n  path,\n  queryParams,\n}: {\n  clientId: string;\n  baseUrl: string;\n  path: string;\n  queryParams?: { [key: string]: string | number };\n}) {\n  const inAppWalletUrl = new URL(`${path}`, baseUrl);\n  if (queryParams) {\n    for (const queryKey of Object.keys(queryParams)) {\n      inAppWalletUrl.searchParams.set(\n        queryKey,\n        queryParams[queryKey]?.toString() || \"\",\n      );\n    }\n  }\n  inAppWalletUrl.searchParams.set(\"clientId\", clientId);\n  return inAppWalletUrl;\n}\nexport const IN_APP_WALLET_IFRAME_ID = \"thirdweb-in-app-wallet-iframe\";\n","import type { ThirdwebClient } from \"../../../../../client/client.js\";\nimport type {\n  AuthAndWalletRpcReturnType,\n  AuthLoginReturnType,\n  AuthProvider,\n  SendEmailOtpReturnType,\n} from \"../../../core/authentication/type.js\";\nimport type { ClientIdWithQuerierType } from \"../../types.js\";\nimport type { InAppWalletIframeCommunicator } from \"../../utils/iFrameCommunication/InAppWalletIframeCommunicator.js\";\n\nexport type LoginQuerierTypes = {\n  loginWithCustomAuthEndpoint: { payload: string; encryptionKey: string };\n  loginWithCustomJwt: { jwt: string; encryptionKey?: string };\n  loginWithThirdwebModal: undefined | { email: string };\n  sendThirdwebSmsLoginOtp: { phoneNumber: string };\n  sendThirdwebEmailLoginOtp: { email: string };\n  verifyThirdwebEmailLoginOtp: {\n    email: string;\n    otp: string;\n    recoveryCode?: string;\n  };\n  verifyThirdwebSmsLoginOtp: {\n    phoneNumber: string;\n    otp: string;\n    recoveryCode?: string;\n  };\n  injectDeveloperClientId: undefined;\n  getHeadlessOauthLoginLink: { authProvider: AuthProvider };\n};\n\ntype OauthLoginType = {\n  openedWindow?: Window | null;\n  closeOpenedWindow?: (openedWindow: Window) => void;\n};\n\n/**\n * @internal\n */\nexport abstract class AbstractLogin<\n  MODAL = void,\n  EMAIL_MODAL extends { email: string } = { email: string },\n  EMAIL_VERIFICATION extends { email: string; otp: string } = {\n    email: string;\n    otp: string;\n    recoveryCode?: string;\n  },\n> {\n  protected LoginQuerier: InAppWalletIframeCommunicator<LoginQuerierTypes>;\n  protected preLogin;\n  protected postLogin: (\n    authResults: AuthAndWalletRpcReturnType,\n  ) => Promise<AuthLoginReturnType>;\n  protected client: ThirdwebClient;\n  protected baseUrl: string;\n  /**\n   * Used to manage the user's auth states. This should not be instantiated directly.\n   * Call {@link InAppWalletSDK.auth} instead.\n   * @internal\n   */\n  constructor({\n    baseUrl,\n    querier,\n    preLogin,\n    postLogin,\n    client,\n  }: ClientIdWithQuerierType & {\n    baseUrl: string;\n    preLogin: () => Promise<void>;\n    postLogin: (\n      authDetails: AuthAndWalletRpcReturnType,\n    ) => Promise<AuthLoginReturnType>;\n  }) {\n    this.baseUrl = baseUrl;\n    this.LoginQuerier = querier;\n    this.preLogin = preLogin;\n    this.postLogin = postLogin;\n    this.client = client;\n  }\n\n  abstract loginWithCustomJwt(args: {\n    jwt: string;\n    encryptionKey: string;\n  }): Promise<AuthLoginReturnType>;\n  abstract loginWithCustomAuthEndpoint(args: {\n    payload: string;\n    encryptionKey: string;\n  }): Promise<AuthLoginReturnType>;\n  abstract loginWithModal(args?: MODAL): Promise<AuthLoginReturnType>;\n  abstract loginWithEmailOtp(args: EMAIL_MODAL): Promise<AuthLoginReturnType>;\n  abstract loginWithOauth(\n    args: OauthLoginType & { oauthProvider: AuthProvider },\n  ): Promise<AuthLoginReturnType>;\n\n  /**\n   * @internal\n   */\n  async sendEmailLoginOtp({\n    email,\n  }: LoginQuerierTypes[\"sendThirdwebEmailLoginOtp\"]): Promise<SendEmailOtpReturnType> {\n    await this.preLogin();\n    const result = await this.LoginQuerier.call<SendEmailOtpReturnType>({\n      procedureName: \"sendThirdwebEmailLoginOtp\",\n      params: { email },\n    });\n    return result;\n  }\n\n  /**\n   *\n   * @internal\n   */\n  async sendSmsLoginOtp({\n    phoneNumber,\n  }: LoginQuerierTypes[\"sendThirdwebSmsLoginOtp\"]): Promise<SendEmailOtpReturnType> {\n    await this.preLogin();\n    const result = await this.LoginQuerier.call<SendEmailOtpReturnType>({\n      procedureName: \"sendThirdwebSmsLoginOtp\",\n      params: { phoneNumber },\n    });\n    return result;\n  }\n\n  abstract verifyEmailLoginOtp(\n    args: EMAIL_VERIFICATION,\n  ): Promise<AuthLoginReturnType>;\n\n  abstract verifySmsLoginOtp(args: {\n    phoneNumber: string;\n    otp: string;\n    recoveryCode?: string;\n  }): Promise<AuthLoginReturnType>;\n}\n","import {\n  type AuthAndWalletRpcReturnType,\n  type AuthLoginReturnType,\n  AuthProvider,\n  type GetHeadlessLoginLinkReturnType,\n} from \"../../../core/authentication/type.js\";\nimport { AbstractLogin, type LoginQuerierTypes } from \"./abstract-login.js\";\n\n/**\n *\n */\nexport class BaseLogin extends AbstractLogin<\n  void,\n  { email: string },\n  { email: string; otp: string; recoveryCode?: string }\n> {\n  private async getOauthLoginUrl(\n    authProvider: AuthProvider,\n  ): Promise<GetHeadlessLoginLinkReturnType> {\n    const result = await this.LoginQuerier.call<GetHeadlessLoginLinkReturnType>(\n      {\n        procedureName: \"getHeadlessOauthLoginLink\",\n        params: { authProvider },\n      },\n    );\n    return result;\n  }\n\n  /**\n   * @internal\n   */\n  override async loginWithModal(): Promise<AuthLoginReturnType> {\n    await this.preLogin();\n    const result = await this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithThirdwebModal\",\n      params: undefined,\n      showIframe: true,\n    });\n    return this.postLogin(result);\n  }\n\n  /**\n   * @internal\n   */\n  override async loginWithEmailOtp({\n    email,\n  }: {\n    email: string;\n  }): Promise<AuthLoginReturnType> {\n    await this.preLogin();\n    const result = await this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithThirdwebModal\",\n      params: { email },\n      showIframe: true,\n    });\n    return this.postLogin(result);\n  }\n\n  private closeWindow = ({\n    isWindowOpenedByFn,\n    win,\n    closeOpenedWindow,\n  }: {\n    win?: Window | null;\n    isWindowOpenedByFn: boolean;\n    closeOpenedWindow?: (openedWindow: Window) => void;\n  }) => {\n    if (isWindowOpenedByFn) {\n      win?.close();\n    } else {\n      if (win && closeOpenedWindow) {\n        closeOpenedWindow(win);\n      } else if (win) {\n        win.close();\n      }\n    }\n  };\n\n  private getOauthPopUpSizing(authProvider: AuthProvider) {\n    switch (authProvider) {\n      case AuthProvider.FACEBOOK:\n        return \"width=715, height=555\";\n      default:\n        return \"width=350, height=500\";\n    }\n  }\n\n  /**\n   * @internal\n   */\n  override async loginWithOauth(args: {\n    oauthProvider: AuthProvider;\n    openedWindow?: Window | null | undefined;\n    closeOpenedWindow?: ((openedWindow: Window) => void) | undefined;\n  }): Promise<AuthLoginReturnType> {\n    let win = args?.openedWindow;\n    let isWindowOpenedByFn = false;\n    if (!win) {\n      win = window.open(\n        \"\",\n        \"Login\",\n        this.getOauthPopUpSizing(args.oauthProvider),\n      );\n      isWindowOpenedByFn = true;\n    }\n    if (!win) {\n      throw new Error(\"Something went wrong opening pop-up\");\n    }\n    // logout the user\n    // fetch the url to open the login window from iframe\n    const [{ loginLink }] = await Promise.all([\n      this.getOauthLoginUrl(args.oauthProvider),\n      this.preLogin(),\n    ]);\n    win.location.href = loginLink;\n    // listen to result from the login window\n    const result = await new Promise<AuthAndWalletRpcReturnType>(\n      (resolve, reject) => {\n        // detect when the user closes the login window\n        const pollTimer = window.setInterval(async () => {\n          if (!win) {\n            return;\n          }\n          if (win.closed) {\n            clearInterval(pollTimer);\n            window.removeEventListener(\"message\", messageListener);\n            reject(new Error(\"User closed login window\"));\n          }\n        }, 1000);\n\n        const messageListener = async (\n          event: MessageEvent<{\n            eventType: string;\n            authResult?: AuthAndWalletRpcReturnType;\n            error?: string;\n          }>,\n        ) => {\n          if (event.origin !== this.baseUrl) {\n            return;\n          }\n          if (typeof event.data !== \"object\") {\n            reject(new Error(\"Invalid event data\"));\n            return;\n          }\n\n          switch (event.data.eventType) {\n            case \"userLoginSuccess\": {\n              window.removeEventListener(\"message\", messageListener);\n              clearInterval(pollTimer);\n              this.closeWindow({\n                isWindowOpenedByFn,\n                win,\n                closeOpenedWindow: args?.closeOpenedWindow,\n              });\n              if (event.data.authResult) {\n                resolve(event.data.authResult);\n              }\n              break;\n            }\n            case \"userLoginFailed\": {\n              window.removeEventListener(\"message\", messageListener);\n              clearInterval(pollTimer);\n              this.closeWindow({\n                isWindowOpenedByFn,\n                win,\n                closeOpenedWindow: args?.closeOpenedWindow,\n              });\n              reject(new Error(event.data.error));\n              break;\n            }\n            case \"injectDeveloperClientId\": {\n              win?.postMessage(\n                {\n                  eventType: \"injectDeveloperClientIdResult\",\n                  developerClientId: this.client.clientId,\n                  authOption: args.oauthProvider,\n                },\n                this.baseUrl,\n              );\n              break;\n            }\n          }\n        };\n        window.addEventListener(\"message\", messageListener);\n      },\n    );\n\n    return this.postLogin({\n      storedToken: { ...result.storedToken, shouldStoreCookieString: true },\n      walletDetails: { ...result.walletDetails, isIframeStorageEnabled: false },\n    });\n  }\n\n  /**\n   * @internal\n   */\n  override async loginWithCustomJwt({\n    encryptionKey,\n    jwt,\n  }: LoginQuerierTypes[\"loginWithCustomJwt\"]): Promise<AuthLoginReturnType> {\n    await this.preLogin();\n    const result = await this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithCustomJwt\",\n      params: { encryptionKey, jwt },\n    });\n    return this.postLogin(result);\n  }\n\n  /**\n   * @internal\n   */\n  override async loginWithCustomAuthEndpoint({\n    encryptionKey,\n    payload,\n  }: LoginQuerierTypes[\"loginWithCustomAuthEndpoint\"]): Promise<AuthLoginReturnType> {\n    await this.preLogin();\n    const result = await this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithCustomAuthEndpoint\",\n      params: { encryptionKey, payload },\n    });\n    return this.postLogin(result);\n  }\n\n  /**\n   * @internal\n   */\n  override async verifyEmailLoginOtp({\n    email,\n    otp,\n    recoveryCode,\n  }: LoginQuerierTypes[\"verifyThirdwebEmailLoginOtp\"]): Promise<AuthLoginReturnType> {\n    const result = await this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"verifyThirdwebEmailLoginOtp\",\n      params: { email, otp, recoveryCode },\n    });\n    return this.postLogin(result);\n  }\n\n  /**\n   * @internal\n   */\n  override async verifySmsLoginOtp({\n    phoneNumber,\n    otp,\n    recoveryCode,\n  }: LoginQuerierTypes[\"verifyThirdwebSmsLoginOtp\"]): Promise<AuthLoginReturnType> {\n    const result = await this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"verifyThirdwebSmsLoginOtp\",\n      params: { phoneNumber, otp, recoveryCode },\n    });\n    return this.postLogin(result);\n  }\n}\n","import type { ThirdwebClient } from \"../../../../../client/client.js\";\nimport type {\n  AuthAndWalletRpcReturnType,\n  AuthLoginReturnType,\n  AuthStoredTokenWithCookieReturnType,\n  LogoutReturnType,\n  SendEmailOtpReturnType,\n} from \"../../../core/authentication/type.js\";\nimport type { ClientIdWithQuerierType } from \"../../types.js\";\nimport { LocalStorage } from \"../../utils/Storage/LocalStorage.js\";\nimport type { InAppWalletIframeCommunicator } from \"../../utils/iFrameCommunication/InAppWalletIframeCommunicator.js\";\nimport { BaseLogin } from \"./base-login.js\";\n\nexport type AuthQuerierTypes = {\n  logout: undefined;\n  initIframe: {\n    clientId: string;\n    authCookie: string;\n    walletUserId: string;\n    deviceShareStored: string;\n  };\n  loginWithStoredTokenDetails: {\n    storedToken: AuthStoredTokenWithCookieReturnType[\"storedToken\"];\n    recoveryCode?: string;\n  };\n};\n\n/**\n *\n */\nexport class Auth {\n  protected client: ThirdwebClient;\n  protected AuthQuerier: InAppWalletIframeCommunicator<AuthQuerierTypes>;\n  protected localStorage: LocalStorage;\n  protected onAuthSuccess: (\n    authResults: AuthAndWalletRpcReturnType,\n  ) => Promise<AuthLoginReturnType>;\n  private BaseLogin: BaseLogin;\n\n  /**\n   * Used to manage the user's auth states. This should not be instantiated directly.\n   * Call {@link InAppWalletSdk.auth} instead.\n   * @internal\n   */\n  constructor({\n    client,\n    querier,\n    onAuthSuccess,\n    baseUrl,\n  }: ClientIdWithQuerierType & {\n    baseUrl: string;\n    onAuthSuccess: (\n      authDetails: AuthAndWalletRpcReturnType,\n    ) => Promise<AuthLoginReturnType>;\n  }) {\n    this.client = client;\n\n    this.AuthQuerier = querier;\n    this.localStorage = new LocalStorage({ clientId: client.clientId });\n    this.onAuthSuccess = onAuthSuccess;\n    this.BaseLogin = new BaseLogin({\n      postLogin: async (result) => {\n        return this.postLogin(result);\n      },\n      preLogin: async () => {\n        await this.preLogin();\n      },\n      querier: querier,\n      client,\n      baseUrl,\n    });\n  }\n\n  private async preLogin() {\n    await this.logout();\n  }\n\n  private async postLogin({\n    storedToken,\n    walletDetails,\n  }: AuthAndWalletRpcReturnType): Promise<AuthLoginReturnType> {\n    if (storedToken.shouldStoreCookieString) {\n      await this.localStorage.saveAuthCookie(storedToken.cookieString);\n    }\n    const initializedUser = await this.onAuthSuccess({\n      storedToken,\n      walletDetails,\n    });\n    return initializedUser;\n  }\n\n  async loginWithAuthToken(\n    authToken: AuthStoredTokenWithCookieReturnType,\n    recoveryCode?: string,\n  ): Promise<AuthLoginReturnType> {\n    await this.preLogin();\n    const result = await this.AuthQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithStoredTokenDetails\",\n      params: {\n        storedToken: authToken.storedToken,\n        recoveryCode,\n      },\n    });\n    return this.postLogin(result);\n  }\n\n  /**\n   * Used to log the user into their thirdweb wallet on your platform via a myriad of auth providers\n   * @example\n   * ```typescript\n   * const thirdwebInAppWallet = new InAppWalletSdk({clientId: \"YOUR_CLIENT_ID\", chain: \"Polygon\"})\n   * try {\n   *   const user = await thirdwebInAppWallet.auth.loginWithModal();\n   *   // user is now logged in\n   * } catch (e) {\n   *   // User closed modal or something else went wrong during the authentication process\n   *   console.error(e)\n   * }\n   * ```\n   * @returns `{{user: InitializedUser}}` An InitializedUser object.\n   */\n  async loginWithModal(): Promise<AuthLoginReturnType> {\n    return this.BaseLogin.loginWithModal();\n  }\n\n  /**\n   * Used to log the user into their thirdweb wallet using email OTP\n   * @example\n   * ```typescript\n   *  // Basic Flow\n   *  const thirdwebInAppWallet = new InAppWalletSdk({clientId: \"\", chain: \"Polygon\"});\n   *  try {\n   *    // prompts user to enter the code they received\n   *    const user = await thirdwebInAppWallet.auth.loginWithThirdwebEmailOtp({ email : \"you@example.com\" });\n   *    // user is now logged in\n   *  } catch (e) {\n   *    // User closed the OTP modal or something else went wrong during the authentication process\n   *    console.error(e)\n   *  }\n   * ```\n   * @param args - args.email: We will send the email an OTP that needs to be entered in order for them to be logged in.\n   * @returns `{{user: InitializedUser}}` An InitializedUser object. See {@link InAppWalletSdk.getUser} for more\n   */\n  async loginWithEmailOtp(\n    args: Parameters<BaseLogin[\"loginWithEmailOtp\"]>[0],\n  ): Promise<AuthLoginReturnType> {\n    return this.BaseLogin.loginWithEmailOtp(args);\n  }\n\n  /**\n   * @internal\n   */\n  async loginWithCustomJwt(\n    args: Parameters<BaseLogin[\"loginWithCustomJwt\"]>[0],\n  ): Promise<AuthLoginReturnType> {\n    return this.BaseLogin.loginWithCustomJwt(args);\n  }\n\n  /**\n   * @internal\n   */\n  async loginWithCustomAuthEndpoint(\n    args: Parameters<BaseLogin[\"loginWithCustomAuthEndpoint\"]>[0],\n  ): Promise<AuthLoginReturnType> {\n    return this.BaseLogin.loginWithCustomAuthEndpoint(args);\n  }\n\n  /**\n   * @internal\n   */\n  async loginWithOauth(\n    args: Parameters<BaseLogin[\"loginWithOauth\"]>[0],\n  ): Promise<AuthLoginReturnType> {\n    return this.BaseLogin.loginWithOauth(args);\n  }\n\n  /**\n   * A headless way to send the users at the passed email an OTP code.\n   * You need to then call {@link Auth.verifyEmailLoginOtp} in order to complete the login process\n   * @example\n   * @param param0.email\n   * ```typescript\n   *  const thirdwebInAppWallet = new InAppWalletSdk({clientId: \"\", chain: \"Polygon\"});\n   *  // sends user an OTP code\n   * try {\n   *    await thirdwebInAppWallet.auth.sendEmailLoginOtp({ email : \"you@example.com\" });\n   * } catch(e) {\n   *    // Error Sending user's email an OTP code\n   *    console.error(e);\n   * }\n   *\n   * // Then when your user is ready to verify their OTP\n   * try {\n   *    const user = await thirdwebInAppWallet.auth.verifyEmailLoginOtp({ email: \"you@example.com\", otp: \"6-DIGIT_CODE_HERE\" });\n   * } catch(e) {\n   *    // Error verifying the OTP code\n   *    console.error(e)\n   * }\n   * ```\n   * @param param0 - param0.email We will send the email an OTP that needs to be entered in order for them to be logged in.\n   * @returns `{{ isNewUser: boolean }}` IsNewUser indicates if the user is a new user to your platform\n   * @internal\n   */\n  async sendEmailLoginOtp({\n    email,\n  }: Parameters<\n    BaseLogin[\"sendEmailLoginOtp\"]\n  >[0]): Promise<SendEmailOtpReturnType> {\n    return this.BaseLogin.sendEmailLoginOtp({\n      email,\n    });\n  }\n\n  /**\n   * @internal\n   */\n  async sendSmsLoginOtp({\n    phoneNumber,\n  }: Parameters<\n    BaseLogin[\"sendSmsLoginOtp\"]\n  >[0]): Promise<SendEmailOtpReturnType> {\n    return this.BaseLogin.sendSmsLoginOtp({\n      phoneNumber,\n    });\n  }\n\n  /**\n   * Used to verify the otp that the user receives from thirdweb\n   *\n   * See {@link Auth.sendEmailLoginOtp} for how the headless call flow looks like. Simply swap out the calls to `loginWithThirdwebEmailOtp` with `verifyThirdwebEmailLoginOtp`\n   * @param args - props.email We will send the email an OTP that needs to be entered in order for them to be logged in.\n   * props.otp The code that the user received in their email\n   * @returns `{{user: InitializedUser}}` An InitializedUser object containing the user's status, wallet, authDetails, and more\n   * @internal\n   */\n  async verifyEmailLoginOtp(\n    args: Parameters<BaseLogin[\"verifyEmailLoginOtp\"]>[0],\n  ) {\n    return this.BaseLogin.verifyEmailLoginOtp(args);\n  }\n\n  /**\n   * @internal\n   */\n  async verifySmsLoginOtp(args: Parameters<BaseLogin[\"verifySmsLoginOtp\"]>[0]) {\n    return this.BaseLogin.verifySmsLoginOtp(args);\n  }\n\n  /**\n   * Logs any existing user out of their wallet.\n   * @returns `{{success: boolean}}` true if a user is successfully logged out. false if there's no user currently logged in.\n   * @internal\n   */\n  async logout(): Promise<LogoutReturnType> {\n    const { success } = await this.AuthQuerier.call<LogoutReturnType>({\n      procedureName: \"logout\",\n      params: undefined,\n    });\n    const isRemoveAuthCookie = await this.localStorage.removeAuthCookie();\n    const isRemoveUserId = await this.localStorage.removeWalletUserId();\n\n    return {\n      success: success || isRemoveAuthCookie || isRemoveUserId,\n    };\n  }\n}\n","import type * as ethers5 from \"ethers5\";\nimport type { TypedDataDefinition } from \"viem\";\nimport { getCachedChain } from \"../../../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { eth_sendRawTransaction } from \"../../../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../../../rpc/rpc.js\";\nimport type { Hex } from \"../../../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../../../utils/signatures/helpers/parseTypedData.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n} from \"../../../interfaces/wallet.js\";\nimport {\n  type GetUser,\n  type GetUserWalletStatusRpcReturnType,\n  type SetUpWalletRpcReturnType,\n  UserWalletStatus,\n  type WalletAddressObjectType,\n} from \"../../core/authentication/type.js\";\nimport type {\n  ClientIdWithQuerierType,\n  GetAddressReturnType,\n  SignMessageReturnType,\n  SignTransactionReturnType,\n  SignedTypedDataReturnType,\n} from \"../types.js\";\nimport { LocalStorage } from \"../utils/Storage/LocalStorage.js\";\nimport type { InAppWalletIframeCommunicator } from \"../utils/iFrameCommunication/InAppWalletIframeCommunicator.js\";\n\nexport type WalletManagementTypes = {\n  createWallet: undefined;\n  setUpNewDevice: undefined;\n  getUserStatus: undefined;\n};\nexport type WalletManagementUiTypes = {\n  createWalletUi: undefined;\n  setUpNewDeviceUi: undefined;\n};\n\nexport type InAppWalletInternalHelperType = { showUi: boolean };\n\nexport type SignerProcedureTypes = {\n  getAddress: undefined;\n  signMessage: {\n    message: string | Hex;\n    chainId: number;\n    rpcEndpoint?: string;\n  };\n  signTransaction: {\n    transaction: ethers5.ethers.providers.TransactionRequest;\n    chainId: number;\n    rpcEndpoint?: string;\n  };\n  signTypedDataV4: {\n    domain: TypedDataDefinition[\"domain\"];\n    types: TypedDataDefinition[\"types\"];\n    message: TypedDataDefinition[\"message\"];\n    chainId: number;\n    rpcEndpoint?: string;\n  };\n  //connect: { provider: Provider };\n};\n\ntype PostWalletSetup = SetUpWalletRpcReturnType & {\n  walletUserId: string;\n};\n\n/**\n *\n */\nexport class IFrameWallet {\n  protected client: ThirdwebClient;\n  protected walletManagerQuerier: InAppWalletIframeCommunicator<\n    WalletManagementTypes & WalletManagementUiTypes\n  >;\n  protected localStorage: LocalStorage;\n\n  /**\n   * Not meant to be initialized directly. Call {@link initializeUser} to get an instance\n   * @internal\n   */\n  constructor({ client, querier }: ClientIdWithQuerierType) {\n    this.client = client;\n    this.walletManagerQuerier = querier;\n\n    this.localStorage = new LocalStorage({ clientId: client.clientId });\n  }\n\n  /**\n   * Used to set-up the user device in the case that they are using incognito\n   * @returns `{walletAddress : string }` The user's wallet details\n   * @internal\n   */\n  async postWalletSetUp({\n    deviceShareStored,\n    walletAddress,\n    isIframeStorageEnabled,\n    walletUserId,\n  }: PostWalletSetup): Promise<WalletAddressObjectType> {\n    if (!isIframeStorageEnabled) {\n      await this.localStorage.saveDeviceShare(deviceShareStored, walletUserId);\n    }\n    return { walletAddress };\n  }\n\n  /**\n   * Gets the various status states of the user\n   * @example\n   * ```typescript\n   *  const userStatus = await Paper.getUserWalletStatus();\n   *  switch (userStatus.status) {\n   *  case UserWalletStatus.LOGGED_OUT: {\n   *    // User is logged out, call one of the auth methods on Paper.auth to authenticate the user\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED: {\n   *    // User is logged in, but does not have a wallet associated with it\n   *    // you also have access to the user's details\n   *    userStatus.user.authDetails;\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_NEW_DEVICE: {\n   *    // User is logged in and created a wallet already, but is missing the device shard\n   *    // You have access to:\n   *    userStatus.user.authDetails;\n   *    userStatus.user.walletAddress;\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {\n   *    // user is logged in and wallet is all set up.\n   *    // You have access to:\n   *    userStatus.user.authDetails;\n   *    userStatus.user.walletAddress;\n   *    userStatus.user.wallet;\n   *    break;\n   *  }\n   *}\n   *```\n   * @returns `{GetUserWalletStatusFnReturnType}` an object to containing various information on the user statuses\n   * @internal\n   */\n  async getUserWalletStatus(): Promise<GetUser> {\n    const userStatus =\n      await this.walletManagerQuerier.call<GetUserWalletStatusRpcReturnType>({\n        procedureName: \"getUserStatus\",\n        params: undefined,\n      });\n    if (userStatus.status === UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED) {\n      return {\n        status: UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED,\n        ...userStatus.user,\n        account: await this.getAccount(),\n      };\n    }\n    if (userStatus.status === UserWalletStatus.LOGGED_IN_NEW_DEVICE) {\n      return {\n        status: UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED,\n        ...userStatus.user,\n      };\n    }\n    if (userStatus.status === UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED) {\n      return {\n        status: UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED,\n        ...userStatus.user,\n      };\n    }\n    // Logged out\n    return { status: userStatus.status };\n  }\n\n  /**\n   * Returns an account that communicates with the iFrame for signing operations\n   * @internal\n   */\n  async getAccount(): Promise<Account> {\n    const querier = this\n      .walletManagerQuerier as unknown as InAppWalletIframeCommunicator<SignerProcedureTypes>;\n    const { address } = await querier.call<GetAddressReturnType>({\n      procedureName: \"getAddress\",\n      params: undefined,\n    });\n    const _signTransaction = async (tx: SendTransactionOption) => {\n      // biome-ignore lint/suspicious/noExplicitAny: ethers tx transformation\n      const transaction: Record<string, any> = {\n        to: tx.to ?? undefined,\n        data: tx.data,\n        value: tx.value,\n        gasLimit: tx.gas,\n        nonce: tx.nonce,\n        chainId: tx.chainId,\n      };\n      if (tx.maxFeePerGas) {\n        // ethers (in the iframe) rejects any type 0 trasaction with unknown keys\n        // TODO remove this once iframe is upgraded to v5\n        transaction.accessList = tx.accessList;\n        transaction.maxFeePerGas = tx.maxFeePerGas;\n        transaction.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n        transaction.type = 2;\n      } else {\n        transaction.gasPrice = tx.gasPrice;\n        transaction.type = 0;\n      }\n      const { signedTransaction } =\n        await querier.call<SignTransactionReturnType>({\n          procedureName: \"signTransaction\",\n          params: {\n            transaction,\n            chainId: tx.chainId,\n            rpcEndpoint: `https://${tx.chainId}.rpc.thirdweb.com`, // TODO (ew) shouldnt be needed\n          },\n        });\n      return signedTransaction as Hex;\n    };\n    const client = this.client;\n    return {\n      address,\n      async signTransaction(tx) {\n        if (!tx.chainId) {\n          throw new Error(\"chainId required in tx to sign\");\n        }\n        return _signTransaction({\n          ...tx,\n          chainId: tx.chainId,\n        });\n      },\n      async sendTransaction(tx) {\n        const rpcRequest = getRpcClient({\n          client,\n          chain: getCachedChain(tx.chainId),\n        });\n        const signedTx = await _signTransaction(tx);\n        const transactionHash = await eth_sendRawTransaction(\n          rpcRequest,\n          signedTx,\n        );\n        return {\n          transactionHash,\n        };\n      },\n      async signMessage({ message }) {\n        const messageDecoded =\n          typeof message === \"string\" ? message : message.raw;\n        const { signedMessage } = await querier.call<SignMessageReturnType>({\n          procedureName: \"signMessage\",\n          params: {\n            // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n            message: messageDecoded as any, // wants Bytes or string\n            chainId: 1, // TODO check if we need this\n          },\n        });\n        return signedMessage as Hex;\n      },\n      async signTypedData(_typedData) {\n        const parsedTypedData = parseTypedData(_typedData);\n        // deleting EIP712 Domain as it results in ambiguous primary type on some cases\n        // this happens when going from viem to ethers via the iframe\n        if (parsedTypedData.types?.EIP712Domain) {\n          parsedTypedData.types.EIP712Domain = undefined;\n        }\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n        const chainId = Number((parsedTypedData.domain as any)?.chainId || 1);\n\n        const { signedTypedData } =\n          await querier.call<SignedTypedDataReturnType>({\n            procedureName: \"signTypedDataV4\",\n            params: {\n              // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n              domain: parsedTypedData.domain as any,\n              types:\n                parsedTypedData.types as SignerProcedureTypes[\"signTypedDataV4\"][\"types\"],\n              message:\n                parsedTypedData.message as SignerProcedureTypes[\"signTypedDataV4\"][\"message\"],\n              chainId,\n              rpcEndpoint: `https://${chainId}.rpc.thirdweb.com`, // TODO (ew) shouldnt be needed\n            },\n          });\n        return signedTypedData as Hex;\n      },\n    };\n  }\n}\n","import type { EIP1193RequestFn, EIP1474Methods, Hex } from \"viem\";\n\n/**\n * Sends a raw transaction to the Ethereum network.\n * @param request - The EIP1193 request function.\n * @param signedTransaction - The signed transaction in hex format.\n * @returns A promise that resolves to the transaction hash.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_sendRawTransaction } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const transactionHash = await eth_sendRawTransaction(rpcRequest, \"0x...\");\n * ```\n */\nexport async function eth_sendRawTransaction(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  signedTransaction: Hex,\n) {\n  return await request({\n    method: \"eth_sendRawTransaction\",\n    params: [signedTransaction],\n  });\n}\n","import type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport type { Account } from \"../../../interfaces/wallet.js\";\nimport { oauthStrategyToAuthProvider } from \"../../core/authentication/index.js\";\nimport {\n  type AuthArgsType,\n  type AuthLoginReturnType,\n  type GetUser,\n  type LogoutReturnType,\n  type PreAuthArgsType,\n  type SendEmailOtpReturnType,\n  UserWalletStatus,\n} from \"../../core/authentication/type.js\";\nimport type { InAppConnector } from \"../../core/interfaces/connector.js\";\nimport type { InAppWalletConstructorType } from \"../types.js\";\nimport { InAppWalletIframeCommunicator } from \"../utils/iFrameCommunication/InAppWalletIframeCommunicator.js\";\nimport { Auth, type AuthQuerierTypes } from \"./auth/index.js\";\nimport { loginWithPasskey, registerPasskey } from \"./auth/passkeys.js\";\nimport { IFrameWallet } from \"./in-app-account.js\";\n\n/**\n * @internal\n */\nexport class InAppWebConnector implements InAppConnector {\n  protected client: ThirdwebClient;\n  protected querier: InAppWalletIframeCommunicator<AuthQuerierTypes>;\n\n  private wallet: IFrameWallet;\n  /**\n   * Used to manage the Auth state of the user.\n   */\n  auth: Auth;\n\n  private isClientIdLegacyPaper(clientId: string): boolean {\n    if (clientId.indexOf(\"-\") > 0 && clientId.length === 36) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @example\n   * `const thirdwebInAppWallet = new InAppWalletSdk({ clientId: \"\", chain: \"Goerli\" });`\n   * @internal\n   */\n  constructor({ client, onAuthSuccess }: InAppWalletConstructorType) {\n    if (this.isClientIdLegacyPaper(client.clientId)) {\n      throw new Error(\n        \"You are using a legacy clientId. Please use the clientId found on the thirdweb dashboard settings page\",\n      );\n    }\n    const baseUrl = getThirdwebBaseUrl(\"inAppWallet\");\n    this.client = client;\n    this.querier = new InAppWalletIframeCommunicator({\n      clientId: client.clientId,\n      baseUrl,\n    });\n    this.wallet = new IFrameWallet({\n      client,\n      querier: this.querier,\n    });\n\n    this.auth = new Auth({\n      client,\n      querier: this.querier,\n      baseUrl,\n      onAuthSuccess: async (authResult) => {\n        onAuthSuccess?.(authResult);\n        await this.wallet.postWalletSetUp({\n          ...authResult.walletDetails,\n          walletUserId: authResult.storedToken.authDetails.userWalletId,\n        });\n        await this.querier.call({\n          procedureName: \"initIframe\",\n          params: {\n            deviceShareStored: authResult.walletDetails.deviceShareStored,\n            clientId: this.client.clientId,\n            walletUserId: authResult.storedToken.authDetails.userWalletId,\n            authCookie: authResult.storedToken.cookieString,\n          },\n        });\n        return {\n          user: {\n            status: UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED,\n            authDetails: authResult.storedToken.authDetails,\n            account: await this.wallet.getAccount(),\n            walletAddress: authResult.walletDetails.walletAddress,\n          },\n        };\n      },\n    });\n  }\n\n  /**\n   * Gets the usr if they are logged in\n   * @example\n   * ```js\n   *  const user = await thirdwebInAppWallet.getUser();\n   *  switch (user.status) {\n   *     case UserWalletStatus.LOGGED_OUT: {\n   *       // User is logged out, call one of the auth methods on thirdwebInAppWallet.auth to authenticate the user\n   *       break;\n   *     }\n   *     case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {\n   *       // user is logged in and wallet is all set up.\n   *       // You have access to:\n   *       user.status;\n   *       user.authDetails;\n   *       user.walletAddress;\n   *       user.wallet;\n   *       break;\n   *     }\n   * }\n   * ```\n   * @returns GetUser - an object to containing various information on the user statuses\n   */\n  async getUser(): Promise<GetUser> {\n    return this.wallet.getUserWalletStatus();\n  }\n\n  getAccount(): Promise<Account> {\n    return this.wallet.getAccount();\n  }\n\n  async preAuthenticate(\n    args: PreAuthArgsType,\n  ): Promise<SendEmailOtpReturnType> {\n    const strategy = args.strategy;\n    switch (strategy) {\n      case \"email\": {\n        return this.auth.sendEmailLoginOtp({ email: args.email });\n      }\n      case \"phone\": {\n        return this.auth.sendSmsLoginOtp({ phoneNumber: args.phoneNumber });\n      }\n      default:\n        assertUnreachable(\n          strategy,\n          `Provider: ${strategy} doesnt require pre-authentication`,\n        );\n    }\n  }\n\n  async authenticate(args: AuthArgsType): Promise<AuthLoginReturnType> {\n    const strategy = args.strategy;\n    switch (strategy) {\n      case \"email\": {\n        return await this.auth.verifyEmailLoginOtp({\n          email: args.email,\n          otp: args.verificationCode,\n        });\n      }\n      case \"phone\": {\n        return await this.auth.verifySmsLoginOtp({\n          otp: args.verificationCode,\n          phoneNumber: args.phoneNumber,\n        });\n      }\n      case \"apple\":\n      case \"facebook\":\n      case \"google\": {\n        const oauthProvider = oauthStrategyToAuthProvider[strategy];\n        return this.auth.loginWithOauth({\n          oauthProvider,\n          closeOpenedWindow: args.closeOpenedWindow,\n          openedWindow: args.openedWindow,\n        });\n      }\n      case \"jwt\": {\n        return this.auth.loginWithCustomJwt({\n          jwt: args.jwt,\n          encryptionKey: args.encryptionKey,\n        });\n      }\n      case \"auth_endpoint\": {\n        return this.auth.loginWithCustomAuthEndpoint({\n          payload: args.payload,\n          encryptionKey: args.encryptionKey,\n        });\n      }\n      case \"iframe_email_verification\": {\n        return this.auth.loginWithEmailOtp({\n          email: args.email,\n        });\n      }\n      case \"iframe\": {\n        return this.auth.loginWithModal();\n      }\n      case \"passkey\": {\n        if (args.type === \"sign-up\") {\n          const authToken = await registerPasskey({\n            client: args.client,\n            authenticatorType: args.authenticatorType,\n            username: args.passkeyName,\n          });\n          return this.auth.loginWithAuthToken(authToken);\n        }\n        const authToken = await loginWithPasskey({\n          client: args.client,\n          authenticatorType: args.authenticatorType,\n        });\n        return this.auth.loginWithAuthToken(authToken);\n      }\n      default:\n        assertUnreachable(strategy);\n    }\n  }\n\n  async logout(): Promise<LogoutReturnType> {\n    return await this.auth.logout();\n  }\n}\n\nfunction assertUnreachable(x: never, message?: string): never {\n  throw new Error(message ?? `Invalid param: ${x}`);\n}\n"],"names":["parseTypedData","typedData","domain","undefined","chainId","isHex","hexToNumber","sleep","seconds","Promise","resolve","setTimeout","iframeBaseStyle","height","width","border","backgroundColor","colorScheme","position","top","right","zIndex","display","isIframeLoaded","Map","IframeCommunicator","constructor","_ref","link","baseUrl","iframeId","container","document","body","onIframeInitialize","Object","defineProperty","this","iframeBaseUrl","iframe","getElementById","hrefLink","URL","src","href","createElement","mergedIframeStyles","assign","style","setAttribute","appendChild","onIframeLoaded","event","data","eventType","window","removeEventListener","console","warn","onIframeLoadHandler","addEventListener","onIframeLoadedInitVariables","async","_iframe$contentWindow","channel","MessageChannel","promise","res","rej","port1","onmessage","close","success","Error","error","set","contentWindow","postMessage","port2","call","_ref2","_this$iframe$contentW","procedureName","params","showIframe","get","POLLING_INTERVAL_SECONDS","destroy","delete","InAppWalletIframeCommunicator","clientId","super","IN_APP_WALLET_IFRAME_ID","createInAppWalletIframeLink","path","IN_APP_WALLET_PATH","localStorage","LocalStorage","authCookie","getAuthCookie","deviceShareStored","getDeviceShare","walletUserId","getWalletUserId","queryParams","inAppWalletUrl","concat","queryKey","keys","_queryParams$queryKey","searchParams","toString","AbstractLogin","querier","preLogin","postLogin","client","LoginQuerier","sendEmailLoginOtp","email","sendSmsLoginOtp","_ref3","phoneNumber","BaseLogin","isWindowOpenedByFn","win","closeOpenedWindow","getOauthLoginUrl","authProvider","loginWithModal","result","loginWithEmailOtp","getOauthPopUpSizing","AuthProvider","FACEBOOK","loginWithOauth","args","openedWindow","open","oauthProvider","loginLink","all","location","reject","pollTimer","setInterval","closed","clearInterval","messageListener","origin","closeWindow","authResult","_win","developerClientId","authOption","storedToken","shouldStoreCookieString","walletDetails","isIframeStorageEnabled","loginWithCustomJwt","encryptionKey","jwt","loginWithCustomAuthEndpoint","_ref4","payload","verifyEmailLoginOtp","_ref5","otp","recoveryCode","verifySmsLoginOtp","_ref6","Auth","onAuthSuccess","AuthQuerier","logout","saveAuthCookie","cookieString","loginWithAuthToken","authToken","isRemoveAuthCookie","removeAuthCookie","isRemoveUserId","removeWalletUserId","IFrameWallet","walletManagerQuerier","postWalletSetUp","walletAddress","saveDeviceShare","getUserWalletStatus","userStatus","status","UserWalletStatus","LOGGED_IN_WALLET_INITIALIZED","user","account","getAccount","LOGGED_IN_NEW_DEVICE","LOGGED_IN_WALLET_UNINITIALIZED","address","_signTransaction","_tx$to","transaction","to","tx","value","gasLimit","gas","nonce","maxFeePerGas","accessList","maxPriorityFeePerGas","type","gasPrice","signedTransaction","rpcEndpoint","signTransaction","sendTransaction","rpcRequest","getRpcClient","chain","getCachedChain","signedTx","transactionHash","request","method","eth_sendRawTransaction","signMessage","message","messageDecoded","raw","signedMessage","signTypedData","_typedData","_parsedTypedData$type","_parsedTypedData$doma","parsedTypedData","types","EIP712Domain","Number","signedTypedData","InAppWebConnector","isClientIdLegacyPaper","indexOf","length","getThirdwebBaseUrl","wallet","auth","authDetails","userWalletId","getUser","preAuthenticate","strategy","assertUnreachable","authenticate","verificationCode","oauthStrategyToAuthProvider","registerPasskey","authenticatorType","username","passkeyName","loginWithPasskey","x"],"sourceRoot":""}