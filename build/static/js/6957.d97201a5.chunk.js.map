{"version":3,"file":"static/js/6957.d97201a5.chunk.js","mappings":"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","sources":["../node_modules/thirdweb/src/utils/signatures/helpers/parseTypedData.ts","../node_modules/thirdweb/src/wallets/injected/index.ts","../node_modules/thirdweb/src/wallets/utils/chains.ts","../node_modules/thirdweb/src/wallets/utils/normalizeChainId.ts","../node_modules/thirdweb/node_modules/viem/utils/regex.ts","../node_modules/thirdweb/node_modules/viem/utils/typedData.ts"],"sourcesContent":["import type { TypedData } from \"abitype\";\nimport type { TypedDataDefinition } from \"viem\";\nimport { type Hex, hexToNumber, isHex } from \"../../encoding/hex.js\";\n\ntype UnknownDomain = unknown & { chainId?: unknown }; // TODO: create our own typed data types so this is cleaner\ntype HexDomain = unknown & { chainId: Hex }; // TODO: create our own typed data types so this is cleaner\n\n/**\n * @internal\n */\nexport function parseTypedData<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n>(\n  typedData: TypedDataDefinition<typedData, primaryType>,\n): TypedDataDefinition<typedData, primaryType> {\n  const domain = typedData.domain as UnknownDomain;\n  if (domain?.chainId !== undefined && isHex(domain.chainId)) {\n    typedData.domain = {\n      ...(typedData.domain as HexDomain),\n      chainId: hexToNumber((typedData.domain as unknown as HexDomain).chainId),\n    } as unknown as TypedDataDefinition<typedData, primaryType>[\"domain\"];\n  }\n  return typedData;\n}\n","import type { Address } from \"abitype\";\nimport {\n  type SignTypedDataParameters,\n  getTypesForEIP712Domain,\n  validateTypedData,\n} from \"viem\";\nimport type { Chain } from \"../../chains/types.js\";\nimport { getCachedChain, getChainMetadata } from \"../../chains/utils.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport {\n  type Hex,\n  isHex,\n  numberToHex,\n  stringToHex,\n  uint8ArrayToHex,\n} from \"../../utils/encoding/hex.js\";\nimport { stringify } from \"../../utils/json.js\";\nimport type { Ethereum } from \"../interfaces/ethereum.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n  Wallet,\n} from \"../interfaces/wallet.js\";\nimport { getValidPublicRPCUrl } from \"../utils/chains.js\";\nimport { normalizeChainId } from \"../utils/normalizeChainId.js\";\nimport type { InjectedConnectOptions, WalletId } from \"../wallet-types.js\";\nimport { injectedProvider } from \"./mipdStore.js\";\n\nimport { parseTypedData } from \"../../utils/signatures/helpers/parseTypedData.js\";\nimport type { InjectedSupportedWalletIds } from \"../__generated__/wallet-ids.js\";\nimport type { DisconnectFn, SwitchChainFn } from \"../types.js\";\nimport type { WalletEmitter } from \"../wallet-emitter.js\";\n\n/**\n * Checks if the provided wallet is an injected wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is an injected wallet, false otherwise.\n */\nexport function isInjectedWallet(wallet: Wallet<WalletId>) {\n  return !!injectedProvider(wallet.id);\n}\n\n// TODO: save the provider in data\nexport function getInjectedProvider(walletId: WalletId) {\n  const provider = injectedProvider(walletId);\n  if (!provider) {\n    throw new Error(`No injected provider found for wallet: \"${walletId}\"`);\n  }\n\n  return provider;\n}\n\n/**\n * @internal\n */\nexport async function connectInjectedWallet(\n  id: InjectedSupportedWalletIds,\n  options: InjectedConnectOptions,\n  emitter: WalletEmitter<InjectedSupportedWalletIds>,\n): Promise<ReturnType<typeof onConnect>> {\n  const provider = getInjectedProvider(id);\n  const addresses = await provider.request({\n    method: \"eth_requestAccounts\",\n  });\n\n  const addr = addresses[0];\n  if (!addr) {\n    throw new Error(\"no accounts available\");\n  }\n\n  // use the first account\n  const address = getAddress(addr);\n\n  // get the chainId the provider is on\n  const chainId = await provider\n    .request({ method: \"eth_chainId\" })\n    .then(normalizeChainId);\n\n  let connectedChain =\n    options.chain && options.chain.id === chainId\n      ? options.chain\n      : getCachedChain(chainId);\n\n  // if we want a specific chainId and it is not the same as the provider chainId, trigger switchChain\n  if (options.chain && options.chain.id !== chainId) {\n    await switchChain(provider, options.chain);\n    connectedChain = options.chain;\n  }\n\n  return onConnect(provider, address, connectedChain, emitter);\n}\n\n/**\n * @internal\n */\nexport async function autoConnectInjectedWallet(\n  id: InjectedSupportedWalletIds,\n  emitter: WalletEmitter<InjectedSupportedWalletIds>,\n  chain?: Chain,\n): Promise<ReturnType<typeof onConnect>> {\n  const provider = getInjectedProvider(id);\n\n  // connected accounts\n  const addresses = await provider.request({\n    method: \"eth_accounts\",\n  });\n\n  const addr = addresses[0];\n  if (!addr) {\n    throw new Error(\"no accounts available\");\n  }\n\n  // use the first account\n  const address = getAddress(addr);\n\n  // get the chainId the provider is on\n  const chainId = await provider\n    .request({ method: \"eth_chainId\" })\n    .then(normalizeChainId);\n\n  const connectedChain =\n    chain && chain.id === chainId ? chain : getCachedChain(chainId);\n\n  return onConnect(provider, address, connectedChain, emitter);\n}\n\nfunction createAccount(provider: Ethereum, address: string) {\n  const account: Account = {\n    address,\n    async sendTransaction(tx: SendTransactionOption) {\n      const transactionHash = (await provider.request({\n        method: \"eth_sendTransaction\",\n        params: [\n          {\n            accessList: tx.accessList,\n            value: tx.value ? numberToHex(tx.value) : undefined,\n            gas: tx.gas ? numberToHex(tx.gas) : undefined,\n            from: this.address,\n            to: tx.to as Address,\n            data: tx.data,\n          },\n        ],\n      })) as Hex;\n\n      return {\n        transactionHash,\n      };\n    },\n    async signMessage({ message }) {\n      if (!account.address) {\n        throw new Error(\"Provider not setup\");\n      }\n\n      const messageToSign = (() => {\n        if (typeof message === \"string\") {\n          return stringToHex(message);\n        }\n        if (message.raw instanceof Uint8Array) {\n          return uint8ArrayToHex(message.raw);\n        }\n        return message.raw;\n      })();\n\n      return await provider.request({\n        method: \"personal_sign\",\n        params: [messageToSign, account.address],\n      });\n    },\n    async signTypedData(typedData) {\n      if (!provider || !account.address) {\n        throw new Error(\"Provider not setup\");\n      }\n      const parsedTypedData = parseTypedData(typedData);\n\n      const { domain, message, primaryType } =\n        parsedTypedData as unknown as SignTypedDataParameters;\n\n      const types = {\n        EIP712Domain: getTypesForEIP712Domain({ domain }),\n        ...parsedTypedData.types,\n      };\n\n      // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n      // as we can't statically check this with TypeScript.\n      validateTypedData({ domain, message, primaryType, types });\n\n      const stringifiedData = stringify(\n        { domain: domain ?? {}, message, primaryType, types },\n        (_, value) => (isHex(value) ? value.toLowerCase() : value),\n      );\n\n      return await provider.request({\n        method: \"eth_signTypedData_v4\",\n        params: [account.address, stringifiedData],\n      });\n    },\n  };\n\n  return account;\n}\n\n/**\n * Call this method when the wallet provider is connected or auto connected\n * @internal\n */\nasync function onConnect(\n  provider: Ethereum,\n  address: string,\n  chain: Chain,\n  emitter: WalletEmitter<InjectedSupportedWalletIds>,\n): Promise<[Account, Chain, DisconnectFn, SwitchChainFn]> {\n  const account = createAccount(provider, address);\n  async function disconnect() {\n    provider.removeListener(\"accountsChanged\", onAccountsChanged);\n    provider.removeListener(\"chainChanged\", onChainChanged);\n    provider.removeListener(\"disconnect\", onDisconnect);\n  }\n\n  function onDisconnect() {\n    disconnect();\n    emitter.emit(\"disconnect\", undefined);\n  }\n\n  function onAccountsChanged(accounts: string[]) {\n    if (accounts[0]) {\n      const newAccount = createAccount(provider, getAddress(accounts[0]));\n\n      emitter.emit(\"accountChanged\", newAccount);\n      emitter.emit(\"accountsChanged\", accounts);\n    } else {\n      onDisconnect();\n    }\n  }\n\n  function onChainChanged(newChainId: string) {\n    const newChain = getCachedChain(normalizeChainId(newChainId));\n    emitter.emit(\"chainChanged\", newChain);\n  }\n\n  if (provider.on) {\n    provider.on(\"accountsChanged\", onAccountsChanged);\n    provider.on(\"chainChanged\", onChainChanged);\n    provider.on(\"disconnect\", onDisconnect);\n  }\n\n  return [\n    account,\n    chain,\n    disconnect,\n    (newChain) => switchChain(provider, newChain),\n  ] as const;\n}\n\n/**\n * @internal\n */\nasync function switchChain(provider: Ethereum, chain: Chain) {\n  const hexChainId = numberToHex(chain.id);\n  try {\n    await provider.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{ chainId: hexChainId }],\n    });\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  } catch (e: any) {\n    // if chain does not exist, add the chain\n    if (e?.code === 4902 || e?.data?.originalError?.code === 4902) {\n      const apiChain = await getChainMetadata(chain);\n      await provider.request({\n        method: \"wallet_addEthereumChain\",\n        params: [\n          {\n            chainId: hexChainId,\n            chainName: apiChain.name,\n            nativeCurrency: apiChain.nativeCurrency,\n            rpcUrls: getValidPublicRPCUrl(apiChain), // no client id on purpose here\n            blockExplorerUrls: apiChain.explorers?.map((x) => x.url),\n          },\n        ],\n      });\n    } else {\n      throw e;\n    }\n  }\n}\n","import type { ChainMetadata } from \"../../chains/types.js\";\n\n// TODO - move this to chains subfolder\n\n/**\n * Remove client id from RPC url for given chain\n * @internal\n */\nexport function getValidPublicRPCUrl(chain: ChainMetadata) {\n  return getValidChainRPCs(chain).map((rpc) => {\n    try {\n      const url = new URL(rpc);\n      // remove client id from url\n      if (url.hostname.endsWith(\".thirdweb.com\")) {\n        url.pathname = \"\";\n        url.search = \"\";\n      }\n      return url.toString();\n    } catch (e) {\n      return rpc;\n    }\n  });\n}\n\n// TODO - move this to chains/\n/**\n * Get valid RPCs for given chain\n * @internal\n */\nfunction getValidChainRPCs(\n  chain: Pick<ChainMetadata, \"rpc\" | \"chainId\">,\n  clientId?: string,\n  mode: \"http\" | \"ws\" = \"http\",\n): string[] {\n  const processedRPCs: string[] = [];\n\n  for (const rpc of chain.rpc) {\n    // exclude RPC if mode mismatch\n    if (mode === \"http\" && !rpc.startsWith(\"http\")) {\n      continue;\n    }\n\n    if (mode === \"ws\" && !rpc.startsWith(\"ws\")) {\n      continue;\n    }\n\n    // Replace API_KEY placeholder with value\n    if (rpc.includes(\"${THIRDWEB_API_KEY}\")) {\n      if (clientId) {\n        processedRPCs.push(\n          rpc.replace(\"${THIRDWEB_API_KEY}\", clientId) +\n            (typeof globalThis !== \"undefined\" && \"APP_BUNDLE_ID\" in globalThis\n              ? // @ts-expect-error\n                `/?bundleId=${globalThis.APP_BUNDLE_ID}`\n              : \"\"),\n        );\n      } else {\n        // if no client id, let it through with empty string\n        // if secretKey is present, it will be used in header\n        // if none are passed, will have reduced access\n        processedRPCs.push(rpc.replace(\"${THIRDWEB_API_KEY}\", \"\"));\n      }\n    }\n\n    // exclude RPCs with unknown placeholder\n    else if (rpc.includes(\"${\")) {\n      // do nothing (just don't add it to the list)\n    }\n\n    // add as is\n    else {\n      processedRPCs.push(rpc);\n    }\n  }\n\n  if (processedRPCs.length === 0) {\n    throw new Error(\n      `No RPC available for chainId \"${chain.chainId}\" with mode ${mode}`,\n    );\n  }\n\n  return processedRPCs;\n}\n","import { hexToNumber, isHex } from \"../../utils/encoding/hex.js\";\n\n/**\n * @internal\n */\nexport function normalizeChainId(chainId: string | number | bigint): number {\n  if (typeof chainId === \"number\") {\n    return chainId;\n  }\n  if (isHex(chainId)) {\n    return hexToNumber(chainId);\n  }\n  if (typeof chainId === \"bigint\") {\n    return Number(chainId);\n  }\n  return Number.parseInt(chainId, 10);\n}\n","export const arrayRegex = /^(.*)\\[([0-9]*)\\]$/\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n","import type { TypedData, TypedDataDomain, TypedDataParameter } from 'abitype'\n\nimport { BytesSizeMismatchError } from '../errors/abi.js'\nimport { InvalidAddressError } from '../errors/address.js'\nimport type { Hex } from '../types/misc.js'\nimport type { TypedDataDefinition } from '../types/typedData.js'\n\nimport type { ErrorType } from '../errors/utils.js'\nimport { type IsAddressErrorType, isAddress } from './address/isAddress.js'\nimport { type SizeErrorType, size } from './data/size.js'\nimport { type NumberToHexErrorType, numberToHex } from './encoding/toHex.js'\nimport { bytesRegex, integerRegex } from './regex.js'\nimport {\n  type HashDomainErrorType,\n  hashDomain,\n} from './signature/hashTypedData.js'\n\nexport type ValidateTypedDataErrorType =\n  | HashDomainErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function validateTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(parameters: TypedDataDefinition<typedData, primaryType>) {\n  const { domain, message, primaryType, types } =\n    parameters as unknown as TypedDataDefinition\n\n  const validateData = (\n    struct: readonly TypedDataParameter[],\n    data: Record<string, unknown>,\n  ) => {\n    for (const param of struct) {\n      const { name, type } = param\n      const value = data[name]\n\n      const integerMatch = type.match(integerRegex)\n      if (\n        integerMatch &&\n        (typeof value === 'number' || typeof value === 'bigint')\n      ) {\n        const [_type, base, size_] = integerMatch\n        // If number cannot be cast to a sized hex value, it is out of range\n        // and will throw.\n        numberToHex(value, {\n          signed: base === 'int',\n          size: Number.parseInt(size_) / 8,\n        })\n      }\n\n      if (type === 'address' && typeof value === 'string' && !isAddress(value))\n        throw new InvalidAddressError({ address: value })\n\n      const bytesMatch = type.match(bytesRegex)\n      if (bytesMatch) {\n        const [_type, size_] = bytesMatch\n        if (size_ && size(value as Hex) !== Number.parseInt(size_))\n          throw new BytesSizeMismatchError({\n            expectedSize: Number.parseInt(size_),\n            givenSize: size(value as Hex),\n          })\n      }\n\n      const struct = types[type]\n      if (struct) validateData(struct, value as Record<string, unknown>)\n    }\n  }\n\n  // Validate domain types.\n  if (types.EIP712Domain && domain) validateData(types.EIP712Domain, domain)\n\n  if (primaryType !== 'EIP712Domain') {\n    // Validate message types.\n    const type = types[primaryType]\n    validateData(type, message)\n  }\n}\n\nexport type GetTypesForEIP712DomainErrorType = ErrorType\n\nexport function getTypesForEIP712Domain({\n  domain,\n}: { domain?: TypedDataDomain | undefined }): TypedDataParameter[] {\n  return [\n    typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n    domain?.version && { name: 'version', type: 'string' },\n    typeof domain?.chainId === 'number' && {\n      name: 'chainId',\n      type: 'uint256',\n    },\n    domain?.verifyingContract && {\n      name: 'verifyingContract',\n      type: 'address',\n    },\n    domain?.salt && { name: 'salt', type: 'bytes32' },\n  ].filter(Boolean) as TypedDataParameter[]\n}\n\nexport type DomainSeparatorErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | ErrorType\n\nexport function domainSeparator({ domain }: { domain: TypedDataDomain }): Hex {\n  return hashDomain({\n    domain,\n    types: {\n      EIP712Domain: getTypesForEIP712Domain({ domain }),\n    },\n  })\n}\n"],"names":["parseTypedData","typedData","domain","undefined","chainId","isHex","hexToNumber","getInjectedProvider","walletId","provider","injectedProvider","Error","concat","async","connectInjectedWallet","id","options","emitter","addr","request","method","address","getAddress","then","normalizeChainId","connectedChain","chain","getCachedChain","switchChain","onConnect","autoConnectInjectedWallet","createAccount","account","sendTransaction","tx","transactionHash","params","accessList","value","numberToHex","gas","from","this","to","data","signMessage","_ref","message","messageToSign","stringToHex","raw","Uint8Array","uint8ArrayToHex","signTypedData","parsedTypedData","primaryType","types","EIP712Domain","getTypesForEIP712Domain","validateTypedData","stringifiedData","stringify","_","toLowerCase","disconnect","removeListener","onAccountsChanged","onChainChanged","onDisconnect","emit","accounts","newAccount","newChainId","newChain","on","hexChainId","e","_e$data","code","originalError","_apiChain$explorers","apiChain","getChainMetadata","chainName","name","nativeCurrency","rpcUrls","getValidPublicRPCUrl","blockExplorerUrls","explorers","map","x","url","clientId","mode","arguments","length","processedRPCs","rpc","startsWith","includes","push","replace","globalThis","APP_BUNDLE_ID","getValidChainRPCs","URL","hostname","endsWith","pathname","search","toString","Number","parseInt","bytesRegex","integerRegex","parameters","validateData","struct","param","type","integerMatch","match","_type","base","size_","signed","size","isAddress","InvalidAddressError","bytesMatch","BytesSizeMismatchError","expectedSize","givenSize","version","verifyingContract","salt","filter","Boolean"],"sourceRoot":""}