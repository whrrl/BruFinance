{"version":3,"file":"static/js/14270.a55ceccd.chunk.js","mappings":"uKAgBO,MAAMA,EAAc,aACrBC,EAAY,CAChB,CACEC,KAAM,UACNC,KAAM,aAGJC,EAAa,CACjB,CACEF,KAAM,WA2FHG,eAAeC,EACpBC,GAEA,OAAOC,EAAAA,EAAAA,cAAa,CAClBC,SAAUF,EAAQE,SAClBC,OAAQ,CAACV,EAAaC,EAAWG,GACjCO,OAAQ,CAACJ,EAAQK,UAErB,CCzFOP,eAAeQ,EACpBN,GAEA,MAAOO,EAAKC,SAAeC,QAAQC,IAAI,CACrCX,EAASC,GAASW,OAAM,IAAM,OAC9BX,EAAQY,aACJ,iCACGC,MAAMC,GAAMA,EAAEC,QAAQf,KACtBW,OAAM,IAAM,OACf,OAGN,OAAKJ,GAgBES,EAAAA,EAAAA,SACCC,EAAAA,EAAAA,GAAmB,CACvBC,OAAQlB,EAAQE,SAASgB,OACzBb,QAASL,EAAQK,QACjBc,SAAUZ,IACTI,OAAM,KAAM,CACbS,GAAIpB,EAAQK,QACZV,KAAM,SACNY,UAEF,CACEF,QAASL,EAAQK,QACjBc,SAAUZ,EACVZ,KAAM,SACNa,WA7BKQ,EAAAA,EAAAA,GACL,CACEI,GAAIpB,EAAQK,QACZV,KAAM,SACNY,IAAK,IAEP,CACEF,QAASL,EAAQK,QACjBc,SAAU,GACVxB,KAAM,SACNa,SAsBR,C,gEC3DOV,eAAemB,EACpBjB,GAEA,MAAM,OAAEkB,EAAM,QAAEb,EAAO,SAAEc,GAAanB,EAEtC,GAAiBmB,ECVPE,WAAW,gCDWnB,IACE,OAAOC,KAAKC,MCIZ,SAA4BC,GAChC,MAAO,CAAEC,GAAUD,EAAME,MAAM,KAC/B,OAAOC,EAAAA,EAAAA,IAAeF,EACxB,CDPwBG,CAAkBT,GACtC,CAAE,MAAOU,GAMP,MALAC,QAAQC,MACN,qCACA,CAAE1B,UAASc,YACXU,GAEIA,CACR,CAIF,MAAM,SAAEG,SAAmB,wCAG3B,IACE,IAAKb,EAASc,SAAS,QACrB,mBAAoBD,EAAS,CAAEd,SAAQX,IAAKY,KAAae,MAE7D,CAAE,MAAOL,GAEP,MADAC,QAAQC,MAAM,kCAAmC,CAAE1B,UAASc,YAAYU,GAClEA,CACR,CAGA,IACE,IAEE,mBACQG,EAAS,CACbd,SACAX,IAAKY,EAASgB,QACZ,QACAC,EAAAA,EAAAA,IAAY/B,EAAS,CAAEgC,KAAM,KAAMC,MAAM,OAG7CJ,MACJ,CAAE,MAAOK,GAEP,mBACQP,EAAS,CACbd,SACAX,IAAKY,EAASgB,QAAQ,OAAQ9B,EAAQmC,eAExCN,MACJ,CACF,CAAE,MAAOL,GAEP,MADAC,QAAQC,MAAM,8BAA+B,CAAE1B,UAASc,YAAYU,GAC9DA,CACR,CACF,C,kBEJM,SAAUb,EAASyB,EAAmBzC,GAAwB,IAAA0C,EAAAC,EAClE,OAAQ3C,EAAQL,MACd,IAAK,SACH,MAAO,CACLiD,SAAUH,EACVjC,MAAqB,QAAhBkC,EAAS,OAAP1C,QAAO,IAAPA,OAAO,EAAPA,EAASQ,aAAK,IAAAkC,EAAAA,EAAI,KACzBtB,GAAIpB,EAAQK,QACZN,SAAUC,EAAQmB,SAClBxB,KAAMK,EAAQL,MAElB,IAAK,UACH,MAAO,CACLiD,SAAUH,EACVjC,MAAqB,QAAhBmC,EAAS,OAAP3C,QAAO,IAAPA,OAAO,EAAPA,EAASQ,aAAK,IAAAmC,EAAAA,EAAI,KACzBvB,GAAIpB,EAAQK,QACZN,SAAUC,EAAQmB,SAClBxB,KAAMK,EAAQL,KACdkD,OAAQ7C,EAAQ6C,QAEpB,QACE,MAAM,IAAIC,MAAM,oBAEtB,C,kCChGA,IAAIC,E,oCCEJ,MAAMC,EAAwB,sBAe9B,SAASC,EAAiBC,GACxB,IAAKC,EAAaD,GAChB,MAAM,IAAIE,UAAU,+BAADC,cAA0CH,EAAK,KAEtE,CAoBM,SAAUC,EAAaD,GAC3B,QAAKA,IAIDA,EAAMI,cAAgBC,YAInBC,OAAOC,UAAUjB,SAASkB,KAAKR,KAAWF,EACnD,CAqBM,SAAUW,EAAoBC,EAAeC,GAIjD,GAHAZ,EAAiBW,GACjBX,EAAiBY,GAEbD,IAAMC,EACR,OAAO,EAGT,GAAID,EAAEE,SAAWD,EAAEC,OACjB,OAAO,EAGT,IAAK,IAAIC,EAAQ,EAAGA,EAAQH,EAAEE,OAAQC,IACpC,GAAIH,EAAEG,KAAWF,EAAEE,GACjB,OAAO,EAIX,OAAO,CACT,CAgBM,SAAUC,EAAmBC,GAEjC,OADAhB,EAAiBgB,IDnGZlB,IACHA,EAAc,IAAImB,aAEbnB,GCiGoBoB,OAAOF,EACpC,CAEA,SAASG,EAAalB,GACpB,GAAqB,kBAAVA,EACT,MAAM,IAAIE,UAAU,2BAADC,cAAsCH,EAAK,KAElE,CAwCM,SAAUvB,EAAe0C,GAE7B,OADAD,EAAaC,GACNL,EAxBH,SAA6BK,GAEjC,OADAD,EAAaC,GACNd,WAAWe,KAChBC,WAAWC,KAAuBH,EAlBnBI,WAAW,IAAK,KAAKA,WAAW,IAAK,OAqBnDC,GAAMA,EAAEC,YAAY,IAEzB,CAgB4BC,CAAmBP,GAC/C,C","sources":["../node_modules/thirdweb/src/extensions/erc721/__generated__/IERC721A/read/tokenURI.ts","../node_modules/thirdweb/src/extensions/erc721/read/getNFT.ts","../node_modules/thirdweb/src/utils/nft/fetchTokenMetadata.ts","../node_modules/thirdweb/src/utils/base64/base64.ts","../node_modules/thirdweb/src/utils/nft/parseNft.ts","../node_modules/thirdweb/src/utils/text-decoder.ts","../node_modules/thirdweb/src/utils/uint8-array.ts"],"sourcesContent":["import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"tokenURI\" function.\n */\nexport type TokenURIParams = {\n  tokenId: AbiParameterToPrimitiveType<{ type: \"uint256\"; name: \"_tokenId\" }>;\n};\n\nexport const FN_SELECTOR = \"0xc87b56dd\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"uint256\",\n    name: \"_tokenId\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"string\",\n  },\n] as const;\n\n/**\n * Checks if the `tokenURI` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `tokenURI` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isTokenURISupported } from \"thirdweb/extensions/erc721\";\n *\n * const supported = await isTokenURISupported(contract);\n * ```\n */\nexport async function isTokenURISupported(contract: ThirdwebContract<any>) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"tokenURI\" function.\n * @param options - The options for the tokenURI function.\n * @returns The encoded ABI parameters.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeTokenURIParams } \"thirdweb/extensions/erc721\";\n * const result = encodeTokenURIParams({\n *  tokenId: ...,\n * });\n * ```\n */\nexport function encodeTokenURIParams(options: TokenURIParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.tokenId]);\n}\n\n/**\n * Encodes the \"tokenURI\" function into a Hex string with its parameters.\n * @param options - The options for the tokenURI function.\n * @returns The encoded hexadecimal string.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeTokenURI } \"thirdweb/extensions/erc721\";\n * const result = encodeTokenURI({\n *  tokenId: ...,\n * });\n * ```\n */\nexport function encodeTokenURI(options: TokenURIParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeTokenURIParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the tokenURI function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC721\n * @example\n * ```ts\n * import { decodeTokenURIResult } from \"thirdweb/extensions/erc721\";\n * const result = decodeTokenURIResult(\"...\");\n * ```\n */\nexport function decodeTokenURIResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"tokenURI\" function on the contract.\n * @param options - The options for the tokenURI function.\n * @returns The parsed result of the function call.\n * @extension ERC721\n * @example\n * ```ts\n * import { tokenURI } from \"thirdweb/extensions/erc721\";\n *\n * const result = await tokenURI({\n *  contract,\n *  tokenId: ...,\n * });\n *\n * ```\n */\nexport async function tokenURI(\n  options: BaseTransactionOptions<TokenURIParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.tokenId],\n  });\n}\n","import type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { fetchTokenMetadata } from \"../../../utils/nft/fetchTokenMetadata.js\";\nimport { type NFT, parseNFT } from \"../../../utils/nft/parseNft.js\";\nimport type { Prettify } from \"../../../utils/type-utils.js\";\nimport {\n  type TokenURIParams,\n  tokenURI,\n} from \"../__generated__/IERC721A/read/tokenURI.js\";\n\n/**\n * Parameters for getting an NFT.\n */\nexport type GetNFTParams = Prettify<\n  TokenURIParams & {\n    /**\n     * Whether to include the owner of the NFT.\n     */\n    includeOwner?: boolean;\n  }\n>;\n\n/**\n * Retrieves information about a specific ERC721 non-fungible token (NFT).\n * @param options - The options for retrieving the NFT.\n * @returns A promise that resolves to the NFT object.\n * @extension ERC721\n * @example\n * ```ts\n * import { getNFT } from \"thirdweb/extensions/erc721\";\n * const nft = await getNFT({\n *  contract,\n *  tokenId: 1n,\n * });\n * ```\n */\nexport async function getNFT(\n  options: BaseTransactionOptions<GetNFTParams>,\n): Promise<NFT> {\n  const [uri, owner] = await Promise.all([\n    tokenURI(options).catch(() => null),\n    options.includeOwner\n      ? import(\"../__generated__/IERC721A/read/ownerOf.js\")\n          .then((m) => m.ownerOf(options))\n          .catch(() => null)\n      : null,\n  ]);\n\n  if (!uri) {\n    return parseNFT(\n      {\n        id: options.tokenId,\n        type: \"ERC721\",\n        uri: \"\",\n      },\n      {\n        tokenId: options.tokenId,\n        tokenUri: \"\",\n        type: \"ERC721\",\n        owner,\n      },\n    );\n  }\n\n  return parseNFT(\n    await fetchTokenMetadata({\n      client: options.contract.client,\n      tokenId: options.tokenId,\n      tokenUri: uri,\n    }).catch(() => ({\n      id: options.tokenId,\n      type: \"ERC721\",\n      uri,\n    })),\n    {\n      tokenId: options.tokenId,\n      tokenUri: uri,\n      type: \"ERC721\",\n      owner,\n    },\n  );\n}\n","import type { ThirdwebClient } from \"../../client/client.js\";\nimport { isBase64JSON, parseBase64String } from \"../base64/base64.js\";\nimport { numberToHex } from \"../encoding/hex.js\";\nimport type { NFTMetadata } from \"./parseNft.js\";\n\n/**\n * @internal\n */\nexport type FetchTokenMetadataOptions = {\n  client: ThirdwebClient;\n  tokenId: bigint;\n  tokenUri: string;\n};\n\n/**\n * Fetches the metadata for a token.\n *\n * @param options - The options for fetching the token metadata.\n * @returns The token metadata.\n * @internal\n */\nexport async function fetchTokenMetadata(\n  options: FetchTokenMetadataOptions,\n): Promise<NFTMetadata> {\n  const { client, tokenId, tokenUri } = options;\n  // handle case where the URI is a base64 encoded JSON (onchain nft)\n  if (isBase64JSON(tokenUri)) {\n    try {\n      return JSON.parse(parseBase64String(tokenUri));\n    } catch (e) {\n      console.error(\n        \"Failed to fetch base64 encoded NFT\",\n        { tokenId, tokenUri },\n        e,\n      );\n      throw e;\n    }\n  }\n\n  // in all other cases we will need the `download` function from storage\n  const { download } = await import(\"../../storage/download.js\");\n\n  // handle non-dynamic uris (most common case -> skip the other checks)\n  try {\n    if (!tokenUri.includes(\"{id}\")) {\n      return await (await download({ client, uri: tokenUri })).json();\n    }\n  } catch (e) {\n    console.error(\"Failed to fetch non-dynamic NFT\", { tokenId, tokenUri }, e);\n    throw e;\n  }\n\n  // DYNAMIC NFT FORMATS (2 options, sadly has to be waterfall)\n  try {\n    try {\n      // try first dynamic id format\n      return await (\n        await download({\n          client,\n          uri: tokenUri.replace(\n            \"{id}\",\n            numberToHex(tokenId, { size: 32 }).slice(2),\n          ),\n        })\n      ).json();\n    } catch (err) {\n      // otherwise attempt the second format\n      return await (\n        await download({\n          client,\n          uri: tokenUri.replace(\"{id}\", tokenId.toString()),\n        })\n      ).json();\n    }\n  } catch (e) {\n    console.error(\"Failed to fetch dynamic NFT\", { tokenId, tokenUri }, e);\n    throw e;\n  }\n}\n","import { base64ToString } from \"../uint8-array.js\";\n\ntype Base64Prefix = \"data:application/json;base64\";\ntype Base64String = `${Base64Prefix},${string}`;\n\n/**\n * Checks if a given string is a base64 encoded JSON string.\n * @param input - The string to be checked.\n * @returns True if the input string starts with \"data:application/json;base64\", false otherwise.\n * @example\n * ```ts\n * isBase64JSON(\"data:application/json;base64,eyJ0ZXN0IjoiYmFzZTY0In0=\")\n * // true\n * ```\n */\nexport function isBase64JSON(input: string): input is Base64String {\n  if (input.startsWith(\"data:application/json;base64\")) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Parses a base64 string and returns the decoded string.\n * @param input - The base64 string to parse.\n * @returns The decoded string.\n * @example\n * ```ts\n * parseBase64String(\"data:application/json;base64,eyJ0ZXN0IjoiYmFzZTY0In0=\")\n * // '{\"test\":\"base64\"}'\n * ```\n */\nexport function parseBase64String(input: Base64String) {\n  const [, base64] = input.split(\",\") as [Base64Prefix, string];\n  return base64ToString(base64);\n}\n","import type { FileOrBufferOrString } from \"../../storage/upload/types.js\";\nimport type { Prettify } from \"../type-utils.js\";\n\n/**\n * Represents the input data for creating an NFT (Non-Fungible Token).\n */\nexport type NFTInput = Prettify<\n  {\n    name?: string;\n    description?: string;\n    image?: FileOrBufferOrString;\n    animation_url?: FileOrBufferOrString;\n    external_url?: FileOrBufferOrString;\n    background_color?: string;\n    // TODO check if we truly need both of these?\n    properties?: Record<string, unknown> | Array<Record<string, unknown>>;\n  } & Record<string, unknown>\n>;\n\nexport type NFTMetadata = {\n  id: bigint;\n  uri: string;\n  name?: string;\n  description?: string;\n  image?: string;\n  animation_url?: string;\n  external_url?: string;\n  background_color?: string;\n  properties?: Record<string, unknown>;\n  attributes?: Record<string, unknown>;\n} & Record<string, unknown>;\n\nexport type NFT =\n  | {\n      metadata: NFTMetadata;\n      owner: string | null;\n      id: bigint;\n      tokenURI: string;\n      type: \"ERC721\";\n    }\n  | {\n      metadata: NFTMetadata;\n      owner: string | null;\n      id: bigint;\n      tokenURI: string;\n      type: \"ERC1155\";\n      supply: bigint;\n    };\n\n/**\n * @internal\n */\nexport type ParseNFTOptions =\n  | {\n      tokenId: bigint;\n      tokenUri: string;\n      type: \"ERC721\";\n      owner?: string | null;\n    }\n  | {\n      tokenId: bigint;\n      tokenUri: string;\n      type: \"ERC1155\";\n      owner?: string | null;\n      supply: bigint;\n    };\n\n/**\n * Parses the NFT metadata and options to create an NFT object.\n * @param base - The base NFT metadata.\n * @param options - The options for parsing the NFT.\n * @returns The parsed NFT object.\n * @internal\n */\nexport function parseNFT(base: NFTMetadata, options: ParseNFTOptions): NFT {\n  switch (options.type) {\n    case \"ERC721\":\n      return {\n        metadata: base,\n        owner: options?.owner ?? null,\n        id: options.tokenId,\n        tokenURI: options.tokenUri,\n        type: options.type,\n      };\n    case \"ERC1155\":\n      return {\n        metadata: base,\n        owner: options?.owner ?? null,\n        id: options.tokenId,\n        tokenURI: options.tokenUri,\n        type: options.type,\n        supply: options.supply,\n      };\n    default:\n      throw new Error(\"Invalid NFT type\");\n  }\n}\n","let textDecoder: TextDecoder;\n\n/**\n * Re-using the same textdecoder is faster.\n *\n * @returns\n * @internal\n */\nexport function cachedTextDecoder(): TextDecoder {\n  if (!textDecoder) {\n    textDecoder = new TextDecoder();\n  }\n  return textDecoder;\n}\n","import { cachedTextDecoder } from \"./text-decoder.js\";\n\nconst uint8ArrayStringified = \"[object Uint8Array]\";\n\n/**\n * Throw a `TypeError` if the given value is not an instance of `Uint8Array`.\n * @example\n * ```ts\n * import {assertUint8Array} from 'uint8array-extras';\n *\n * try {\n * assertUint8Array(new ArrayBuffer(10)); // Throws a TypeError\n * } catch (error) {\n * console.error(error.message);\n * }\n * ```\n */\nfunction assertUint8Array(value: unknown): asserts value is Uint8Array {\n  if (!isUint8Array(value)) {\n    throw new TypeError(`Expected \\`Uint8Array\\`, got \\`${typeof value}\\``);\n  }\n}\n\n/**\n * Check if the given value is an instance of `Uint8Array`.\n *\n * Replacement for [`Buffer.isBuffer()`](https://nodejs.org/api/buffer.html#static-method-bufferisbufferobj).\n * @example\n * ```ts\n * import {isUint8Array} from 'uint8array-extras';\n *\n * console.log(isUint8Array(new Uint8Array()));\n * //=> true\n *\n * console.log(isUint8Array(Buffer.from('x')));\n * //=> true\n *\n * console.log(isUint8Array(new ArrayBuffer(10)));\n * //=> false\n * ```\n */\nexport function isUint8Array(value: unknown): value is Uint8Array {\n  if (!value) {\n    return false;\n  }\n\n  if (value.constructor === Uint8Array) {\n    return true;\n  }\n\n  return Object.prototype.toString.call(value) === uint8ArrayStringified;\n}\n\n/**\n * Check if two arrays are identical by verifying that they contain the same bytes in the same sequence.\n *\n * Replacement for [`Buffer#equals()`](https://nodejs.org/api/buffer.html#bufequalsotherbuffer).\n * @example\n * ```ts\n * import {areUint8ArraysEqual} from 'uint8array-extras';\n *\n * const a = new Uint8Array([1, 2, 3]);\n * const b = new Uint8Array([1, 2, 3]);\n * const c = new Uint8Array([4, 5, 6]);\n *\n * console.log(areUint8ArraysEqual(a, b));\n * //=> true\n *\n * console.log(areUint8ArraysEqual(a, c));\n * //=> false\n * ```\n */\nexport function areUint8ArraysEqual(a: Uint8Array, b: Uint8Array): boolean {\n  assertUint8Array(a);\n  assertUint8Array(b);\n\n  if (a === b) {\n    return true;\n  }\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let index = 0; index < a.length; index++) {\n    if (a[index] !== b[index]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Convert a `Uint8Array` (containing a UTF-8 string) to a string.\n *\n * Replacement for [`Buffer#toString()`](https://nodejs.org/api/buffer.html#buftostringencoding-start-end).\n * @example\n * ```ts\n * import {uint8ArrayToString} from 'uint8array-extras';\n *\n * const byteArray = new Uint8Array([72, 101, 108, 108, 111]);\n *\n * console.log(uint8ArrayToString(byteArray));\n * //=> 'Hello'\n * ```\n */\nexport function uint8ArrayToString(array: Uint8Array): string {\n  assertUint8Array(array);\n  return cachedTextDecoder().decode(array);\n}\n\nfunction assertString(value: unknown): asserts value is string {\n  if (typeof value !== \"string\") {\n    throw new TypeError(`Expected \\`string\\`, got \\`${typeof value}\\``);\n  }\n}\n\nfunction base64UrlToBase64(base64url: string) {\n  return base64url.replaceAll(\"-\", \"+\").replaceAll(\"_\", \"/\");\n}\n\n/**\n * Convert a Base64-encoded or [Base64URL](https://base64.guru/standards/base64url)-encoded string to a `Uint8Array`.\n *\n * Replacement for [`Buffer.from('SGVsbG8=', 'base64')`](https://nodejs.org/api/buffer.html#static-method-bufferfromstring-encoding).\n * @example\n * ```ts\n * import {base64ToUint8Array} from 'uint8array-extras';\n *\n * console.log(base64ToUint8Array('SGVsbG8='));\n * //=> Uint8Array [72, 101, 108, 108, 111]\n * ```\n */\nexport function base64ToUint8Array(base64String: string): Uint8Array {\n  assertString(base64String);\n  return Uint8Array.from(\n    globalThis.atob(base64UrlToBase64(base64String)),\n\n    // biome-ignore lint/style/noNonNullAssertion: we know that the code points exist\n    (x) => x.codePointAt(0)!,\n  );\n}\n\n/**\n * Decode a Base64-encoded or [Base64URL](https://base64.guru/standards/base64url)-encoded string to a string.\n *\n * Replacement for `Buffer.from('SGVsbG8=', 'base64').toString()` and [`atob()`](https://developer.mozilla.org/en-US/docs/Web/API/atob).\n * @example\n * ```ts\n * import {base64ToString} from 'uint8array-extras';\n *\n * console.log(base64ToString('SGVsbG8='));\n * //=> 'Hello'\n * ```\n */\nexport function base64ToString(base64String: string): string {\n  assertString(base64String);\n  return uint8ArrayToString(base64ToUint8Array(base64String));\n}\n\nfunction base64ToBase64Url(base64: string): string {\n  return base64.replaceAll(\"+\", \"-\").replaceAll(\"/\", \"_\").replace(/=+$/, \"\");\n}\n// Reference: https://phuoc.ng/collection/this-vs-that/concat-vs-push/\nconst MAX_BLOCK_SIZE = 65_535;\n\nexport function uint8ArrayToBase64(\n  array: Uint8Array,\n  { urlSafe = false } = {},\n): string {\n  assertUint8Array(array);\n\n  let base64: string;\n\n  if (array.length < MAX_BLOCK_SIZE) {\n    // Required as `btoa` and `atob` don't properly support Unicode: https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem\n    // @ts-expect-error - TS doesn't know about `String#fromCodePoint`\n    base64 = globalThis.btoa(String.fromCodePoint.apply(this, array));\n  } else {\n    base64 = \"\";\n    for (const value of array) {\n      base64 += String.fromCodePoint(value);\n    }\n\n    base64 = globalThis.btoa(base64);\n  }\n\n  return urlSafe ? base64ToBase64Url(base64) : base64;\n}\n\nexport function concatUint8Arrays(\n  arrays: Uint8Array[],\n  totalLength?: number,\n): Uint8Array {\n  if (arrays.length === 0) {\n    return new Uint8Array(0);\n  }\n\n  const calculatedTotalLength =\n    totalLength ??\n    arrays.reduce(\n      (accumulator, currentValue) => accumulator + currentValue.length,\n      0,\n    );\n\n  const returnValue = new Uint8Array(calculatedTotalLength);\n\n  let offset = 0;\n  for (const array of arrays) {\n    assertUint8Array(array);\n    returnValue.set(array, offset);\n    offset += array.length;\n  }\n\n  return returnValue;\n}\n\nexport function compareUint8Arrays(a: Uint8Array, b: Uint8Array): number {\n  assertUint8Array(a);\n  assertUint8Array(b);\n\n  const length = Math.min(a.length, b.length);\n\n  for (let index = 0; index < length; index++) {\n    // biome-ignore lint/style/noNonNullAssertion: we check the length above so the index is always in bounds\n    const diff = a[index]! - b[index]!;\n    if (diff !== 0) {\n      return Math.sign(diff);\n    }\n  }\n\n  // At this point, all the compared elements are equal.\n  // The shorter array should come first if the arrays are of different lengths.\n  return Math.sign(a.length - b.length);\n}\n"],"names":["FN_SELECTOR","FN_INPUTS","type","name","FN_OUTPUTS","async","tokenURI","options","readContract","contract","method","params","tokenId","getNFT","uri","owner","Promise","all","catch","includeOwner","then","m","ownerOf","parseNFT","fetchTokenMetadata","client","tokenUri","id","startsWith","JSON","parse","input","base64","split","base64ToString","parseBase64String","e","console","error","download","includes","json","replace","numberToHex","size","slice","err","toString","base","_options$owner","_options$owner2","metadata","supply","Error","textDecoder","uint8ArrayStringified","assertUint8Array","value","isUint8Array","TypeError","concat","constructor","Uint8Array","Object","prototype","call","areUint8ArraysEqual","a","b","length","index","uint8ArrayToString","array","TextDecoder","decode","assertString","base64String","from","globalThis","atob","replaceAll","x","codePointAt","base64ToUint8Array"],"sourceRoot":""}