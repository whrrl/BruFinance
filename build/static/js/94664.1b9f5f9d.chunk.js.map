{"version":3,"file":"static/js/94664.1b9f5f9d.chunk.js","mappings":"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","sources":["../node_modules/@thirdweb-dev/wallets/dist/WagmiConnector-2f14002d.browser.esm.js","../node_modules/@thirdweb-dev/wallets/dist/errors-9edc08c8.browser.esm.js","../node_modules/@thirdweb-dev/wallets/dist/normalizeChainId-1fb9aedf.browser.esm.js","../node_modules/@thirdweb-dev/wallets/evm/connectors/injected/dist/thirdweb-dev-wallets-evm-connectors-injected.browser.esm.js","../node_modules/@thirdweb-dev/wallets/evm/connectors/okx/dist/thirdweb-dev-wallets-evm-connectors-okx.browser.esm.js"],"sourcesContent":["import { defaultChains } from '@thirdweb-dev/chains';\nimport EventEmitter from 'eventemitter3';\n\nclass WagmiConnector extends EventEmitter {\n  /** Unique connector id */\n\n  /** Connector name */\n\n  /** Chains connector supports */\n\n  /** Options to use with connector */\n\n  /** Whether connector is usable */\n\n  constructor(_ref) {\n    let {\n      chains = defaultChains,\n      options\n    } = _ref;\n    super();\n    this.chains = chains;\n    this.options = options;\n  }\n  getBlockExplorerUrls(chain) {\n    const explorers = chain.explorers?.map(x => x.url) ?? [];\n    return explorers.length > 0 ? explorers : undefined;\n  }\n  isChainUnsupported(chainId) {\n    return !this.chains.some(x => x.chainId === chainId);\n  }\n  updateChains(chains) {\n    this.chains = chains;\n  }\n}\n\nexport { WagmiConnector as W };\n","import { _ as _defineProperty } from './defineProperty-350fc508.browser.esm.js';\n\n/**\n * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors per EIP-1474.\n * @see https://eips.ethereum.org/EIPS/eip-1474\n */\nclass RpcError extends Error {\n  constructor( /** Human-readable string */\n  message, options) {\n    const {\n      cause,\n      code,\n      data\n    } = options;\n    if (!Number.isInteger(code)) {\n      throw new Error('\"code\" must be an integer.');\n    }\n    if (!message || typeof message !== \"string\") {\n      throw new Error('\"message\" must be a nonempty string.');\n    }\n    super(`${message}. Cause: ${JSON.stringify(cause)}`);\n    this.cause = cause;\n    this.code = code;\n    this.data = data;\n  }\n}\n\n/**\n * @internal\n * Error subclass implementing Ethereum Provider errors per EIP-1193.\n * @see https://eips.ethereum.org/EIPS/eip-1193\n */\nclass ProviderRpcError extends RpcError {\n  /**\n   * Create an Ethereum Provider JSON-RPC error.\n   * `code` must be an integer in the `1000 <= 4999` range.\n   */\n  constructor( /** Human-readable string */\n  message, options) {\n    const {\n      cause,\n      code,\n      data\n    } = options;\n    if (!(Number.isInteger(code) && code >= 1000 && code <= 4999)) {\n      throw new Error('\"code\" must be an integer such that: 1000 <= code <= 4999');\n    }\n    super(message, {\n      cause,\n      code,\n      data\n    });\n  }\n}\n\n/**\n * @internal\n */\nclass AddChainError extends Error {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"name\", \"AddChainError\");\n    _defineProperty(this, \"message\", \"Error adding chain\");\n  }\n}\n\n/**\n * @internal\n */\nclass ChainNotConfiguredError extends Error {\n  constructor(_ref) {\n    let {\n      chainId,\n      connectorId\n    } = _ref;\n    super(`Chain \"${chainId}\" not configured for connector \"${connectorId}\".`);\n    _defineProperty(this, \"name\", \"ChainNotConfigured\");\n  }\n}\nclass ConnectorNotFoundError extends Error {\n  constructor() {\n    super(...arguments);\n    _defineProperty(this, \"name\", \"ConnectorNotFoundError\");\n    _defineProperty(this, \"message\", \"Connector not found\");\n  }\n}\nclass ResourceUnavailableError extends RpcError {\n  constructor(cause) {\n    super(\"Resource unavailable\", {\n      cause,\n      code: -32002\n    });\n    _defineProperty(this, \"name\", \"ResourceUnavailable\");\n  }\n}\n/**\n * @internal\n */\nclass SwitchChainError extends ProviderRpcError {\n  constructor(cause) {\n    super(\"Error switching chain\", {\n      cause,\n      code: 4902\n    });\n    _defineProperty(this, \"name\", \"SwitchChainError\");\n  }\n}\n/**\n * @internal\n */\nclass UserRejectedRequestError extends ProviderRpcError {\n  constructor(cause) {\n    super(\"User rejected request\", {\n      cause,\n      code: 4001\n    });\n    _defineProperty(this, \"name\", \"UserRejectedRequestError\");\n  }\n}\n\n/**\n * @internal\n */\n// Ethers does not have an error type so we can use this for casting\n// https://github.com/ethers-io/ethers.js/blob/main/packages/logger/src.ts/index.ts#L268\n\nexport { AddChainError as A, ChainNotConfiguredError as C, ProviderRpcError as P, ResourceUnavailableError as R, SwitchChainError as S, UserRejectedRequestError as U, ConnectorNotFoundError as a };\n","/**\n * @internal\n */\nfunction normalizeChainId(chainId) {\n  if (typeof chainId === \"string\") {\n    return Number.parseInt(chainId, chainId.trim().substring(0, 2) === \"0x\" ? 16 : 10);\n  }\n  if (typeof chainId === \"bigint\") {\n    return Number(chainId);\n  }\n  return chainId;\n}\n\nexport { normalizeChainId as n };\n","import { _ as _defineProperty } from '../../../../dist/defineProperty-350fc508.browser.esm.js';\nimport { W as WagmiConnector } from '../../../../dist/WagmiConnector-2f14002d.browser.esm.js';\nimport { a as ConnectorNotFoundError, U as UserRejectedRequestError, R as ResourceUnavailableError, C as ChainNotConfiguredError, A as AddChainError, S as SwitchChainError } from '../../../../dist/errors-9edc08c8.browser.esm.js';\nimport { a as assertWindowEthereum } from '../../../../dist/assertWindowEthereum-88295886.browser.esm.js';\nimport { g as getValidPublicRPCUrl } from '../../../../dist/url-a45219bd.browser.esm.js';\nimport { utils, providers } from 'ethers';\nimport { n as normalizeChainId } from '../../../../dist/normalizeChainId-1fb9aedf.browser.esm.js';\nimport '@thirdweb-dev/chains';\nimport 'eventemitter3';\n\nfunction getInjectedName(ethereum) {\n  if (!ethereum) {\n    return \"Injected\";\n  }\n  const getName = provider => {\n    if (provider.isAvalanche) {\n      return \"Core Wallet\";\n    }\n    if (provider.isBitKeep) {\n      return \"BitKeep\";\n    }\n    if (provider.isBraveWallet) {\n      return \"Brave Wallet\";\n    }\n    if (provider.isCoinbaseWallet) {\n      return \"Coinbase Wallet\";\n    }\n    if (provider.isExodus) {\n      return \"Exodus\";\n    }\n    if (provider.isFrame) {\n      return \"Frame\";\n    }\n    if (provider.isKuCoinWallet) {\n      return \"KuCoin Wallet\";\n    }\n    if (provider.isMathWallet) {\n      return \"MathWallet\";\n    }\n    if (provider.isOneInchIOSWallet || provider.isOneInchAndroidWallet) {\n      return \"1inch Wallet\";\n    }\n    if (provider.isOpera) {\n      return \"Opera\";\n    }\n    if (provider.isPortal) {\n      return \"Ripio Portal\";\n    }\n    if (provider.isTally) {\n      return \"Tally\";\n    }\n    if (provider.isTokenPocket) {\n      return \"TokenPocket\";\n    }\n    if (provider.isTokenary) {\n      return \"Tokenary\";\n    }\n    if (provider.isTrust || provider.isTrustWallet) {\n      return \"Trust Wallet\";\n    }\n    if (provider.isMetaMask) {\n      return \"MetaMask\";\n    }\n    if (provider.isImToken) {\n      return \"imToken\";\n    }\n  };\n\n  // Some injected providers detect multiple other providers and create a list at `ethers.providers`\n  if (ethereum.providers?.length) {\n    // Deduplicate names using Set\n    // Coinbase Wallet puts multiple providers in `ethereum.providers`\n    const nameSet = new Set();\n    let unknownCount = 1;\n    for (const provider of ethereum.providers) {\n      let name = getName(provider);\n      if (!name) {\n        name = `Unknown Wallet #${unknownCount}`;\n        unknownCount += 1;\n      }\n      nameSet.add(name);\n    }\n    const names = [...nameSet];\n    if (names.length) {\n      return names;\n    }\n    return names[0] ?? \"Injected\";\n  }\n  return getName(ethereum) ?? \"Injected\";\n}\n\nclass InjectedConnector extends WagmiConnector {\n  constructor(arg) {\n    const defaultOptions = {\n      shimDisconnect: true,\n      getProvider: () => {\n        if (assertWindowEthereum(globalThis.window)) {\n          return globalThis.window.ethereum;\n        }\n      }\n    };\n    const options = {\n      ...defaultOptions,\n      ...arg.options\n    };\n    super({\n      chains: arg.chains,\n      options\n    });\n    /**\n     * Name of the injected connector\n     */\n    /**\n     * Whether the connector is ready to be used\n     *\n     * `true` if the injected provider is found\n     */\n    _defineProperty(this, \"shimDisconnectKey\", \"injected.shimDisconnect\");\n    /**\n     * handles the `accountsChanged` event from the provider\n     * * emits `change` event if connected to a different account\n     * * emits `disconnect` event if no accounts available\n     */\n    _defineProperty(this, \"onAccountsChanged\", async accounts => {\n      if (accounts.length === 0) {\n        this.emit(\"disconnect\");\n      } else {\n        this.emit(\"change\", {\n          account: utils.getAddress(accounts[0])\n        });\n      }\n    });\n    /**\n     * handles the `chainChanged` event from the provider\n     * * emits `change` event if connected to a different chain\n     */\n    _defineProperty(this, \"onChainChanged\", chainId => {\n      const id = normalizeChainId(chainId);\n      const unsupported = this.isChainUnsupported(id);\n      this.emit(\"change\", {\n        chain: {\n          id,\n          unsupported\n        }\n      });\n    });\n    /**\n     * handles the `disconnect` event from the provider\n     * * emits `disconnect` event\n     */\n    _defineProperty(this, \"onDisconnect\", async error => {\n      // We need this as MetaMask can emit the \"disconnect\" event upon switching chains.\n      // If MetaMask emits a `code: 1013` error, wait for reconnection before disconnecting\n      // https://github.com/MetaMask/providers/pull/120\n      if (error.code === 1013) {\n        const provider = await this.getProvider();\n        if (provider) {\n          try {\n            const isAuthorized = await this.getAccount();\n            if (isAuthorized) {\n              return;\n            }\n          } catch {\n            // If we can't get the account anymore, continue with disconnect\n          }\n        }\n      }\n      this.emit(\"disconnect\");\n\n      // Remove `shimDisconnect` => it signals that wallet is disconnected\n      if (this.options.shimDisconnect) {\n        await this.connectorStorage.removeItem(this.shimDisconnectKey);\n      }\n    });\n    const _provider = options.getProvider();\n\n    // set the name of the connector\n    if (typeof options.name === \"string\") {\n      // if name is given, use that\n      this.name = options.name;\n    } else if (_provider) {\n      // if injected provider is detected, get name from it\n      const detectedName = getInjectedName(_provider);\n      if (options.name) {\n        this.name = options.name(detectedName);\n      } else {\n        if (typeof detectedName === \"string\") {\n          this.name = detectedName;\n        } else {\n          this.name = detectedName[0];\n        }\n      }\n    } else {\n      // else default to \"Injected\"\n      this.name = \"Injected\";\n    }\n    this.id = \"injected\";\n    this.ready = !!_provider;\n    this.connectorStorage = arg.connectorStorage;\n  }\n\n  /**\n   * * Connect to the injected provider\n   * * switch to the given chain if `chainId` is specified as an argument\n   */\n  async connect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    try {\n      const provider = await this.getProvider();\n      if (!provider) {\n        throw new ConnectorNotFoundError();\n      }\n      this.setupListeners();\n\n      // emit \"connecting\" event\n      this.emit(\"message\", {\n        type: \"connecting\"\n      });\n\n      // request account addresses from injected provider\n      const accountAddresses = await provider.request({\n        method: \"eth_requestAccounts\"\n      });\n\n      // get the first account address\n      const firstAccountAddress = utils.getAddress(accountAddresses[0]);\n\n      // Switch to given chain if a chainId is specified\n      let connectedChainId = await this.getChainId();\n      // Check if currently connected chain is unsupported\n      // chainId is considered unsupported if chainId is not in the list of this.chains array\n      let isUnsupported = this.isChainUnsupported(connectedChainId);\n\n      // if chainId is specified and it is not the same as the currently connected chain\n      if (options.chainId && connectedChainId !== options.chainId) {\n        // switch to the given chain\n        try {\n          await this.switchChain(options.chainId);\n          // recalculate connectedChainId and isUnsupported\n          connectedChainId = options.chainId;\n          isUnsupported = this.isChainUnsupported(options.chainId);\n        } catch (e) {\n          console.error(`Could not switch to chain id: ${options.chainId}`, e);\n        }\n      }\n\n      // if shimDisconnect is enabled\n      if (this.options.shimDisconnect) {\n        // add the shim shimDisconnectKey => it signals that wallet is connected\n        await this.connectorStorage.setItem(this.shimDisconnectKey, \"true\");\n      }\n      const connectionInfo = {\n        account: firstAccountAddress,\n        chain: {\n          id: connectedChainId,\n          unsupported: isUnsupported\n        },\n        provider\n      };\n      this.emit(\"connect\", connectionInfo);\n      return connectionInfo;\n    } catch (error) {\n      if (this.isUserRejectedRequestError(error)) {\n        throw new UserRejectedRequestError(error);\n      }\n      if (error.code === -32002) {\n        throw new ResourceUnavailableError(error);\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * disconnect from the injected provider\n   */\n  async disconnect() {\n    // perform cleanup\n    const provider = await this.getProvider();\n    if (!provider?.removeListener) {\n      return;\n    }\n    provider.removeListener(\"accountsChanged\", this.onAccountsChanged);\n    provider.removeListener(\"chainChanged\", this.onChainChanged);\n    provider.removeListener(\"disconnect\", this.onDisconnect);\n\n    // if shimDisconnect is enabled\n    if (this.options.shimDisconnect) {\n      // Remove the shimDisconnectKey => it signals that wallet is disconnected\n      await this.connectorStorage.removeItem(this.shimDisconnectKey);\n    }\n  }\n\n  /**\n   * @returns The first account address from the injected provider\n   */\n  async getAccount() {\n    const provider = await this.getProvider();\n    if (!provider) {\n      throw new ConnectorNotFoundError();\n    }\n    const accounts = await provider.request({\n      method: \"eth_accounts\"\n    });\n\n    // return checksum address\n    // https://docs.ethers.org/v5/api/utils/address/#utils-getAddress\n    return utils.getAddress(accounts[0]);\n  }\n\n  /**\n   * @returns The `chainId` of the currently connected chain from injected provider normalized to a `number`\n   */\n  async getChainId() {\n    const provider = await this.getProvider();\n    if (!provider) {\n      throw new ConnectorNotFoundError();\n    }\n    return provider.request({\n      method: \"eth_chainId\"\n    }).then(normalizeChainId);\n  }\n\n  /**\n   * get the injected provider\n   */\n  async getProvider() {\n    const provider = this.options.getProvider();\n    if (provider) {\n      this._provider = provider;\n      // setting listeners\n    }\n    return this._provider;\n  }\n\n  /**\n   * get a `signer` for given `chainId`\n   */\n  async getSigner() {\n    let {\n      chainId\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const [provider, account] = await Promise.all([this.getProvider(), this.getAccount()]);\n\n    // ethers.providers.Web3Provider\n    return new providers.Web3Provider(provider, chainId).getSigner(account);\n  }\n\n  /**\n   *\n   * @returns `true` if the connector is connected and address is available, else `false`\n   */\n  async isAuthorized() {\n    try {\n      // `false` if connector is disconnected\n      if (this.options.shimDisconnect &&\n      // If shim does not exist in storage, wallet is disconnected\n      !Boolean(await this.connectorStorage.getItem(this.shimDisconnectKey))) {\n        return false;\n      }\n      const provider = await this.getProvider();\n      if (!provider) {\n        throw new ConnectorNotFoundError();\n      }\n      // `false` if no account address available, else `true`\n      const account = await this.getAccount();\n      return !!account;\n    } catch {\n      // `false` if any error thrown\n      return false;\n    }\n  }\n\n  /**\n   * switch to given chain\n   */\n  async switchChain(chainId) {\n    const provider = await this.getProvider();\n    if (!provider) {\n      throw new ConnectorNotFoundError();\n    }\n    const chainIdHex = utils.hexValue(chainId);\n    try {\n      // request provider to switch to given chainIdHex\n      await provider.request({\n        method: \"wallet_switchEthereumChain\",\n        params: [{\n          chainId: chainIdHex\n        }]\n      });\n      const chain = this.chains.find(_chain => _chain.chainId === chainId);\n      if (chain) {\n        return chain;\n      }\n      return {\n        chainId: chainId,\n        name: `Chain ${chainIdHex}`,\n        slug: `${chainIdHex}`,\n        nativeCurrency: {\n          name: \"Ether\",\n          decimals: 18,\n          symbol: \"ETH\"\n        },\n        rpc: [\"\"],\n        chain: \"\",\n        shortName: \"\",\n        testnet: true\n      };\n    } catch (error) {\n      // if could not switch to given chainIdHex\n\n      // if tried to connect to a chain that is not configured\n      const chain = this.chains.find(_chain => _chain.chainId === chainId);\n      if (!chain) {\n        throw new ChainNotConfiguredError({\n          chainId,\n          connectorId: this.id\n        });\n      }\n\n      // if chain is not added to provider\n      if (error.code === 4902 ||\n      // Unwrapping for MetaMask Mobile\n      // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719\n      error?.data?.originalError?.code === 4902) {\n        try {\n          // request provider to add chain\n          await provider.request({\n            method: \"wallet_addEthereumChain\",\n            params: [{\n              chainId: chainIdHex,\n              chainName: chain.name,\n              nativeCurrency: chain.nativeCurrency,\n              rpcUrls: getValidPublicRPCUrl(chain),\n              // no client id on purpose here\n              blockExplorerUrls: this.getBlockExplorerUrls(chain)\n            }]\n          });\n          return chain;\n        } catch (addError) {\n          // if user rejects request to add chain\n          if (this.isUserRejectedRequestError(addError)) {\n            throw new UserRejectedRequestError(error);\n          }\n\n          // else other error\n          throw new AddChainError();\n        }\n      }\n      if (this.isUserRejectedRequestError(error)) {\n        throw new UserRejectedRequestError(error);\n      }\n      throw new SwitchChainError(error);\n    }\n  }\n  async setupListeners() {\n    const provider = await this.getProvider();\n    if (provider.on) {\n      provider.on(\"accountsChanged\", this.onAccountsChanged);\n      provider.on(\"chainChanged\", this.onChainChanged);\n      provider.on(\"disconnect\", this.onDisconnect);\n    }\n  }\n  isUserRejectedRequestError(error) {\n    return error.code === 4001;\n  }\n}\n\nexport { InjectedConnector };\n","import { _ as _defineProperty } from '../../../../dist/defineProperty-350fc508.browser.esm.js';\nimport { a as ConnectorNotFoundError, U as UserRejectedRequestError, R as ResourceUnavailableError } from '../../../../dist/errors-9edc08c8.browser.esm.js';\nimport { w as walletIds } from '../../../../dist/walletIds-dff6dced.browser.esm.js';\nimport { InjectedConnector } from '../../injected/dist/thirdweb-dev-wallets-evm-connectors-injected.browser.esm.js';\nimport { utils } from 'ethers';\nimport { g as getInjectedOKXProvider } from '../../../../dist/getInjectedOKXProvider-f368fd1c.browser.esm.js';\nimport '../../../../dist/WagmiConnector-2f14002d.browser.esm.js';\nimport '@thirdweb-dev/chains';\nimport 'eventemitter3';\nimport '../../../../dist/assertWindowEthereum-88295886.browser.esm.js';\nimport '../../../../dist/url-a45219bd.browser.esm.js';\nimport '../../../../dist/normalizeChainId-1fb9aedf.browser.esm.js';\n\nclass OKXConnector extends InjectedConnector {\n  constructor(arg) {\n    const defaultOptions = {\n      name: \"OKX\",\n      shimDisconnect: true,\n      shimChainChangedDisconnect: true,\n      getProvider: getInjectedOKXProvider\n    };\n    const options = {\n      ...defaultOptions,\n      ...arg.options\n    };\n    super({\n      chains: arg.chains,\n      options,\n      connectorStorage: arg.connectorStorage\n    });\n    _defineProperty(this, \"id\", walletIds.okx);\n  }\n\n  /**\n   * Connect to injected OKX provider\n   */\n  async connect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    try {\n      const provider = await this.getProvider();\n      if (!provider) {\n        throw new ConnectorNotFoundError();\n      }\n      this.setupListeners();\n\n      // emit \"connecting\" event\n      this.emit(\"message\", {\n        type: \"connecting\"\n      });\n\n      // Attempt to show wallet select prompt with `wallet_requestPermissions` when\n      // `shimDisconnect` is active and account is in disconnected state (flag in storage)\n      let account = null;\n      if (this.options?.shimDisconnect && !Boolean(this.connectorStorage.getItem(this.shimDisconnectKey))) {\n        account = await this.getAccount().catch(() => null);\n        const isConnected = !!account;\n        if (isConnected) {\n          // Attempt to show another prompt for selecting wallet if already connected\n          try {\n            await provider.request({\n              method: \"wallet_requestPermissions\",\n              params: [{\n                eth_accounts: {}\n              }]\n            });\n          } catch (error) {\n            // Not all injected providers support `wallet_requestPermissions` (e.g. iOS).\n            // Only bubble up error if user rejects request\n            if (this.isUserRejectedRequestError(error)) {\n              throw new UserRejectedRequestError(error);\n            }\n          }\n        }\n      }\n\n      // if account is not already set, request accounts and use the first account\n      if (!account) {\n        const accounts = await provider.request({\n          method: \"eth_requestAccounts\"\n        });\n        account = utils.getAddress(accounts[0]);\n      }\n\n      // get currently connected chainId\n      let connectedChainId = await this.getChainId();\n      // check if connected chain is unsupported\n      let isUnsupported = this.isChainUnsupported(connectedChainId);\n\n      // if chainId is given, but does not match the currently connected chainId, switch to the given chainId\n      if (options.chainId && connectedChainId !== options.chainId) {\n        try {\n          await this.switchChain(options.chainId);\n          // recalculate the chainId and isUnsupported\n          connectedChainId = options.chainId;\n          isUnsupported = this.isChainUnsupported(options.chainId);\n        } catch (e) {\n          console.error(`Could not switch to chain id : ${options.chainId}`, e);\n        }\n      }\n\n      // if shimDisconnect is enabled\n      if (this.options?.shimDisconnect) {\n        // add shimDisconnectKey in storage - this signals that connector is \"connected\"\n        await this.connectorStorage.setItem(this.shimDisconnectKey, \"true\");\n      }\n      const connectionInfo = {\n        chain: {\n          id: connectedChainId,\n          unsupported: isUnsupported\n        },\n        provider: provider,\n        account\n      };\n      this.emit(\"connect\", connectionInfo);\n      return connectionInfo;\n    } catch (error) {\n      if (this.isUserRejectedRequestError(error)) {\n        throw new UserRejectedRequestError(error);\n      }\n      if (error.code === -32002) {\n        throw new ResourceUnavailableError(error);\n      }\n      throw error;\n    }\n  }\n  async switchAccount() {\n    const provider = await this.getProvider();\n    await provider.request({\n      method: \"wallet_requestPermissions\",\n      params: [{\n        eth_accounts: {}\n      }]\n    });\n  }\n}\n\nexport { OKXConnector };\n"],"names":["WagmiConnector","EventEmitter","constructor","_ref","chains","defaultChains","options","super","this","getBlockExplorerUrls","chain","_chain$explorers$map","_chain$explorers","explorers","map","x","url","length","undefined","isChainUnsupported","chainId","some","updateChains","RpcError","Error","message","cause","code","data","Number","isInteger","concat","JSON","stringify","ProviderRpcError","AddChainError","arguments","_defineProperty","ChainNotConfiguredError","connectorId","ConnectorNotFoundError","ResourceUnavailableError","SwitchChainError","UserRejectedRequestError","normalizeChainId","parseInt","trim","substring","InjectedConnector","arg","shimDisconnect","getProvider","assertWindowEthereum","globalThis","window","ethereum","async","accounts","emit","account","utils","id","unsupported","error","getAccount","connectorStorage","removeItem","shimDisconnectKey","_provider","name","detectedName","_ethereum$providers","_getName","getName","provider","isAvalanche","isBitKeep","isBraveWallet","isCoinbaseWallet","isExodus","isFrame","isKuCoinWallet","isMathWallet","isOneInchIOSWallet","isOneInchAndroidWallet","isOpera","isPortal","isTally","isTokenPocket","isTokenary","isTrust","isTrustWallet","isMetaMask","isImToken","providers","_names$","nameSet","Set","unknownCount","add","names","getInjectedName","ready","connect","setupListeners","type","accountAddresses","request","method","firstAccountAddress","connectedChainId","getChainId","isUnsupported","switchChain","e","console","setItem","connectionInfo","isUserRejectedRequestError","disconnect","removeListener","onAccountsChanged","onChainChanged","onDisconnect","then","getSigner","Promise","all","isAuthorized","Boolean","getItem","chainIdHex","params","find","_chain","slug","nativeCurrency","decimals","symbol","rpc","shortName","testnet","_error$data","originalError","chainName","rpcUrls","getValidPublicRPCUrl","blockExplorerUrls","addError","on","OKXConnector","shimChainChangedDisconnect","getInjectedOKXProvider","walletIds","okx","_this$options","_this$options2","catch","eth_accounts","switchAccount"],"sourceRoot":""}