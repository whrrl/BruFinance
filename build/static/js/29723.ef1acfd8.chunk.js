"use strict";(self.webpackChunkbru_finance=self.webpackChunkbru_finance||[]).push([[29723],{88532:(t,r,e)=>{e.d(r,{c:()=>n});var a=e(63112),i=e(76328);function n(t){return(0,i.i)(t)?a.aW:t}},38918:(t,r,e)=>{e.d(r,{C:()=>o});var a=e(54705),i=e(81274),n=e(63112);class o{constructor(t){(0,a.A)(this,"featureName",n.dr.name),(0,a.A)(this,"set",(0,i.f)((async t=>{const r=await n.bH.parseAsync(t);return i.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setPlatformFeeInfo",args:[r.platform_fee_recipient,r.platform_fee_basis_points]})}))),this.contractWrapper=t}async get(){const[t,r]=await this.contractWrapper.read("getPlatformFeeInfo",[]);return n.bH.parseAsync({platform_fee_recipient:t,platform_fee_basis_points:r})}}},59837:(t,r,e)=>{e.d(r,{a:()=>m,g:()=>g,h:()=>p,i:()=>d,m:()=>l,v:()=>u});var a=e(10974),i=e(2776),n=e(3404),o=e(67882),s=e(63112),c=e(76328);async function d(t,r,i,n,s){try{const p=(await e.e(94811).then(e.t.bind(e,94811,19))).default,u=new a.NZ(i,p,t),[l,m]=await Promise.all([u.supportsInterface(o.I),u.supportsInterface(o.a)]);if(l){var c;const o=(await Promise.resolve().then(e.t.bind(e,57305,19))).default,p=new a.NZ(i,o,t);if(await p.isApprovedForAll(s,r))return!0;let u;try{u=await p.getApproved(n)}catch(d){}return(null===(c=u)||void 0===c?void 0:c.toLowerCase())===r.toLowerCase()}if(m){const n=(await Promise.resolve().then(e.t.bind(e,59355,19))).default,o=new a.NZ(i,n,t);return await o.isApprovedForAll(s,r)}return console.error("Contract does not implement ERC 1155 or ERC 721."),!1}catch(p){return console.error("Failed to check if token is approved",p),!1}}async function p(t,r,a,i,n){const c=(await e.e(94811).then(e.t.bind(e,94811,19))).default,d=new s.cs(t.getSignerOrProvider(),a,c,t.options,t.storage),[p,u]=await Promise.all([d.read("supportsInterface",[o.I]),d.read("supportsInterface",[o.a])]);if(p){const o=(await Promise.resolve().then(e.t.bind(e,57305,19))).default,c=new s.cs(t.getSignerOrProvider(),a,o,t.options,t.storage);if(!await c.read("isApprovedForAll",[n,r])){(await c.read("getApproved",[i])).toLowerCase()===r.toLowerCase()||await c.sendTransaction("setApprovalForAll",[r,!0])}}else{if(!u)throw Error("Contract must implement ERC 1155 or ERC 721.");{const i=(await Promise.resolve().then(e.t.bind(e,59355,19))).default,o=new s.cs(t.getSignerOrProvider(),a,i,t.options,t.storage);await o.read("isApprovedForAll",[n,r])||await o.sendTransaction("setApprovalForAll",[r,!0])}}}function u(t){if((0,n.A)(void 0!==t.assetContractAddress&&null!==t.assetContractAddress,"Asset contract address is required"),(0,n.A)(void 0!==t.buyoutPricePerToken&&null!==t.buyoutPricePerToken,"Buyout price is required"),(0,n.A)(void 0!==t.listingDurationInSeconds&&null!==t.listingDurationInSeconds,"Listing duration is required"),(0,n.A)(void 0!==t.startTimestamp&&null!==t.startTimestamp,"Start time is required"),(0,n.A)(void 0!==t.tokenId&&null!==t.tokenId,"Token ID is required"),(0,n.A)(void 0!==t.quantity&&null!==t.quantity,"Quantity is required"),"NewAuctionListing"===t.type)(0,n.A)(void 0!==t.reservePricePerToken&&null!==t.reservePricePerToken,"Reserve price is required")}async function l(t,r,e){return{quantity:e.quantityDesired,pricePerToken:e.pricePerToken,currencyContractAddress:e.currency,buyerAddress:e.offeror,quantityDesired:e.quantityWanted,currencyValue:await(0,c.a)(t,e.currency,e.quantityWanted.mul(e.pricePerToken)),listingId:r}}function m(t,r,e){if(e=i.gH.from(e),t=i.gH.from(t),r=i.gH.from(r),t.eq(i.gH.from(0)))return!1;return r.sub(t).mul(s.dB).div(t).gte(e)}async function g(t,r,e){const a=[];for(;r-t>o.D;)a.push(e(t,t+o.D-1)),t+=o.D;return a.push(e(t,r-1)),await Promise.all(a)}},47170:(t,r,e)=>{e.d(r,{M:()=>b,a:()=>L,b:()=>I});var a=e(54705),i=e(2776),n=e(10974),o=e(73594),s=e(81237),c=e(3404),d=e(88532),p=e(76328),u=e(49013),l=e(26252),m=e(63112),g=e(59837),f=e(67882),h=e(81274),w=e(78344),A=e(97665),v=e(53053),y=e(78527);const C=(()=>A.z.object({assetContractAddress:m.ba,tokenId:m.b7,quantity:m.b7.default(1),currencyContractAddress:m.ba.default(m.aW),pricePerToken:m.cw,startTimestamp:w.R.default(new Date),endTimestamp:w.E,isReservedListing:A.z.boolean().default(!1)}))();let W=function(t){return t[t.UNSET=0]="UNSET",t[t.Created=1]="Created",t[t.Completed=2]="Completed",t[t.Cancelled=3]="Cancelled",t[t.Active=4]="Active",t[t.Expired=5]="Expired",t}({});class b{constructor(t,r){(0,a.A)(this,"featureName",m.dx.name),(0,a.A)(this,"createListing",(0,h.f)((async t=>{const r=await C.parseAsync(t);await(0,g.h)(this.contractWrapper,this.getAddress(),r.assetContractAddress,r.tokenId,await this.contractWrapper.getSignerAddress());const e=await(0,u.n)(this.contractWrapper.getProvider(),r.pricePerToken,r.currencyContractAddress),a=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;r.startTimestamp.lt(a)&&(r.startTimestamp=i.gH.from(a));const n=h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"createListing",args:[{assetContract:r.assetContractAddress,tokenId:r.tokenId,quantity:r.quantity,currency:(0,d.c)(r.currencyContractAddress),pricePerToken:e,startTimestamp:r.startTimestamp,endTimestamp:r.endTimestamp,reserved:r.isReservedListing}],parse:t=>({id:this.contractWrapper.parseLogs("NewListing",null===t||void 0===t?void 0:t.logs)[0].args.listingId,receipt:t})});return n.setGasLimitMultiple(1.2),n}))),(0,a.A)(this,"createListingsBatch",(0,h.f)((async t=>{const r=(await Promise.all(t.map((t=>this.createListing.prepare(t))))).map((t=>t.encode())),e=h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r],parse:t=>this.contractWrapper.parseLogs("NewListing",null===t||void 0===t?void 0:t.logs).map((r=>({id:r.args.listingId,receipt:t})))});return e.setGasLimitMultiple(1.2),e}))),(0,a.A)(this,"updateListing",(0,h.f)((async(t,r)=>{const e=await C.parseAsync(r);await(0,g.h)(this.contractWrapper,this.getAddress(),e.assetContractAddress,e.tokenId,await this.contractWrapper.getSignerAddress());const a=await(0,u.n)(this.contractWrapper.getProvider(),e.pricePerToken,e.currencyContractAddress),i=h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"updateListing",args:[t,{assetContract:e.assetContractAddress,tokenId:e.tokenId,quantity:e.quantity,currency:(0,d.c)(e.currencyContractAddress),pricePerToken:a,startTimestamp:e.startTimestamp,endTimestamp:e.endTimestamp,reserved:e.isReservedListing}],parse:t=>({id:this.contractWrapper.parseLogs("UpdatedListing",null===t||void 0===t?void 0:t.logs)[0].args.listingId,receipt:t})});return i.setGasLimitMultiple(1.2),i}))),(0,a.A)(this,"cancelListing",(0,h.f)((async t=>{const r=h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancelListing",args:[t]});return r.setGasLimitMultiple(1.2),r}))),(0,a.A)(this,"buyFromListing",(0,h.f)((async(t,r,e)=>{e&&(e=await(0,m.aM)(e));const a=await this.validateListing(i.gH.from(t)),{valid:n,error:o}=await this.isStillValidListing(a,r);if(!n)throw new Error("Listing ".concat(t," is no longer valid. ").concat(o));const s=e||await this.contractWrapper.getSignerAddress(),c=i.gH.from(r),d=i.gH.from(a.pricePerToken).mul(c),p=await this.contractWrapper.getCallOverrides()||{};await(0,l.s)(this.contractWrapper,d,a.currencyContractAddress,p);const u=h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"buyFromListing",args:[t,s,c,a.currencyContractAddress,d],overrides:p});return u.setGasLimitMultiple(1.2),u}))),(0,a.A)(this,"approveBuyerForReservedListing",(0,h.f)((async(t,r)=>{if(await this.isBuyerApprovedForListing(t,r))throw new Error("Buyer ".concat(r," already approved for listing ").concat(t,"."));{const e=h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveBuyerForListing",args:[t,r,!0]});return e.setGasLimitMultiple(1.2),e}}))),(0,a.A)(this,"revokeBuyerApprovalForReservedListing",(0,h.f)((async(t,r)=>{if(await this.isBuyerApprovedForListing(t,r)){const e=h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveBuyerForListing",args:[t,r,!1]});return e.setGasLimitMultiple(1.2),e}throw new Error("Buyer ".concat(r," not approved for listing ").concat(t,"."))}))),(0,a.A)(this,"approveCurrencyForListing",(0,h.f)((async(t,r,e)=>{const a=await this.validateListing(i.gH.from(t)),n=await(0,m.aM)(r);n===a.currencyContractAddress&&(0,c.A)(e===a.pricePerToken,"Approving listing currency with a different price.");const o=await this.contractWrapper.read("currencyPriceForListing",[t,n]);(0,c.A)(e===o,"Currency already approved with this price.");const s=h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveCurrencyForListing",args:[t,n,e]});return s.setGasLimitMultiple(1.2),s}))),(0,a.A)(this,"revokeCurrencyApprovalForListing",(0,h.f)((async(t,r)=>{const e=await this.validateListing(i.gH.from(t)),a=await(0,m.aM)(r);if(a===e.currencyContractAddress)throw new Error("Can't revoke approval for main listing currency.");const n=await this.contractWrapper.read("currencyPriceForListing",[t,a]);(0,c.A)(!n.isZero(),"Currency not approved.");const o=h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveCurrencyForListing",args:[t,a,i.gH.from(0)]});return o.setGasLimitMultiple(1.2),o}))),this.contractWrapper=t,this.storage=r,this.events=new v.a(this.contractWrapper),this.encoder=new p.C(this.contractWrapper),this.interceptor=new y.C(this.contractWrapper),this.estimator=new v.G(this.contractWrapper)}getAddress(){return this.contractWrapper.address}async getTotalCount(){return await this.contractWrapper.read("totalListings",[])}async getAll(t){const r=await this.getTotalCount(),e=i.gH.from((null===t||void 0===t?void 0:t.start)||0).toNumber(),a=r.toNumber();if(0===a)throw new Error("No listings exist on the contract.");let n=[];n=(await(0,g.g)(e,a,((t,r)=>this.contractWrapper.read("getAllListings",[t,r])))).flat();const o=await this.applyFilter(n,t);return await Promise.all(o.map((t=>this.mapListing(t))))}async getAllValid(t){const r=await this.getTotalCount(),e=i.gH.from((null===t||void 0===t?void 0:t.start)||0).toNumber(),a=r.toNumber();if(0===a)throw new Error("No listings exist on the contract.");let n=[];n=(await(0,g.g)(e,a,((t,r)=>this.contractWrapper.read("getAllValidListings",[t,r])))).flat();const o=await this.applyFilter(n,t);return await Promise.all(o.map((t=>this.mapListing(t))))}async getListing(t){const r=await this.contractWrapper.read("getListing",[t]);return await this.mapListing(r)}async isBuyerApprovedForListing(t,r){if(!(await this.validateListing(i.gH.from(t))).isReservedListing)throw new Error("Listing ".concat(t," is not a reserved listing."));return await this.contractWrapper.read("isBuyerApprovedForListing",[t,await(0,m.aM)(r)])}async isCurrencyApprovedForListing(t,r){return await this.validateListing(i.gH.from(t)),await this.contractWrapper.read("isCurrencyApprovedForListing",[t,await(0,m.aM)(r)])}async currencyPriceForListing(t,r){const e=await this.validateListing(i.gH.from(t)),a=await(0,m.aM)(r);if(a===e.currencyContractAddress)return e.pricePerToken;if(!await this.isCurrencyApprovedForListing(t,a))throw new Error("Currency ".concat(a," is not approved for Listing ").concat(t,"."));return await this.contractWrapper.read("currencyPriceForListing",[t,a])}async validateListing(t){try{return await this.getListing(t)}catch(r){throw console.error("Error getting the listing with id ".concat(t)),r}}async mapListing(t){let r=W.UNSET;const e=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;switch(t.status){case 1:r=i.gH.from(t.startTimestamp).gt(e)?W.Created:i.gH.from(t.endTimestamp).lt(e)?W.Expired:W.Active;break;case 2:r=W.Completed;break;case 3:r=W.Cancelled}return{assetContractAddress:t.assetContract,currencyContractAddress:t.currency,pricePerToken:t.pricePerToken.toString(),currencyValuePerToken:await(0,p.a)(this.contractWrapper.getProvider(),t.currency,t.pricePerToken),id:t.listingId.toString(),tokenId:t.tokenId.toString(),quantity:t.quantity.toString(),startTimeInSeconds:i.gH.from(t.startTimestamp).toNumber(),asset:await(0,f.c)(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),endTimeInSeconds:i.gH.from(t.endTimestamp).toNumber(),creatorAddress:t.listingCreator,isReservedListing:t.reserved,status:r}}async isStillValidListing(t,r){if(!await(0,g.i)(this.contractWrapper.getProvider(),this.getAddress(),t.assetContractAddress,t.tokenId,t.creatorAddress))return{valid:!1,error:"Token '".concat(t.tokenId,"' from contract '").concat(t.assetContractAddress,"' is not approved for transfer")};const a=this.contractWrapper.getProvider(),i=(await e.e(94811).then(e.t.bind(e,94811,19))).default,o=new n.NZ(t.assetContractAddress,i,a),s=await o.supportsInterface(f.I),c=await o.supportsInterface(f.a);if(s){var d;const r=(await Promise.resolve().then(e.t.bind(e,57305,19))).default,i=new n.NZ(t.assetContractAddress,r,a);let o;try{o=await i.ownerOf(t.tokenId)}catch(p){}const s=(null===(d=o)||void 0===d?void 0:d.toLowerCase())===t.creatorAddress.toLowerCase();return{valid:s,error:s?void 0:"Seller is not the owner of Token '".concat(t.tokenId,"' from contract '").concat(t.assetContractAddress," anymore'")}}if(c){const i=(await Promise.resolve().then(e.t.bind(e,59355,19))).default,o=new n.NZ(t.assetContractAddress,i,a),s=(await o.balanceOf(t.creatorAddress,t.tokenId)).gte(r||t.quantity);return{valid:s,error:s?void 0:"Seller does not have enough balance of Token '".concat(t.tokenId,"' from contract '").concat(t.assetContractAddress," to fulfill the listing")}}return{valid:!1,error:"Contract does not implement ERC 1155 or ERC 721."}}async applyFilter(t,r){let e=[...t];if(r){if(r.seller){const t=await(0,m.aM)(r.seller);e=e.filter((r=>r.listingCreator.toString().toLowerCase()===(null===t||void 0===t?void 0:t.toString().toLowerCase())))}if(r.tokenContract){const t=await(0,m.aM)(r.tokenContract);e=e.filter((r=>r.assetContract.toString().toLowerCase()===(null===t||void 0===t?void 0:t.toString().toLowerCase())))}void 0!==r.tokenId&&(e=e.filter((t=>{var e;return t.tokenId.toString()===(null===r||void 0===r||null===(e=r.tokenId)||void 0===e?void 0:e.toString())})))}return null!==r&&void 0!==r&&r.count&&r.count<e.length?e.slice(0,r.count):e}}const T=(()=>A.z.object({assetContractAddress:m.ba,tokenId:m.b7,quantity:m.b7.default(1),currencyContractAddress:m.ba.default(m.aW),minimumBidAmount:m.cw,buyoutBidAmount:m.cw,timeBufferInSeconds:m.b7.default(900),bidBufferBps:m.b7.default(500),startTimestamp:w.R.default(new Date),endTimestamp:w.E}))();class L{constructor(t,r){(0,a.A)(this,"featureName",m.dy.name),(0,a.A)(this,"createAuction",(0,h.f)((async t=>{const r=T.parse(t);await(0,g.h)(this.contractWrapper,this.getAddress(),r.assetContractAddress,r.tokenId,await this.contractWrapper.getSignerAddress());const e=await(0,u.n)(this.contractWrapper.getProvider(),r.buyoutBidAmount,r.currencyContractAddress),a=await(0,u.n)(this.contractWrapper.getProvider(),r.minimumBidAmount,r.currencyContractAddress),n=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;r.startTimestamp.lt(n)&&(r.startTimestamp=i.gH.from(n));const o=h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"createAuction",args:[{assetContract:r.assetContractAddress,tokenId:r.tokenId,quantity:r.quantity,currency:(0,d.c)(r.currencyContractAddress),minimumBidAmount:a,buyoutBidAmount:e,timeBufferInSeconds:r.timeBufferInSeconds,bidBufferBps:r.bidBufferBps,startTimestamp:r.startTimestamp,endTimestamp:r.endTimestamp}],parse:t=>({id:this.contractWrapper.parseLogs("NewAuction",t.logs)[0].args.auctionId,receipt:t})});return o.setGasLimitMultiple(1.2),o}))),(0,a.A)(this,"createAuctionsBatch",(0,h.f)((async t=>{const r=(await Promise.all(t.map((t=>this.createAuction.prepare(t))))).map((t=>t.encode())),e=h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r],parse:t=>this.contractWrapper.parseLogs("NewAuction",null===t||void 0===t?void 0:t.logs).map((r=>({id:r.args.auctionId,receipt:t})))});return e.setGasLimitMultiple(1.2),e}))),(0,a.A)(this,"buyoutAuction",(0,h.f)((async t=>{const r=await this.validateAuction(i.gH.from(t)),e=await(0,p.f)(this.contractWrapper.getProvider(),r.currencyContractAddress);return this.makeBid.prepare(t,o.formatUnits(r.buyoutBidAmount,e.decimals))}))),(0,a.A)(this,"makeBid",(0,h.f)((async(t,r)=>{const e=await this.validateAuction(i.gH.from(t)),a=await(0,u.n)(this.contractWrapper.getProvider(),r,e.currencyContractAddress);if(a.eq(i.gH.from(0)))throw new Error("Cannot make a bid with 0 value");if(i.gH.from(e.buyoutBidAmount).gt(0)&&a.gt(e.buyoutBidAmount))throw new Error("Bid amount must be less than or equal to buyoutBidAmount");if(await this.getWinningBid(t)){const r=await this.isWinningBid(t,a);(0,c.A)(r,"Bid price is too low based on the current winning bid and the bid buffer")}else{const t=a,r=i.gH.from(e.minimumBidAmount);(0,c.A)(t.gte(r),"Bid price is too low based on minimum bid amount")}const n=await this.contractWrapper.getCallOverrides()||{};await(0,l.s)(this.contractWrapper,a,e.currencyContractAddress,n);const o=h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"bidInAuction",overrides:n,args:[t,a]});return o.setGasLimitMultiple(1.2),o}))),(0,a.A)(this,"cancelAuction",(0,h.f)((async t=>{if(await this.getWinningBid(t))throw new Error("Bids already made.");const r=h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancelAuction",args:[t]});return r.setGasLimitMultiple(1.2),r}))),(0,a.A)(this,"closeAuctionForBidder",(0,h.f)((async(t,r)=>{r||(r=await this.contractWrapper.getSignerAddress());const e=await this.validateAuction(i.gH.from(t));try{const r=h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"collectAuctionTokens",args:[i.gH.from(t)]});return r.setGasLimitMultiple(1.2),r}catch(a){throw a.message.includes("Marketplace: auction still active.")?new m.w(t.toString(),e.endTimeInSeconds.toString()):a}}))),(0,a.A)(this,"closeAuctionForSeller",(0,h.f)((async t=>{const r=await this.validateAuction(i.gH.from(t));try{const r=h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"collectAuctionPayout",args:[i.gH.from(t)]});return r.setGasLimitMultiple(1.2),r}catch(e){throw e.message.includes("Marketplace: auction still active.")?new m.w(t.toString(),r.endTimeInSeconds.toString()):e}}))),(0,a.A)(this,"executeSale",(0,h.f)((async t=>{const r=await this.validateAuction(i.gH.from(t));try{const r=await this.getWinningBid(t);(0,c.A)(r,"No winning bid found");const e=this.encoder.encode("collectAuctionPayout",[t]),a=this.encoder.encode("collectAuctionTokens",[t]),i=h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[[e,a]]});return i.setGasLimitMultiple(1.2),i}catch(e){throw e.message.includes("Marketplace: auction still active.")?new m.w(t.toString(),r.endTimeInSeconds.toString()):e}}))),this.contractWrapper=t,this.storage=r,this.events=new v.a(this.contractWrapper),this.encoder=new p.C(this.contractWrapper),this.interceptor=new y.C(this.contractWrapper),this.estimator=new v.G(this.contractWrapper)}getAddress(){return this.contractWrapper.address}async getTotalCount(){return await this.contractWrapper.read("totalAuctions",[])}async getAll(t){const r=await this.getTotalCount(),e=i.gH.from((null===t||void 0===t?void 0:t.start)||0).toNumber(),a=r.toNumber();if(0===a)throw new Error("No auctions exist on the contract.");let n=[];n=(await(0,g.g)(e,a,((t,r)=>this.contractWrapper.read("getAllAuctions",[t,r])))).flat();const o=await this.applyFilter(n,t);return await Promise.all(o.map((t=>this.mapAuction(t))))}async getAllValid(t){const r=await this.getTotalCount(),e=i.gH.from((null===t||void 0===t?void 0:t.start)||0).toNumber(),a=r.toNumber();if(0===a)throw new Error("No auctions exist on the contract.");let n=[];n=(await(0,g.g)(e,a,((t,r)=>this.contractWrapper.read("getAllValidAuctions",[t,r])))).flat();const o=await this.applyFilter(n,t);return await Promise.all(o.map((t=>this.mapAuction(t))))}async getAuction(t){const r=await this.contractWrapper.read("getAuction",[t]);return await this.mapAuction(r)}async getWinningBid(t){await this.validateAuction(i.gH.from(t));const r=await this.contractWrapper.read("getWinningBid",[t]);if(r._bidder!==s.L)return await this.mapBid(t.toString(),r._bidder,r._currency,r._bidAmount.toString())}async isWinningBid(t,r){return await this.contractWrapper.read("isNewWinningBid",[t,r])}async getWinner(t){const r=await this.validateAuction(i.gH.from(t)),e=await this.contractWrapper.read("getWinningBid",[t]),a=i.gH.from(Math.floor(Date.now()/1e3)),n=i.gH.from(r.endTimeInSeconds);if(a.gt(n)&&e._bidder!==s.L)return e._bidder;const o=new v.a(this.contractWrapper),c=(await o.getEvents("AuctionClosed")).find((r=>r.data.auctionId.eq(i.gH.from(t))));if(!c)throw new Error("Could not find auction with ID ".concat(t," in closed auctions"));return c.data.winningBidder}async getBidBufferBps(t){return(await this.getAuction(t)).bidBufferBps}async getMinimumNextBid(t){const[r,e,a]=await Promise.all([this.getBidBufferBps(t),this.getWinningBid(t),this.validateAuction(i.gH.from(t))]),n=e?i.gH.from(e.bidAmount):i.gH.from(a.minimumBidAmount),o=n.add(n.mul(r).div(1e4));return(0,p.a)(this.contractWrapper.getProvider(),a.currencyContractAddress,o)}async validateAuction(t){try{return await this.getAuction(t)}catch(r){throw console.error("Error getting the auction with id ".concat(t)),r}}async mapAuction(t){let r=W.UNSET;const e=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;switch(t.status){case 1:r=i.gH.from(t.startTimestamp).gt(e)?W.Created:i.gH.from(t.endTimestamp).lt(e)?W.Expired:W.Active;break;case 2:r=W.Completed;break;case 3:r=W.Cancelled}return{id:t.auctionId.toString(),creatorAddress:t.auctionCreator,assetContractAddress:t.assetContract,tokenId:t.tokenId.toString(),quantity:t.quantity.toString(),currencyContractAddress:t.currency,minimumBidAmount:t.minimumBidAmount.toString(),minimumBidCurrencyValue:await(0,p.a)(this.contractWrapper.getProvider(),t.currency,t.minimumBidAmount),buyoutBidAmount:t.buyoutBidAmount.toString(),buyoutCurrencyValue:await(0,p.a)(this.contractWrapper.getProvider(),t.currency,t.buyoutBidAmount),timeBufferInSeconds:i.gH.from(t.timeBufferInSeconds).toNumber(),bidBufferBps:i.gH.from(t.bidBufferBps).toNumber(),startTimeInSeconds:i.gH.from(t.startTimestamp).toNumber(),endTimeInSeconds:i.gH.from(t.endTimestamp).toNumber(),asset:await(0,f.c)(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),status:r}}async mapBid(t,r,e,a){const i=await(0,m.aM)(r),n=await(0,m.aM)(e);return{auctionId:t,bidderAddress:i,currencyContractAddress:n,bidAmount:a,bidAmountCurrencyValue:await(0,p.a)(this.contractWrapper.getProvider(),n,a)}}async applyFilter(t,r){let e=[...t];if(r){if(r.seller){const t=await(0,m.aM)(r.seller);e=e.filter((r=>r.auctionCreator.toString().toLowerCase()===(null===t||void 0===t?void 0:t.toString().toLowerCase())))}if(r.tokenContract){const t=await(0,m.aM)(r.tokenContract);e=e.filter((r=>r.assetContract.toString().toLowerCase()===(null===t||void 0===t?void 0:t.toString().toLowerCase())))}void 0!==r.tokenId&&(e=e.filter((t=>{var e;return t.tokenId.toString()===(null===r||void 0===r||null===(e=r.tokenId)||void 0===e?void 0:e.toString())})))}return null!==r&&void 0!==r&&r.count&&r.count<e.length?e.slice(0,r.count):e}}const k=(()=>A.z.object({assetContractAddress:m.ba,tokenId:m.b7,quantity:m.b7.default(1),currencyContractAddress:m.ba.default(m.aW),totalPrice:m.cw,endTimestamp:w.E}))();class I{constructor(t,r){(0,a.A)(this,"featureName",m.dz.name),(0,a.A)(this,"makeOffer",(0,h.f)((async t=>{const r=await k.parseAsync(t),e=await this.contractWrapper.getChainID(),a=(0,p.i)(r.currencyContractAddress)?m.aX[e].wrapped.address:r.currencyContractAddress,i=await(0,u.n)(this.contractWrapper.getProvider(),r.totalPrice,a),n=await this.contractWrapper.getCallOverrides();return await(0,l.s)(this.contractWrapper,i,a,n),h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"makeOffer",args:[{assetContract:r.assetContractAddress,tokenId:r.tokenId,quantity:r.quantity,currency:a,totalPrice:i,expirationTimestamp:r.endTimestamp}],parse:t=>({id:this.contractWrapper.parseLogs("NewOffer",null===t||void 0===t?void 0:t.logs)[0].args.offerId,receipt:t})})}))),(0,a.A)(this,"cancelOffer",(0,h.f)((async t=>h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancelOffer",args:[t]})))),(0,a.A)(this,"acceptOffer",(0,h.f)((async t=>{const r=await this.validateOffer(i.gH.from(t)),{valid:e,error:a}=await this.isStillValidOffer(r);if(!e)throw new Error("Offer ".concat(t," is no longer valid. ").concat(a));const n=await this.contractWrapper.getCallOverrides()||{};return await(0,g.h)(this.contractWrapper,this.getAddress(),r.assetContractAddress,r.tokenId,await this.contractWrapper.getSignerAddress()),h.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"acceptOffer",args:[t],overrides:n})}))),this.contractWrapper=t,this.storage=r,this.events=new v.a(this.contractWrapper),this.encoder=new p.C(this.contractWrapper),this.interceptor=new y.C(this.contractWrapper),this.estimator=new v.G(this.contractWrapper)}getAddress(){return this.contractWrapper.address}async getTotalCount(){return await this.contractWrapper.read("totalOffers",[])}async getAll(t){const r=await this.getTotalCount(),e=i.gH.from((null===t||void 0===t?void 0:t.start)||0).toNumber(),a=r.toNumber();if(0===a)throw new Error("No offers exist on the contract.");let n=[];n=(await(0,g.g)(e,a,((t,r)=>this.contractWrapper.read("getAllOffers",[t,r])))).flat();const o=await this.applyFilter(n,t);return await Promise.all(o.map((t=>this.mapOffer(t))))}async getAllValid(t){const r=await this.getTotalCount(),e=i.gH.from((null===t||void 0===t?void 0:t.start)||0).toNumber(),a=r.toNumber();if(0===a)throw new Error("No offers exist on the contract.");let n=[];n=(await(0,g.g)(e,a,((t,r)=>this.contractWrapper.read("getAllValidOffers",[t,r])))).flat();const o=await this.applyFilter(n,t);return await Promise.all(o.map((t=>this.mapOffer(t))))}async getOffer(t){const r=await this.contractWrapper.read("getOffer",[t]);return await this.mapOffer(r)}async validateOffer(t){try{return await this.getOffer(t)}catch(r){throw console.error("Error getting the offer with id ".concat(t)),r}}async mapOffer(t){let r=W.UNSET;const e=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;switch(t.status){case 1:r=i.gH.from(t.expirationTimestamp).lt(e)?W.Expired:W.Active;break;case 2:r=W.Completed;break;case 3:r=W.Cancelled}return{id:t.offerId.toString(),offerorAddress:t.offeror,assetContractAddress:t.assetContract,currencyContractAddress:t.currency,tokenId:t.tokenId.toString(),quantity:t.quantity.toString(),totalPrice:t.totalPrice.toString(),currencyValue:await(0,p.a)(this.contractWrapper.getProvider(),t.currency,t.totalPrice),asset:await(0,f.c)(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),endTimeInSeconds:i.gH.from(t.expirationTimestamp).toNumber(),status:r}}async isStillValidOffer(t){if(i.gH.from(Math.floor(Date.now()/1e3)).gt(t.endTimeInSeconds))return{valid:!1,error:"Offer with ID ".concat(t.id," has expired")};const r=await this.contractWrapper.getChainID(),a=(0,p.i)(t.currencyContractAddress)?m.aX[r].wrapped.address:t.currencyContractAddress,n=this.contractWrapper.getProvider(),o=(await Promise.resolve().then(e.t.bind(e,96337,19))).default,s=new m.cs(n,a,o,{},this.storage);if((await s.read("balanceOf",[t.offerorAddress])).lt(t.totalPrice))return{valid:!1,error:"Offeror ".concat(t.offerorAddress," doesn't have enough balance of token ").concat(a)};return(await s.read("allowance",[t.offerorAddress,this.getAddress()])).lt(t.totalPrice)?{valid:!1,error:"Offeror ".concat(t.offerorAddress," hasn't approved enough amount of token ").concat(a)}:{valid:!0,error:""}}async applyFilter(t,r){let e=[...t];if(r){if(r.offeror){const t=await(0,m.aM)(r.offeror);e=e.filter((r=>r.offeror.toString().toLowerCase()===(null===t||void 0===t?void 0:t.toString().toLowerCase())))}if(r.tokenContract){const t=await(0,m.aM)(r.tokenContract);e=e.filter((r=>r.assetContract.toString().toLowerCase()===(null===t||void 0===t?void 0:t.toString().toLowerCase())))}void 0!==r.tokenId&&(e=e.filter((t=>{var e;return t.tokenId.toString()===(null===r||void 0===r||null===(e=r.tokenId)||void 0===e?void 0:e.toString())})))}return null!==r&&void 0!==r&&r.count&&r.count<e.length?e.slice(0,r.count):e}}}}]);
//# sourceMappingURL=29723.ef1acfd8.chunk.js.map