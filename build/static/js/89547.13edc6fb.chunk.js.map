{"version":3,"file":"static/js/89547.13edc6fb.chunk.js","mappings":"6IAiBO,MAAMA,EAAc,aACrBC,EAAY,CAChB,CACEC,KAAM,UACNC,KAAM,QAER,CACED,KAAM,QACNC,KAAM,cAGJC,EAAa,CACjB,CACEF,KAAM,WAkGHG,eAAeC,EACpBC,GAEA,OAAOC,EAAAA,EAAAA,cAAa,CAClBC,SAAUF,EAAQE,SAClBC,OAAQ,CAACV,EAAaC,EAAWG,GACjCO,OAAQ,CAACJ,EAAQK,KAAML,EAAQM,YAEnC,C,qECxIO,MAAMC,EAAuB,iC,qCCyB9B,SAAUC,EACdC,EACAC,GAEA,MAAMC,EACmB,kBAAZF,GAA6BG,EAAAA,EAAAA,IAAcH,GAClDA,EAAQI,eAAeC,WAAmBL,EAAQI,KAC/CE,EAAAA,EAAAA,IAAQN,EAAQI,KAEnBG,GAAcJ,EAAAA,EAAAA,IAAc,GAADK,OAC5BV,GAAoBU,OAAGN,EAAaO,SAEzC,OAAOC,EAAAA,EAAAA,IAAUF,EAAAA,EAAAA,IAAO,CAACD,EAAaL,IAAgBD,EACxD,C,0BC5BA,MAAMU,EAAc,aAoBbtB,eAAeuB,EACpBrB,GAEA,KAAKsB,EAAAA,EAAAA,GAAMtB,EAAQM,WACjB,MAAM,IAAIiB,MAAM,6CAOlB,aALqBxB,EAAAA,EAAAA,IAAiB,CACpCG,SAAUF,EAAQE,SAClBG,KAAMG,EAAYR,EAAQS,SAC1BH,UAAWN,EAAQM,cAEHc,CACpB,C","sources":["../node_modules/thirdweb/src/extensions/erc1271/__generated__/isValidSignature/read/isValidSignature.ts","../node_modules/viem/constants/strings.ts","../node_modules/viem/utils/signature/hashMessage.ts","../node_modules/thirdweb/src/extensions/erc1271/checkContractWalletSignature.ts"],"sourcesContent":["import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"isValidSignature\" function.\n */\nexport type IsValidSignatureParams = {\n  hash: AbiParameterToPrimitiveType<{ type: \"bytes32\"; name: \"hash\" }>;\n  signature: AbiParameterToPrimitiveType<{ type: \"bytes\"; name: \"signature\" }>;\n};\n\nexport const FN_SELECTOR = \"0x1626ba7e\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"bytes32\",\n    name: \"hash\",\n  },\n  {\n    type: \"bytes\",\n    name: \"signature\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"bytes4\",\n  },\n] as const;\n\n/**\n * Checks if the `isValidSignature` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `isValidSignature` method is supported.\n * @extension ERC1271\n * @example\n * ```ts\n * import { isIsValidSignatureSupported } from \"thirdweb/extensions/erc1271\";\n *\n * const supported = await isIsValidSignatureSupported(contract);\n * ```\n */\nexport async function isIsValidSignatureSupported(\n  contract: ThirdwebContract<any>,\n) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"isValidSignature\" function.\n * @param options - The options for the isValidSignature function.\n * @returns The encoded ABI parameters.\n * @extension ERC1271\n * @example\n * ```ts\n * import { encodeIsValidSignatureParams } \"thirdweb/extensions/erc1271\";\n * const result = encodeIsValidSignatureParams({\n *  hash: ...,\n *  signature: ...,\n * });\n * ```\n */\nexport function encodeIsValidSignatureParams(options: IsValidSignatureParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.hash, options.signature]);\n}\n\n/**\n * Encodes the \"isValidSignature\" function into a Hex string with its parameters.\n * @param options - The options for the isValidSignature function.\n * @returns The encoded hexadecimal string.\n * @extension ERC1271\n * @example\n * ```ts\n * import { encodeIsValidSignature } \"thirdweb/extensions/erc1271\";\n * const result = encodeIsValidSignature({\n *  hash: ...,\n *  signature: ...,\n * });\n * ```\n */\nexport function encodeIsValidSignature(options: IsValidSignatureParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeIsValidSignatureParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the isValidSignature function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC1271\n * @example\n * ```ts\n * import { decodeIsValidSignatureResult } from \"thirdweb/extensions/erc1271\";\n * const result = decodeIsValidSignatureResult(\"...\");\n * ```\n */\nexport function decodeIsValidSignatureResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"isValidSignature\" function on the contract.\n * @param options - The options for the isValidSignature function.\n * @returns The parsed result of the function call.\n * @extension ERC1271\n * @example\n * ```ts\n * import { isValidSignature } from \"thirdweb/extensions/erc1271\";\n *\n * const result = await isValidSignature({\n *  contract,\n *  hash: ...,\n *  signature: ...,\n * });\n *\n * ```\n */\nexport async function isValidSignature(\n  options: BaseTransactionOptions<IsValidSignatureParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.hash, options.signature],\n  });\n}\n","export const presignMessagePrefix = '\\x19Ethereum Signed Message:\\n'\n","import { presignMessagePrefix } from '../../constants/strings.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex, SignableMessage } from '../../types/misc.js'\nimport { type ConcatErrorType, concat } from '../data/concat.js'\nimport {\n  type StringToBytesErrorType,\n  type ToBytesErrorType,\n  stringToBytes,\n  toBytes,\n} from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type HashMessage<TTo extends To> =\n  | (TTo extends 'bytes' ? ByteArray : never)\n  | (TTo extends 'hex' ? Hex : never)\n\nexport type HashMessageErrorType =\n  | ConcatErrorType\n  | Keccak256ErrorType\n  | StringToBytesErrorType\n  | ToBytesErrorType\n  | ErrorType\n\nexport function hashMessage<TTo extends To = 'hex'>(\n  message: SignableMessage,\n  to_?: TTo | undefined,\n): HashMessage<TTo> {\n  const messageBytes = (() => {\n    if (typeof message === 'string') return stringToBytes(message)\n    if (message.raw instanceof Uint8Array) return message.raw\n    return toBytes(message.raw)\n  })()\n  const prefixBytes = stringToBytes(\n    `${presignMessagePrefix}${messageBytes.length}`,\n  )\n  return keccak256(concat([prefixBytes, messageBytes]), to_)\n}\n","import { type SignableMessage, hashMessage } from \"viem\";\nimport type { ThirdwebContract } from \"../../contract/contract.js\";\nimport { isHex } from \"../../utils/encoding/hex.js\";\nimport { isValidSignature } from \"./__generated__/isValidSignature/read/isValidSignature.js\";\n\nexport type CheckContractWalletSignatureOptions = {\n  contract: ThirdwebContract;\n  message: SignableMessage;\n  signature: string;\n};\nconst MAGIC_VALUE = \"0x1626ba7e\";\n\n/**\n * Checks if a contract wallet signature is valid.\n * @param options - The options for the checkContractWalletSignature function.\n * @param options.contract - The contract to check the signature against.\n * @param options.message - The message to check the signature against.\n * @param options.signature - The signature to check.\n * @extension ERC1271\n * @example\n * ```ts\n * import { checkContractWalletSignature } from \"thirdweb/extensions/erc1271\";\n * const isValid = await checkContractWalletSignature({\n *  contract: myContract,\n *  message: \"hello world\",\n *  signature: \"0x...\",\n * });\n * ```\n * @returns A promise that resolves with a boolean indicating if the signature is valid.\n */\nexport async function checkContractWalletSignature(\n  options: CheckContractWalletSignatureOptions,\n) {\n  if (!isHex(options.signature)) {\n    throw new Error(\"The signature must be a valid hex string.\");\n  }\n  const result = await isValidSignature({\n    contract: options.contract,\n    hash: hashMessage(options.message),\n    signature: options.signature,\n  });\n  return result === MAGIC_VALUE;\n}\n"],"names":["FN_SELECTOR","FN_INPUTS","type","name","FN_OUTPUTS","async","isValidSignature","options","readContract","contract","method","params","hash","signature","presignMessagePrefix","hashMessage","message","to_","messageBytes","stringToBytes","raw","Uint8Array","toBytes","prefixBytes","concat","length","keccak256","MAGIC_VALUE","checkContractWalletSignature","isHex","Error"],"sourceRoot":""}