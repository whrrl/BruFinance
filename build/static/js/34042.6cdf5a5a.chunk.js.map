{"version":3,"file":"static/js/34042.6cdf5a5a.chunk.js","mappings":"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","sources":["../node_modules/@thirdweb-dev/wallets/dist/http-rpc-client-0a079e80.browser.esm.js","../node_modules/@thirdweb-dev/wallets/evm/connectors/smart-wallet/dist/thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm.js"],"sourcesContent":["import { utils, BigNumber, providers } from 'ethers';\nimport { i as isTwUrl } from './url-a45219bd.browser.esm.js';\nimport { s as setAnalyticsHeaders } from './headers-733a8199.browser.esm.js';\nimport { e as isZkSyncChain, M as MANAGED_ACCOUNT_GAS_BUFFER } from './utils-f58e7acc.browser.esm.js';\n\nasync function hexlifyUserOp(\n// TODO: types\nop) {\n  const userOp = await utils.resolveProperties(op);\n  return Object.keys(userOp).map(key => {\n    let val = userOp[key];\n    if (typeof val !== \"string\" || !val.startsWith(\"0x\")) {\n      val = utils.hexValue(val);\n    }\n    return [key, val];\n  }).reduce((set, _ref) => {\n    let [k, v] = _ref;\n    return {\n      ...set,\n      [k]: v\n    };\n  }, {});\n}\n\n// v0.6 userOpHash calculation\nasync function getUserOpHashV06(userOp, entryPoint, chainId) {\n  const op = await utils.resolveProperties(userOp);\n  const hashedUserOp = {\n    sender: op.sender,\n    nonce: op.nonce,\n    initCodeHash: utils.keccak256(op.initCode),\n    callDataHash: utils.keccak256(op.callData),\n    callGasLimit: op.callGasLimit,\n    verificationGasLimit: op.verificationGasLimit,\n    preVerificationGas: op.preVerificationGas,\n    maxFeePerGas: op.maxFeePerGas,\n    maxPriorityFeePerGas: op.maxPriorityFeePerGas,\n    paymasterAndDataHash: utils.keccak256(op.paymasterAndData)\n  };\n  const userOpType = {\n    components: [{\n      type: \"address\",\n      name: \"sender\"\n    }, {\n      type: \"uint256\",\n      name: \"nonce\"\n    }, {\n      type: \"bytes32\",\n      name: \"initCodeHash\"\n    }, {\n      type: \"bytes32\",\n      name: \"callDataHash\"\n    }, {\n      type: \"uint256\",\n      name: \"callGasLimit\"\n    }, {\n      type: \"uint256\",\n      name: \"verificationGasLimit\"\n    }, {\n      type: \"uint256\",\n      name: \"preVerificationGas\"\n    }, {\n      type: \"uint256\",\n      name: \"maxFeePerGas\"\n    }, {\n      type: \"uint256\",\n      name: \"maxPriorityFeePerGas\"\n    }, {\n      type: \"bytes32\",\n      name: \"paymasterAndDataHash\"\n    }],\n    name: \"hashedUserOp\",\n    type: \"tuple\"\n  };\n  const encoded = utils.defaultAbiCoder.encode([userOpType], [{\n    ...hashedUserOp\n  }]);\n  // remove leading word (total length) and trailing word (zero-length signature)\n\n  const userOpHash = utils.keccak256(encoded);\n  const enc = utils.defaultAbiCoder.encode([\"bytes32\", \"address\", \"uint256\"], [userOpHash, entryPoint, chainId]);\n  return utils.keccak256(enc);\n}\nconst generateRandomUint192 = () => {\n  const rand1 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand2 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand3 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand4 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand5 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand6 = BigInt(Math.floor(Math.random() * 0x100000000));\n  return rand1 << BigInt(160) | rand2 << BigInt(128) | rand3 << BigInt(96) | rand4 << BigInt(64) | rand5 << BigInt(32) | rand6;\n};\nconst randomNonce = () => {\n  let hexString = generateRandomUint192().toString(16);\n  if (hexString.length % 2 !== 0) {\n    hexString = \"0\" + hexString;\n  }\n  hexString = \"0x\" + hexString;\n  return BigNumber.from(utils.concat([hexString, \"0x0000000000000000\"]));\n};\n\nconst DEBUG = false; // TODO set as public flag\n\nclass HttpRpcClient {\n  constructor(bundlerUrl, entryPointAddress, chainId, clientId, secretKey) {\n    this.bundlerUrl = bundlerUrl;\n    this.entryPointAddress = entryPointAddress;\n    this.chainId = chainId;\n    const headers = {};\n    if (isTwUrl(this.bundlerUrl)) {\n      const bundleId = typeof globalThis !== \"undefined\" && \"APP_BUNDLE_ID\" in globalThis ? globalThis.APP_BUNDLE_ID : undefined;\n      if (secretKey) {\n        headers[\"x-secret-key\"] = secretKey;\n      } else if (clientId) {\n        headers[\"x-client-id\"] = clientId;\n        if (bundleId) {\n          headers[\"x-bundle-id\"] = bundleId;\n        }\n      }\n\n      // Dashboard token\n      if (typeof globalThis !== \"undefined\" && \"TW_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;\n      }\n\n      // CLI token\n      if (typeof globalThis !== \"undefined\" && \"TW_CLI_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`;\n        headers[\"x-authorize-wallet\"] = \"true\";\n      }\n      setAnalyticsHeaders(headers);\n    }\n    this.userOpJsonRpcProvider = new providers.StaticJsonRpcProvider({\n      url: this.bundlerUrl,\n      headers\n    }, {\n      name: \"Connected bundler network\",\n      chainId\n    });\n    this.initializing = this.validateChainId();\n  }\n  async validateChainId() {\n    if (await isZkSyncChain(this.chainId)) {\n      return;\n    }\n    // validate chainId is in sync with expected chainid\n    const chain = await this.userOpJsonRpcProvider.send(\"eth_chainId\", []);\n    const bundlerChain = parseInt(chain);\n    if (bundlerChain !== this.chainId) {\n      throw new Error(`bundler ${this.bundlerUrl} is on chainId ${bundlerChain}, but provider is on chainId ${this.chainId}`);\n    }\n  }\n\n  /**\n   * send a UserOperation to the bundler\n   * @param userOp1 - The UserOperation to send\n   * @returns userOpHash the id of this operation, for getUserOperationTransaction\n   */\n  async sendUserOpToBundler(userOp1) {\n    await this.initializing;\n    const hexifiedUserOp = await hexlifyUserOp(userOp1);\n    const jsonRequestData = [hexifiedUserOp, this.entryPointAddress];\n    await this.printUserOperation(\"eth_sendUserOperation\", jsonRequestData);\n    return await this.userOpJsonRpcProvider.send(\"eth_sendUserOperation\", [hexifiedUserOp, this.entryPointAddress]);\n  }\n  async estimateUserOpGas(userOp) {\n    await this.initializing;\n    const hexifiedUserOp = await hexlifyUserOp(userOp);\n    const jsonRequestData = [hexifiedUserOp, this.entryPointAddress];\n    await this.printUserOperation(\"eth_estimateUserOperationGas\", jsonRequestData);\n    const data = await this.userOpJsonRpcProvider.send(\"eth_estimateUserOperationGas\", [hexifiedUserOp, this.entryPointAddress]);\n    // adds gas buffer to callGasLimit to account for ManagedAccountFactory delegate calls\n    return {\n      preVerificationGas: BigNumber.from(data.preVerificationGas),\n      verificationGas: BigNumber.from(data.verificationGas),\n      verificationGasLimit: BigNumber.from(data.verificationGasLimit),\n      callGasLimit: BigNumber.from(data.callGasLimit).add(MANAGED_ACCOUNT_GAS_BUFFER)\n    };\n  }\n  async getUserOperationGasPrice() {\n    await this.initializing;\n    return await this.userOpJsonRpcProvider.send(\"thirdweb_getUserOperationGasPrice\", []);\n  }\n  async getUserOperationReceipt(userOpHash) {\n    await this.initializing;\n    return await this.userOpJsonRpcProvider.send(\"eth_getUserOperationReceipt\", [userOpHash]);\n  }\n  async zkPaymasterData(transactionInput) {\n    await this.initializing;\n    return await this.userOpJsonRpcProvider.send(\"zk_paymasterData\", [await hexlifyUserOp({\n      ...transactionInput,\n      gas: transactionInput.gasLimit\n    })]);\n  }\n  async zkBroadcastTransaction(transactionInput) {\n    await this.initializing;\n    return await this.userOpJsonRpcProvider.send(\"zk_broadcastTransaction\", [transactionInput]);\n  }\n  async printUserOperation(method, _ref) {\n    {\n      return;\n    }\n  }\n}\n\nexport { DEBUG as D, HttpRpcClient as H, getUserOpHashV06 as g, hexlifyUserOp as h, randomNonce as r };\n","import { C as Connector } from '../../../../dist/connector-05689d68.browser.esm.js';\nimport { h as hexlifyUserOp, D as DEBUG, r as randomNonce, H as HttpRpcClient, g as getUserOpHashV06 } from '../../../../dist/http-rpc-client-0a079e80.browser.esm.js';\nimport { i as isTwUrl } from '../../../../dist/url-a45219bd.browser.esm.js';\nimport { s as setAnalyticsHeaders } from '../../../../dist/headers-733a8199.browser.esm.js';\nimport { EntryPoint__factory } from '@account-abstraction/contracts';\nimport { utils, Signer, ethers, providers, Contract, BigNumber, constants } from 'ethers';\nimport { _ as _defineProperty } from '../../../../dist/defineProperty-350fc508.browser.esm.js';\nimport { signTypedDataInternal, getDynamicFeeData, ThirdwebSDK, LOCAL_NODE_PKEY, getChainProvider, getGasPrice } from '@thirdweb-dev/sdk';\nimport { chainIdToThirdwebRpc } from '../../../wallets/abstract/dist/thirdweb-dev-wallets-evm-wallets-abstract.browser.esm.js';\nimport { c as checkContractWalletSignature, A as ACCOUNT_CORE_ABI, f as ENTRYPOINT_ADDRESS, D as DEFAULT_FACTORY_ADDRESS } from '../../../../dist/utils-f58e7acc.browser.esm.js';\nimport { Celo, CeloAlfajoresTestnet, CeloBaklavaTestnet } from '@thirdweb-dev/chains';\nimport 'eventemitter3';\n\n/**\n * @internal\n */\n\n/**\n * @internal\n */\n\n/**\n * an API to external a UserOperation with paymaster info\n */\nclass PaymasterAPI {}\n\nclass VerifyingPaymasterAPI extends PaymasterAPI {\n  constructor(paymasterUrl, entryPoint, clientId, secretKey) {\n    super();\n    this.paymasterUrl = paymasterUrl;\n    this.entryPoint = entryPoint;\n    this.clientId = clientId;\n    this.secretKey = secretKey;\n  }\n  async getPaymasterAndData(userOp) {\n    const headers = {\n      \"Content-Type\": \"application/json\"\n    };\n    if (isTwUrl(this.paymasterUrl)) {\n      if (this.secretKey && this.clientId) {\n        throw new Error(\"Cannot use both secret key and client ID. Please use secretKey for server-side applications and clientId for client-side applications.\");\n      }\n      if (this.secretKey) {\n        headers[\"x-secret-key\"] = this.secretKey;\n      } else if (this.clientId) {\n        headers[\"x-client-id\"] = this.clientId;\n        const bundleId = typeof globalThis !== \"undefined\" && \"APP_BUNDLE_ID\" in globalThis ? globalThis.APP_BUNDLE_ID : undefined;\n        if (bundleId) {\n          headers[\"x-bundle-id\"] = bundleId;\n        }\n      }\n\n      // Dashboard token.\n      if (typeof globalThis !== \"undefined\" && \"TW_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;\n      }\n\n      // CLI token.\n      if (typeof globalThis !== \"undefined\" && \"TW_CLI_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`;\n        headers[\"x-authorize-wallet\"] = \"true\";\n      }\n      setAnalyticsHeaders(headers);\n    }\n\n    // Ask the paymaster to sign the transaction and return a valid paymasterAndData value.\n    const response = await fetch(this.paymasterUrl, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: 1,\n        method: \"pm_sponsorUserOperation\",\n        params: [await hexlifyUserOp(userOp), this.entryPoint]\n      })\n    });\n    const res = await response.json();\n    if (!response.ok) {\n      const error = res.error || response.statusText;\n      const code = res.code || \"UNKNOWN\";\n      throw new Error(`Paymaster error: ${error}\nStatus: ${response.status}\nCode: ${code}`);\n    }\n    if (DEBUG) {\n      console.debug(\"Paymaster result:\", res);\n    }\n    if (res.result) {\n      // some paymasters return a string, some return an object with more data\n      if (typeof res.result === \"string\") {\n        return {\n          paymasterAndData: res.result\n        };\n      } else {\n        return res.result;\n      }\n    } else {\n      const error = res.error?.message || res.error || response.statusText || \"unknown error\";\n      throw new Error(`Paymaster error from ${this.paymasterUrl}: ${error}`);\n    }\n  }\n}\nconst getVerifyingPaymaster = (paymasterUrl, entryPoint, clientId, secretKey) => new VerifyingPaymasterAPI(paymasterUrl, entryPoint, clientId, secretKey);\n\n/**\n * This class encapsulates Ethers.js listener function and necessary UserOperation details to\n * discover a TransactionReceipt for the operation.\n *\n * TODO refactor this to a simple event listener on the entry point\n */\nclass UserOperationEventListener {\n  constructor(resolve, reject, entryPoint, sender, userOpHash, nonce, timeout) {\n    this.resolve = resolve;\n    this.reject = reject;\n    this.entryPoint = entryPoint;\n    this.sender = sender;\n    this.userOpHash = userOpHash;\n    this.nonce = nonce;\n    this.timeout = timeout;\n    _defineProperty(this, \"resolved\", false);\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    this.boundLisener = this.listenerCallback.bind(this);\n  }\n  start() {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    const filter = this.entryPoint.filters.UserOperationEvent(this.userOpHash);\n    // listener takes time... first query directly:\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    setTimeout(async () => {\n      const res = await this.entryPoint.queryFilter(filter, -10); // look at last 10 blocks\n      if (res.length > 0) {\n        void this.listenerCallback(res[0]);\n      } else {\n        this.entryPoint.once(filter, this.boundLisener);\n      }\n    }, 100);\n  }\n  stop() {\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    this.entryPoint.off(\"UserOperationEvent\", this.boundLisener);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async listenerCallback() {\n    for (var _len = arguments.length, param = new Array(_len), _key = 0; _key < _len; _key++) {\n      param[_key] = arguments[_key];\n    }\n    // TODO clean this up..\n    // eslint-disable-next-line prefer-rest-params\n    const event = arguments[arguments.length - 1];\n    if (!event.args) {\n      console.error(\"got event without args\", event);\n      return;\n    }\n    // TODO: can this happen? we register to event by userOpHash..\n    if (event.args.userOpHash !== this.userOpHash) {\n      console.log(`== event with wrong userOpHash: sender/nonce: event.${event.args.sender}@${event.args.nonce.toString()}!= userOp.${this.sender}@${parseInt(this.nonce?.toString())}`);\n      return;\n    }\n    const transactionReceipt = await event.getTransactionReceipt();\n\n    // before returning the receipt, update the status from the event.\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (!event.args.success) {\n      await this.extractFailureReason(transactionReceipt);\n    }\n    this.stop();\n    this.resolve(transactionReceipt);\n    this.resolved = true;\n  }\n  async extractFailureReason(receipt) {\n    receipt.status = 0;\n    const revertReasonEvents = await this.entryPoint.queryFilter(this.entryPoint.filters.UserOperationRevertReason(this.userOpHash, this.sender), receipt.blockHash);\n    if (revertReasonEvents[0]) {\n      let message = revertReasonEvents[0].args.revertReason;\n      if (message.startsWith(\"0x08c379a0\")) {\n        // Error(string)\n        message = utils.defaultAbiCoder.decode([\"string\"], \"0x\" + message.substring(10)).toString();\n      }\n      this.reject(new Error(`UserOp failed with reason: ${message}`));\n    }\n  }\n}\n\nclass ERC4337EthersSigner extends Signer {\n  // TODO: we have 'erc4337provider', remove shared dependencies or avoid two-way reference\n  constructor(config, originalSigner, erc4337provider, httpRpcClient, smartAccountAPI) {\n    super();\n    utils.defineReadOnly(this, \"provider\", erc4337provider);\n    this.config = config;\n    this.originalSigner = originalSigner;\n    this.erc4337provider = erc4337provider;\n    this.httpRpcClient = httpRpcClient;\n    this.smartAccountAPI = smartAccountAPI;\n    this.approving = false;\n  }\n  // This one is called by Contract. It signs the request and passes in to Provider to be sent.\n  async sendTransaction(transaction, options) {\n    if (!this.approving) {\n      this.approving = true;\n      const tx = await this.smartAccountAPI.createApproveTx();\n      if (tx) {\n        await (await this.sendTransaction(tx)).wait();\n      }\n      this.approving = false;\n    }\n    const tx = await ethers.utils.resolveProperties(transaction);\n    await this.verifyAllNecessaryFields(tx);\n    const multidimensionalNonce = randomNonce();\n    const unsigned = await this.smartAccountAPI.createUnsignedUserOp(this.httpRpcClient, {\n      target: tx.to || \"\",\n      data: tx.data?.toString() || \"0x\",\n      value: tx.value,\n      gasLimit: tx.gasLimit,\n      nonce: multidimensionalNonce,\n      maxFeePerGas: tx.maxFeePerGas,\n      maxPriorityFeePerGas: tx.maxPriorityFeePerGas\n    }, options);\n    const userOperation = await this.smartAccountAPI.signUserOp(unsigned);\n    const transactionResponse = await this.erc4337provider.constructUserOpTransactionResponse(userOperation);\n    try {\n      await this.httpRpcClient.sendUserOpToBundler(userOperation);\n    } catch (error) {\n      throw this.unwrapError(error);\n    }\n    // TODO: handle errors - transaction that is \"rejected\" by bundler is _not likely_ to ever resolve its \"wait()\"\n    return transactionResponse;\n  }\n  unwrapError(errorIn) {\n    try {\n      let errorMsg = \"Unknown Error\";\n      if (errorIn.error) {\n        errorMsg = `The bundler has failed to include UserOperation in a batch: ${errorIn.error}`;\n      } else if (errorIn.body && typeof errorIn.body === \"string\") {\n        const errorBody = JSON.parse(errorIn.body);\n        const errorStatus = errorIn.status || \"UNKNOWN\";\n        const errorCode = errorBody?.code || \"UNKNOWN\";\n        let failedOpMessage = errorBody?.error?.message || errorBody?.error?.data || errorBody?.error || errorIn.reason;\n        if (failedOpMessage?.includes(\"FailedOp\")) {\n          let paymasterInfo = \"\";\n          // TODO: better error extraction methods will be needed\n          const matched = failedOpMessage.match(/FailedOp\\((.*)\\)/);\n          if (matched) {\n            const split = matched[1].split(\",\");\n            paymasterInfo = `(paymaster address: ${split[1]})`;\n            failedOpMessage = split[2];\n          }\n          errorMsg = `The bundler has failed to include UserOperation in a batch: ${failedOpMessage} ${paymasterInfo}`;\n        } else {\n          errorMsg = `RPC error: ${failedOpMessage}\nStatus: ${errorStatus}\nCode: ${errorCode}`;\n        }\n      }\n      const error = new Error(errorMsg);\n      error.stack = errorIn.stack;\n      return error;\n    } catch (error) {}\n    return errorIn;\n  }\n  async verifyAllNecessaryFields(transactionRequest) {\n    if (!transactionRequest.to) {\n      throw new Error(\"Missing call target\");\n    }\n    if (!transactionRequest.data && !transactionRequest.value) {\n      // TBD: banning no-op UserOps seems to make sense on provider level\n      throw new Error(\"Missing call data or value\");\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  connect(provider) {\n    throw new Error(\"changing providers is not supported\");\n  }\n  async getAddress() {\n    if (!this.address) {\n      this.address = await this.erc4337provider.getSenderAccountAddress();\n    }\n    return this.address;\n  }\n\n  /**\n   * Sign a message and return the signature\n   */\n  async signMessage(message) {\n    // Deploy smart wallet if needed\n    const isNotDeployed = await this.smartAccountAPI.checkAccountPhantom();\n    if (isNotDeployed) {\n      console.log(\"Account contract not deployed yet. Deploying account before signing message\");\n      const tx = await this.sendTransaction({\n        to: await this.getAddress(),\n        data: \"0x\"\n      });\n      await tx.wait();\n    }\n    const [chainId, address] = await Promise.all([this.getChainId(), this.getAddress()]);\n    const originalMsgHash = utils.hashMessage(message);\n    let factorySupports712;\n    let signature;\n    const rpcUrl = chainIdToThirdwebRpc(chainId, this.config.clientId);\n    const headers = {};\n    if (isTwUrl(rpcUrl)) {\n      const bundleId = typeof globalThis !== \"undefined\" && \"APP_BUNDLE_ID\" in globalThis ? globalThis.APP_BUNDLE_ID : undefined;\n      if (this.config.secretKey) {\n        headers[\"x-secret-key\"] = this.config.secretKey;\n      } else if (this.config.clientId) {\n        headers[\"x-client-id\"] = this.config.clientId;\n        if (bundleId) {\n          headers[\"x-bundle-id\"] = bundleId;\n        }\n      }\n\n      // Dashboard token\n      if (typeof globalThis !== \"undefined\" && \"TW_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_AUTH_TOKEN}`;\n      }\n\n      // CLI token\n      if (typeof globalThis !== \"undefined\" && \"TW_CLI_AUTH_TOKEN\" in globalThis && typeof globalThis.TW_CLI_AUTH_TOKEN === \"string\") {\n        headers[\"authorization\"] = `Bearer ${globalThis.TW_CLI_AUTH_TOKEN}`;\n        headers[\"x-authorize-wallet\"] = \"true\";\n      }\n      setAnalyticsHeaders(headers);\n    }\n    try {\n      const provider = new providers.StaticJsonRpcProvider({\n        url: rpcUrl,\n        headers\n      }, chainId);\n      const walletContract = new Contract(address, [\"function getMessageHash(bytes32 _hash) public view returns (bytes32)\"], provider);\n      // if this fails it's a pre 712 factory\n      await walletContract.getMessageHash(originalMsgHash);\n      factorySupports712 = true;\n    } catch {\n      factorySupports712 = false;\n    }\n    if (factorySupports712) {\n      const result = await signTypedDataInternal(this, {\n        name: \"Account\",\n        version: \"1\",\n        chainId,\n        verifyingContract: address\n      }, {\n        AccountMessage: [{\n          name: \"message\",\n          type: \"bytes\"\n        }]\n      }, {\n        message: utils.defaultAbiCoder.encode([\"bytes32\"], [originalMsgHash])\n      });\n      signature = result.signature;\n    } else {\n      signature = await this.originalSigner.signMessage(message);\n    }\n    const isValid = await checkContractWalletSignature(message, signature, address, chainId, this.config.clientId, this.config.secretKey);\n    if (isValid) {\n      return signature;\n    } else {\n      throw new Error(\"Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.\");\n    }\n  }\n  async signTransaction(transaction, options) {\n    const tx = await ethers.utils.resolveProperties(transaction);\n    await this.verifyAllNecessaryFields(tx);\n    const multidimensionalNonce = randomNonce();\n    const unsigned = await this.smartAccountAPI.createUnsignedUserOp(this.httpRpcClient, {\n      target: tx.to || \"\",\n      data: tx.data?.toString() || \"0x\",\n      value: tx.value,\n      gasLimit: tx.gasLimit,\n      nonce: multidimensionalNonce\n    }, options);\n    const userOperation = await this.smartAccountAPI.signUserOp(unsigned);\n    const userOpString = JSON.stringify(await hexlifyUserOp(userOperation));\n    return userOpString;\n  }\n}\n\nclass ERC4337EthersProvider extends providers.BaseProvider {\n  constructor(chainId, config, originalSigner, originalProvider, httpRpcClient, entryPoint, smartAccountAPI) {\n    super({\n      name: \"ERC-4337 Custom Network\",\n      chainId\n    });\n    this.chainId = chainId;\n    this.config = config;\n    this.originalSigner = originalSigner;\n    this.originalProvider = originalProvider;\n    this.httpRpcClient = httpRpcClient;\n    this.entryPoint = entryPoint;\n    this.smartAccountAPI = smartAccountAPI;\n    this.signer = new ERC4337EthersSigner(config, originalSigner, this, httpRpcClient, smartAccountAPI);\n  }\n  getSigner() {\n    return this.signer;\n  }\n  async perform(method, params) {\n    if (method === \"sendTransaction\" || method === \"getTransactionReceipt\") {\n      // TODO: do we need 'perform' method to be available at all?\n      // there is nobody out there to use it for ERC-4337 methods yet, we have nothing to override in fact.\n      throw new Error(\"Should not get here. Investigate.\");\n    }\n    if (method === \"estimateGas\") {\n      // gas estimation does nothing at this layer, sendTransaction will do the gas estimation for the userOp\n      return BigNumber.from(500000);\n    }\n    return await this.originalProvider.perform(method, params);\n  }\n  async getTransaction(transactionHash) {\n    // TODO\n    return await super.getTransaction(transactionHash);\n  }\n  async getTransactionReceipt(transactionHash) {\n    const userOpHash = await transactionHash;\n    const sender = await this.getSenderAccountAddress();\n    return await new Promise((resolve, reject) => {\n      new UserOperationEventListener(resolve, reject, this.entryPoint, sender, userOpHash).start();\n    });\n  }\n  async getSenderAccountAddress() {\n    return await this.smartAccountAPI.getAccountAddress();\n  }\n  async waitForTransaction(transactionHash, confirmations, timeout) {\n    const sender = await this.getSenderAccountAddress();\n    return await new Promise((resolve, reject) => {\n      const listener = new UserOperationEventListener(resolve, reject, this.entryPoint, sender, transactionHash, undefined, timeout);\n      listener.start();\n    });\n  }\n\n  // fabricate a response in a format usable by ethers users...\n  async constructUserOpTransactionResponse(userOp1) {\n    const userOp = await utils.resolveProperties(userOp1);\n    const userOpHash = await this.smartAccountAPI.getUserOpHash(userOp);\n    return {\n      hash: userOpHash,\n      confirmations: 0,\n      from: userOp.sender,\n      nonce: 0,\n      // not the real nonce, but good enough for this purpose\n      gasLimit: BigNumber.from(userOp.callGasLimit),\n      // ??\n      value: BigNumber.from(0),\n      data: utils.hexValue(userOp.callData),\n      // should extract the actual called method from this \"execFromEntryPoint()\" call\n      chainId: this.chainId,\n      wait: async confirmations => {\n        const transactionReceipt = await this.smartAccountAPI.getUserOpReceipt(this.httpRpcClient, userOpHash);\n        if (userOp.initCode.length !== 0) {\n          // checking if the wallet has been deployed by the transaction; it must be if we are here\n          await this.smartAccountAPI.checkAccountPhantom();\n        }\n        return transactionReceipt;\n      }\n    };\n  }\n  async detectNetwork() {\n    return this.originalProvider.detectNetwork();\n  }\n}\n\n/**\n * wrap an existing provider to tunnel requests through Account Abstraction.\n * @param originalProvider - The normal provider\n * @param config - see {@link ClientConfig} for more info\n * @param originalSigner - use this signer as the owner. of this wallet. By default, use the provider's signer\n */\nfunction create4337Provider(config, accountApi, originalProvider, chainId) {\n  const entryPoint = EntryPoint__factory.connect(config.entryPointAddress, originalProvider);\n  const httpRpcClient = new HttpRpcClient(config.bundlerUrl, config.entryPointAddress, chainId, config.clientId, config.secretKey);\n  return new ERC4337EthersProvider(chainId, config, config.localSigner, originalProvider, httpRpcClient, entryPoint, accountApi);\n}\n\nconst DUMMY_SIGNATURE = \"0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c\";\n\n/**\n * Base class for all Smart Wallet ERC-4337 Clients to implement.\n * Subclass should inherit 5 methods to support a specific wallet contract:\n *\n * - getAccountInitCode - return the value to put into the \"initCode\" field, if the account is not yet deployed. should create the account instance using a factory contract.\n * - getNonce - return current account's nonce value\n * - encodeExecute - encode the call from entryPoint through our account to the target contract.\n * - signUserOpHash - sign the hash of a UserOp.\n *\n * The user can use the following APIs:\n * - createUnsignedUserOp - given \"target\" and \"calldata\", fill userOp to perform that operation from the account.\n * - createSignedUserOp - helper to call the above createUnsignedUserOp, and then extract the userOpHash and sign it\n */\nclass BaseAccountAPI {\n  // entryPoint connected to \"zero\" address. allowed to make static calls (e.g. to getSenderAddress)\n\n  /**\n   * base constructor.\n   * subclass SHOULD add parameters that define the owner (signer) of this wallet\n   */\n  constructor(params) {\n    _defineProperty(this, \"isPhantom\", true);\n    this.provider = params.provider;\n    this.entryPointAddress = params.entryPointAddress;\n    this.accountAddress = params.accountAddress;\n    this.paymasterAPI = params.paymasterAPI;\n    this.gasless = params.gasless;\n    this.erc20PaymasterAddress = params.erc20PaymasterAddress;\n    this.erc20TokenAddress = params.erc20TokenAddress;\n\n    // factory \"connect\" define the contract address. the contract \"connect\" defines the \"from\" address.\n    this.entryPointView = EntryPoint__factory.connect(params.entryPointAddress, params.provider).connect(ethers.constants.AddressZero);\n  }\n\n  /**\n   * return the value to put into the \"initCode\" field, if the contract is not yet deployed.\n   * this value holds the \"factory\" address, followed by this account's information\n   */\n\n  /**\n   * return current account's nonce.\n   */\n\n  /**\n   * encode the call from entryPoint through our account to the target contract.\n   * @param target - The target contract address\n   * @param value - The value to send to the target contract\n   * @param data - The calldata to send to the target contract\n   */\n\n  /**\n   * sign a userOp's hash (userOpHash).\n   * @param userOpHash - The hash to sign\n   */\n\n  /**\n   * calculate the account address even before it is deployed\n   */\n\n  /**\n   * check if the contract is already deployed.\n   */\n  async checkAccountPhantom() {\n    if (!this.isPhantom) {\n      // already deployed. no need to check anymore.\n      return this.isPhantom;\n    }\n    const senderAddressCode = await this.provider.getCode(this.getAccountAddress());\n    if (senderAddressCode.length > 2) {\n      this.isPhantom = false;\n    }\n    return this.isPhantom;\n  }\n  /**\n   * return initCode value to into the UserOp.\n   * (either deployment code, or empty hex if contract already deployed)\n   */\n  async getInitCode() {\n    if (await this.checkAccountPhantom()) {\n      return await this.getAccountInitCode();\n    }\n    return \"0x\";\n  }\n\n  /**\n   * return maximum gas used for verification.\n   * NOTE: createUnsignedUserOp will add to this value the cost of creation, if the contract is not yet created.\n   */\n  async getVerificationGasLimit() {\n    return 100000;\n  }\n\n  /**\n   * return userOpHash for signing.\n   * This value matches entryPoint.getUserOpHash (calculated off-chain, to avoid a view call)\n   * @param userOp - userOperation, (signature field ignored)\n   */\n  async getUserOpHash(userOp) {\n    const chainId = await this.provider.getNetwork().then(net => net.chainId);\n    return getUserOpHashV06(userOp, this.entryPointAddress, chainId);\n  }\n\n  /**\n   * return the account's address.\n   * this value is valid even before deploying the contract.\n   */\n  async getAccountAddress() {\n    if (!this.senderAddress) {\n      if (this.accountAddress) {\n        this.senderAddress = this.accountAddress;\n      } else {\n        this.senderAddress = await this.getCounterFactualAddress();\n      }\n    }\n    return this.senderAddress;\n  }\n  async estimateCreationGas(initCode) {\n    if (!initCode || initCode === \"0x\") {\n      return 0;\n    }\n    const deployerAddress = initCode.substring(0, 42);\n    const deployerCallData = \"0x\" + initCode.substring(42);\n    return await this.provider.estimateGas({\n      to: deployerAddress,\n      data: deployerCallData\n    });\n  }\n  async createUnsignedUserOp(httpRpcClient, info, options) {\n    let {\n      maxFeePerGas,\n      maxPriorityFeePerGas\n    } = info;\n    // get fees from bundler if available\n    if (isTwUrl(httpRpcClient.bundlerUrl)) {\n      const bundlerFeeData = await httpRpcClient.getUserOperationGasPrice();\n      maxFeePerGas = BigNumber.from(bundlerFeeData.maxFeePerGas);\n      maxPriorityFeePerGas = BigNumber.from(bundlerFeeData.maxPriorityFeePerGas);\n    } else {\n      // if bundler is not available, try to get fees from the network if not passed explicitly\n      if (!maxFeePerGas || !maxPriorityFeePerGas) {\n        const feeData = await getDynamicFeeData(this.provider);\n        if (!maxPriorityFeePerGas) {\n          maxPriorityFeePerGas = feeData.maxPriorityFeePerGas ?? undefined;\n        }\n        if (!maxFeePerGas) {\n          maxFeePerGas = feeData.maxFeePerGas ?? undefined;\n          const network = await this.provider.getNetwork();\n          const chainId = network.chainId;\n          if (chainId === Celo.chainId || chainId === CeloAlfajoresTestnet.chainId || chainId === CeloBaklavaTestnet.chainId) {\n            maxPriorityFeePerGas = maxFeePerGas;\n          }\n        }\n      }\n    }\n    if (!maxFeePerGas || !maxPriorityFeePerGas) {\n      throw new Error(\"maxFeePerGas or maxPriorityFeePerGas could not be calculated, please pass them explicitely\");\n    }\n    const [sender, nonce] = await Promise.all([this.getAccountAddress(), info.nonce ? Promise.resolve(info.nonce) : this.getNonce()]);\n    const initCode = await this.getInitCode();\n    const value = parseNumber(info.value) ?? BigNumber.from(0);\n    const callData = options?.batchData ? info.data : await this.prepareExecute(info.target, value, info.data).then(async tx => {\n      if (!info.gasLimit) {\n        // estimate gas on the inner transactions to simulate\n        // bundler would not revert otherwise\n        await this.provider.estimateGas({\n          from: sender,\n          to: info.target,\n          data: info.data,\n          value: value\n        });\n      }\n      return tx.encode();\n    });\n    const partialOp = {\n      sender,\n      nonce,\n      initCode,\n      callData,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      callGasLimit: BigNumber.from(1000000),\n      verificationGasLimit: BigNumber.from(1000000),\n      preVerificationGas: BigNumber.from(1000000),\n      paymasterAndData: \"0x\",\n      signature: DUMMY_SIGNATURE\n    };\n\n    // paymaster data + maybe used for estimation as well\n    const gasless = options?.gasless !== undefined ? options.gasless : this.gasless;\n    const useErc20Paymaster = this.erc20PaymasterAddress && this.erc20TokenAddress && (await this.isAccountApproved());\n    if (useErc20Paymaster) {\n      partialOp.paymasterAndData = this.erc20PaymasterAddress;\n      let estimates;\n      try {\n        estimates = await httpRpcClient.estimateUserOpGas(partialOp);\n      } catch (error) {\n        throw this.unwrapBundlerError(error);\n      }\n      partialOp.callGasLimit = estimates.callGasLimit;\n      partialOp.verificationGasLimit = estimates.verificationGasLimit;\n      partialOp.preVerificationGas = estimates.preVerificationGas;\n    } else if (gasless) {\n      const paymasterResult = await this.paymasterAPI.getPaymasterAndData(partialOp);\n      const paymasterAndData = paymasterResult.paymasterAndData;\n      if (paymasterAndData && paymasterAndData !== \"0x\") {\n        partialOp.paymasterAndData = paymasterAndData;\n      }\n      // paymaster can have the gas limits in the response\n      if (paymasterResult.callGasLimit && paymasterResult.verificationGasLimit && paymasterResult.preVerificationGas) {\n        partialOp.callGasLimit = BigNumber.from(paymasterResult.callGasLimit);\n        partialOp.verificationGasLimit = BigNumber.from(paymasterResult.verificationGasLimit);\n        partialOp.preVerificationGas = BigNumber.from(paymasterResult.preVerificationGas);\n      } else {\n        // otherwise fallback to bundler for gas limits\n        let estimates;\n        try {\n          estimates = await httpRpcClient.estimateUserOpGas(partialOp);\n        } catch (error) {\n          throw this.unwrapBundlerError(error);\n        }\n        partialOp.callGasLimit = estimates.callGasLimit;\n        partialOp.verificationGasLimit = estimates.verificationGasLimit;\n        partialOp.preVerificationGas = estimates.preVerificationGas;\n        // need paymaster to re-sign after estimates\n        if (paymasterAndData && paymasterAndData !== \"0x\") {\n          const paymasterResult2 = await this.paymasterAPI.getPaymasterAndData(partialOp);\n          if (paymasterResult2.paymasterAndData && paymasterResult2.paymasterAndData !== \"0x\") {\n            partialOp.paymasterAndData = paymasterResult2.paymasterAndData;\n          }\n        }\n      }\n    } else {\n      // query bundler for gas limits\n      let estimates;\n      try {\n        estimates = await httpRpcClient.estimateUserOpGas(partialOp);\n      } catch (error) {\n        throw this.unwrapBundlerError(error);\n      }\n      partialOp.callGasLimit = estimates.callGasLimit;\n      partialOp.verificationGasLimit = estimates.verificationGasLimit;\n      partialOp.preVerificationGas = estimates.preVerificationGas;\n    }\n    return {\n      ...partialOp,\n      signature: \"\"\n    };\n  }\n\n  /**\n   * Sign the filled userOp.\n   * @param userOp - The UserOperation to sign (with signature field ignored)\n   */\n  async signUserOp(userOp) {\n    const userOpHash = await this.getUserOpHash(userOp);\n    const signature = await this.signUserOpHash(userOpHash);\n    return {\n      ...userOp,\n      signature\n    };\n  }\n\n  /**\n   * get the transaction that has this userOpHash mined, or throws if not found\n   * @param userOpHash - returned by sendUserOpToBundler (or by getUserOpHash..)\n   * @param timeout - stop waiting after this timeout\n   * @param interval - time to wait between polls.\n   * @returns The transaction receipt, or an error if timed out.\n   */\n  async getUserOpReceipt(httpRpcClient, userOpHash) {\n    let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 120000;\n    let interval = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1000;\n    const endtime = Date.now() + timeout;\n    while (Date.now() < endtime) {\n      const userOpReceipt = await httpRpcClient.getUserOperationReceipt(userOpHash);\n      if (userOpReceipt) {\n        // avoid desync with current provider state\n        return await this.provider.waitForTransaction(userOpReceipt.receipt.transactionHash);\n      }\n      await new Promise(resolve => setTimeout(resolve, interval));\n    }\n    throw new Error(\"Timeout waiting for userOp to be mined\");\n  }\n  unwrapBundlerError(error) {\n    const message = error?.error?.message || error.error || error.message || error;\n    return new Error(message);\n  }\n}\nfunction parseNumber(a) {\n  if (!a || a === \"\") {\n    return null;\n  }\n  return BigNumber.from(a.toString());\n}\n\nclass AccountAPI extends BaseAccountAPI {\n  constructor(params, originalProvider) {\n    super({\n      ...params,\n      provider: originalProvider\n    });\n    this.params = params;\n    // Technically dont need the signer here, but we need to encode/estimate gas with it so a signer is required\n    // We don't want to use the localSigner directly since it might be connected to another chain\n    // so we just use the public hardhat pkey instead\n    this.sdk = ThirdwebSDK.fromPrivateKey(LOCAL_NODE_PKEY, params.chain, {\n      clientId: params.clientId,\n      secretKey: params.secretKey,\n      // @ts-expect-error expected chain type error\n      supportedChains: typeof params.chain === \"object\" ? [params.chain] : undefined\n    });\n  }\n  async getChainId() {\n    return await this.provider.getNetwork().then(n => n.chainId);\n  }\n  async getAccountContract() {\n    if (!this.accountContract) {\n      if (this.params.accountInfo?.abi) {\n        this.accountContract = await this.sdk.getContract(await this.getAccountAddress(), this.params.accountInfo.abi);\n      } else {\n        this.accountContract = await this.sdk.getContract(await this.getAccountAddress(), ACCOUNT_CORE_ABI);\n      }\n    }\n    return this.accountContract;\n  }\n  async getAccountInitCode() {\n    const factory = await this.getFactoryContract();\n    const localSigner = await this.params.localSigner.getAddress();\n    const tx = await this.params.factoryInfo.createAccount(factory, localSigner);\n    return utils.hexConcat([factory.getAddress(), tx.encode()]);\n  }\n  async getFactoryContract() {\n    if (this.factoryContract) {\n      return this.factoryContract;\n    }\n    if (this.params.factoryInfo?.abi) {\n      this.factoryContract = await this.sdk.getContract(this.params.factoryAddress, this.params.factoryInfo.abi);\n    } else {\n      this.factoryContract = await this.sdk.getContract(this.params.factoryAddress);\n    }\n    return this.factoryContract;\n  }\n  async getCounterFactualAddress() {\n    if (this.params.accountAddress) {\n      return this.params.accountAddress;\n    }\n    const factory = await this.getFactoryContract();\n    const localSigner = await this.params.localSigner.getAddress();\n    return this.params.factoryInfo.getAccountAddress(factory, localSigner);\n  }\n  async getNonce() {\n    if (await this.checkAccountPhantom()) {\n      return BigNumber.from(0);\n    }\n    const accountContract = await this.getAccountContract();\n    return this.params.accountInfo.getNonce(accountContract);\n  }\n  async prepareExecute(target, value, data) {\n    const accountContract = await this.getAccountContract();\n    return this.params.accountInfo.execute(accountContract, target, value, data);\n  }\n  async prepareExecuteBatch(targets, values, datas) {\n    const accountContract = await this.getAccountContract();\n    return accountContract.prepare(\"executeBatch\", [targets, values, datas]);\n  }\n  async signUserOpHash(userOpHash) {\n    return await this.params.localSigner.signMessage(utils.arrayify(userOpHash));\n  }\n  async isAcountDeployed() {\n    return !(await this.checkAccountPhantom());\n  }\n  async isAccountApproved() {\n    if (!this.params.erc20PaymasterAddress || !this.params.erc20TokenAddress) {\n      return true;\n    }\n    const swAddress = await this.getCounterFactualAddress();\n    const ERC20Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC20.json')).default;\n    const erc20Token = await this.sdk.getContract(this.params.erc20TokenAddress, ERC20Abi);\n    const allowance = await erc20Token.call(\"allowance\", [swAddress, this.params.erc20PaymasterAddress]);\n    return allowance.gte(BigNumber.from(2).pow(96).sub(1));\n  }\n  async createApproveTx() {\n    if (await this.isAccountApproved()) {\n      return undefined;\n    }\n    const amountToApprove = BigNumber.from(2).pow(96).sub(1);\n    const ethersSigner = new ethers.Wallet(LOCAL_NODE_PKEY, this.provider);\n    const erc20Contract = new Contract(this.params.erc20TokenAddress, [\"function approve(address spender, uint256 amount) public returns (bool)\"], ethersSigner);\n    const tx = {\n      to: this.params.erc20TokenAddress,\n      from: await this.getAccountAddress(),\n      value: 0,\n      data: erc20Contract.interface.encodeFunctionData(\"approve\", [this.params.erc20PaymasterAddress, amountToApprove])\n    };\n    return tx;\n  }\n}\n\nclass SmartWalletConnector extends Connector {\n  constructor(config) {\n    super();\n    this.config = config;\n  }\n  async initialize(params) {\n    const config = this.config;\n    const originalProvider = getChainProvider(config.chain, {\n      clientId: config.clientId,\n      secretKey: config.secretKey\n    });\n    this.chainId = (await originalProvider.getNetwork()).chainId;\n    const bundlerUrl = this.config.bundlerUrl || `https://${this.chainId}.bundler.thirdweb.com`;\n    const paymasterUrl = this.config.paymasterUrl || `https://${this.chainId}.bundler.thirdweb.com`;\n    const entryPointAddress = config.entryPointAddress || ENTRYPOINT_ADDRESS;\n    const localSigner = await params.personalWallet.getSigner();\n    const providerConfig = {\n      chain: config.chain,\n      localSigner,\n      entryPointAddress,\n      bundlerUrl,\n      paymasterAPI: this.config.paymasterAPI ? this.config.paymasterAPI : getVerifyingPaymaster(paymasterUrl, entryPointAddress, this.config.clientId, this.config.secretKey),\n      gasless: config.gasless,\n      factoryAddress: config.factoryAddress || DEFAULT_FACTORY_ADDRESS,\n      accountAddress: params.accountAddress,\n      factoryInfo: {\n        createAccount: config.factoryInfo?.createAccount || this.defaultFactoryInfo().createAccount,\n        getAccountAddress: config.factoryInfo?.getAccountAddress || this.defaultFactoryInfo().getAccountAddress,\n        abi: config.factoryInfo?.abi\n      },\n      accountInfo: {\n        execute: config.accountInfo?.execute || this.defaultAccountInfo().execute,\n        getNonce: config.accountInfo?.getNonce || this.defaultAccountInfo().getNonce,\n        abi: config.accountInfo?.abi\n      },\n      clientId: config.clientId,\n      secretKey: config.secretKey,\n      erc20PaymasterAddress: config.erc20PaymasterAddress,\n      erc20TokenAddress: config.erc20TokenAddress\n    };\n    this.personalWallet = params.personalWallet;\n    const accountApi = new AccountAPI(providerConfig, originalProvider);\n    this.aaProvider = create4337Provider(providerConfig, accountApi, originalProvider, this.chainId);\n    this.accountApi = accountApi;\n  }\n  async connect(connectionArgs) {\n    await this.initialize(connectionArgs);\n    return await this.getAddress();\n  }\n  getProvider() {\n    if (!this.aaProvider) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    return Promise.resolve(this.aaProvider);\n  }\n  async getSigner() {\n    if (!this.aaProvider) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    return Promise.resolve(this.aaProvider.getSigner());\n  }\n  async getAddress() {\n    const signer = await this.getSigner();\n    return signer.getAddress();\n  }\n  async isConnected() {\n    try {\n      const address = await this.getAddress();\n      return !!address;\n    } catch (e) {\n      return false;\n    }\n  }\n  async disconnect() {\n    this.personalWallet = undefined;\n    this.aaProvider = undefined;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  async switchChain(chainId) {\n    const provider = await this.getProvider();\n    const currentChainId = (await provider.getNetwork()).chainId;\n    if (currentChainId !== chainId) {\n      // only throw if actually trying to switch chains\n      throw new Error(\"Not supported.\");\n    }\n  }\n  setupListeners() {\n    return Promise.resolve();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  updateChains(chains) {}\n\n  /**\n   * Check whether the connected signer can execute a given transaction using the smart wallet.\n   * @param transaction - The transaction to execute using the smart wallet.\n   * @returns whether the connected signer can execute the transaction using the smart wallet.\n   */\n  async hasPermissionToExecute(transaction) {\n    const accountContract = await this.getAccountContract();\n    const signer = await this.getSigner();\n    const signerAddress = await signer.getAddress();\n    const restrictions = (await accountContract.account.getAllSigners()).filter(item => ethers.utils.getAddress(item.signer) === ethers.utils.getAddress(signerAddress))[0]?.permissions;\n    if (!restrictions) {\n      return false;\n    }\n    return restrictions.approvedCallTargets.includes(transaction.getTarget());\n  }\n\n  /// PREPARED TRANSACTIONS\n\n  /**\n   * Send a single transaction without waiting for confirmations\n   * @param transaction - the transaction to send\n   * @param config - optional the transaction configuration\n   * @returns The awaitable transaction\n   */\n  async send(transaction, options) {\n    const signer = await this.getSigner();\n    return signer.sendTransaction({\n      to: transaction.getTarget(),\n      data: transaction.encode(),\n      value: await transaction.getValue()\n    }, options);\n  }\n\n  /**\n   * Execute a single transaction (waiting for confirmations)\n   * @param transaction - The transaction to execute\n   * @returns The transaction receipt\n   */\n  async execute(transaction, options) {\n    const tx = await this.send(transaction, options);\n    const receipt = await tx.wait();\n    return {\n      receipt\n    };\n  }\n  async sendBatch(transactions, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const signer = await this.getSigner();\n    const {\n      tx,\n      batchData\n    } = await this.prepareBatchTx(transactions);\n    return await signer.sendTransaction({\n      to: await signer.getAddress(),\n      data: tx.encode(),\n      value: 0\n    }, {\n      ...options,\n      batchData\n    });\n  }\n\n  /**\n   * Execute multiple transactions in a single batch\n   * @param transactions - The transactions to execute\n   * @returns The transaction receipt\n   */\n  async executeBatch(transactions, options) {\n    const tx = await this.sendBatch(transactions, options);\n    const receipt = await tx.wait();\n    return {\n      receipt\n    };\n  }\n\n  /// RAW TRANSACTIONS\n\n  async sendRaw(transaction, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const signer = await this.getSigner();\n    return signer.sendTransaction(transaction, options);\n  }\n  async executeRaw(transaction, options) {\n    const tx = await this.sendRaw(transaction, options);\n    const receipt = await tx.wait();\n    return {\n      receipt\n    };\n  }\n  async sendBatchRaw(transactions, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const signer = await this.getSigner();\n    const batch = await this.prepareBatchRaw(transactions);\n    return signer.sendTransaction({\n      to: await signer.getAddress(),\n      data: batch.tx.encode(),\n      value: 0\n    }, {\n      ...options,\n      batchData: batch.batchData // batched tx flag\n    });\n  }\n  async executeBatchRaw(transactions, options) {\n    const tx = await this.sendBatchRaw(transactions, options);\n    const receipt = await tx.wait();\n    return {\n      receipt\n    };\n  }\n\n  /// ESTIMATION\n\n  async estimate(transaction, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    return this.estimateTx({\n      target: transaction.getTarget(),\n      data: transaction.encode(),\n      value: await transaction.getValue(),\n      gasLimit: await transaction.getOverrides().gasLimit,\n      maxFeePerGas: await transaction.getOverrides().maxFeePerGas,\n      maxPriorityFeePerGas: await transaction.getOverrides().maxPriorityFeePerGas,\n      nonce: await transaction.getOverrides().nonce\n    }, options);\n  }\n  async estimateRaw(transaction, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const tx = await ethers.utils.resolveProperties(transaction);\n    return this.estimateTx({\n      target: tx.to || constants.AddressZero,\n      data: tx.data?.toString() || \"\",\n      value: tx.value || BigNumber.from(0),\n      gasLimit: tx.gasLimit,\n      maxFeePerGas: tx.maxFeePerGas,\n      maxPriorityFeePerGas: tx.maxPriorityFeePerGas,\n      nonce: tx.nonce\n    }, options);\n  }\n  async estimateBatch(transactions, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const {\n      tx,\n      batchData\n    } = await this.prepareBatchTx(transactions);\n    return this.estimateTx({\n      target: tx.getTarget(),\n      data: tx.encode(),\n      value: await tx.getValue(),\n      gasLimit: await tx.getOverrides().gasLimit,\n      maxFeePerGas: await tx.getOverrides().maxFeePerGas,\n      maxPriorityFeePerGas: await tx.getOverrides().maxPriorityFeePerGas,\n      nonce: await tx.getOverrides().nonce\n    }, {\n      ...options,\n      batchData\n    });\n  }\n  async estimateBatchRaw(transactions, options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const {\n      tx,\n      batchData\n    } = await this.prepareBatchRaw(transactions);\n    return this.estimateTx({\n      target: tx.getTarget(),\n      data: tx.encode(),\n      value: await tx.getValue(),\n      gasLimit: await tx.getOverrides().gasLimit,\n      maxFeePerGas: await tx.getOverrides().maxFeePerGas,\n      maxPriorityFeePerGas: await tx.getOverrides().maxPriorityFeePerGas,\n      nonce: await tx.getOverrides().nonce\n    }, {\n      ...options,\n      batchData\n    });\n  }\n\n  //// DEPLOYMENT\n\n  /**\n   * Manually deploy the smart wallet contract. If already deployed this will throw an error.\n   * Note that this is not necessary as the smart wallet will be deployed automatically on the first transaction the user makes.\n   * @returns The transaction receipt\n   */\n  async deploy(options) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const signer = await this.getSigner();\n    const tx = await signer.sendTransaction({\n      to: await signer.getAddress(),\n      data: \"0x\"\n    }, {\n      ...options,\n      batchData: {\n        targets: [],\n        data: [],\n        values: []\n      } // batched tx flag to avoid hitting the Router fallback method\n    });\n    const receipt = await tx.wait();\n    return {\n      receipt\n    };\n  }\n\n  /**\n   * Check if the smart wallet contract is deployed\n   * @returns true if the smart wallet contract is deployed\n   */\n  async isDeployed() {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    return await this.accountApi.isAcountDeployed();\n  }\n  async deployIfNeeded(options) {\n    const isDeployed = await this.isDeployed();\n    if (!isDeployed) {\n      await this.deploy(options);\n    }\n  }\n\n  //// PERMISSIONS\n\n  async grantPermissions(target, permissions) {\n    const accountContract = await this.getAccountContract();\n    return accountContract.account.grantPermissions(target, permissions);\n  }\n  async revokePermissions(target) {\n    const accountContract = await this.getAccountContract();\n    return accountContract.account.revokeAccess(target);\n  }\n  async addAdmin(target) {\n    const accountContract = await this.getAccountContract();\n    return accountContract.account.grantAdminPermissions(target);\n  }\n  async removeAdmin(target) {\n    const accountContract = await this.getAccountContract();\n    return accountContract.account.revokeAdminPermissions(target);\n  }\n  async getAllActiveSigners() {\n    const isDeployed = await this.isDeployed();\n    if (isDeployed) {\n      const accountContract = await this.getAccountContract();\n      return accountContract.account.getAllAdminsAndSigners();\n    } else {\n      const personalWallet = await this.personalWallet?.getSigner();\n      if (!personalWallet) {\n        throw new Error(\"Personal wallet not connected\");\n      }\n      return [{\n        isAdmin: true,\n        signer: await personalWallet.getAddress(),\n        permissions: {\n          startDate: new Date(0),\n          expirationDate: new Date(0),\n          nativeTokenLimitPerTransaction: BigNumber.from(0),\n          approvedCallTargets: []\n        }\n      }];\n    }\n  }\n\n  /**\n   * Get the underlying account contract of the smart wallet.\n   * @returns The account contract of the smart wallet.\n   */\n  async getAccountContract() {\n    // getting a new instance everytime\n    // to avoid caching issues pre/post deployment\n    const sdk = ThirdwebSDK.fromSigner(await this.getSigner(), this.config.chain, {\n      clientId: this.config.clientId,\n      secretKey: this.config.secretKey\n    });\n    if (this.config.accountInfo?.abi) {\n      return sdk.getContract(await this.getAddress(), this.config.accountInfo.abi);\n    } else {\n      return sdk.getContract(await this.getAddress(), ACCOUNT_CORE_ABI);\n    }\n  }\n\n  /**\n   * Get the underlying account factory contract of the smart wallet.\n   * @returns The account factory contract.\n   */\n  async getFactoryContract() {\n    if (!this.config.factoryAddress) {\n      throw new Error(\"Factory address not set!\");\n    }\n    const sdk = ThirdwebSDK.fromSigner(await this.getSigner(), this.config.chain, {\n      clientId: this.config.clientId,\n      secretKey: this.config.secretKey\n    });\n    if (this.config.factoryInfo?.abi) {\n      return sdk.getContract(this.config.factoryAddress, this.config.factoryInfo.abi);\n    }\n    return sdk.getContract(this.config.factoryAddress);\n  }\n  defaultFactoryInfo() {\n    return {\n      createAccount: async (factory, owner) => {\n        return factory.prepare(\"createAccount\", [owner, ethers.utils.toUtf8Bytes(\"\")]);\n      },\n      getAccountAddress: async (factory, owner) => {\n        return await factory.call(\"getAddress\", [owner, ethers.utils.toUtf8Bytes(\"\")]);\n      }\n    };\n  }\n  defaultAccountInfo() {\n    return {\n      execute: async (account, target, value, data) => {\n        return account.prepare(\"execute\", [target, value, data]);\n      },\n      getNonce: async account => {\n        return account.call(\"getNonce\", []);\n      }\n    };\n  }\n\n  /// PRIVATE METHODS\n\n  async estimateTx(tx, options) {\n    if (!this.accountApi || !this.aaProvider) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    let deployGasLimit = BigNumber.from(0);\n    const [provider, isDeployed] = await Promise.all([this.getProvider(), this.isDeployed()]);\n    if (!isDeployed) {\n      deployGasLimit = await this.estimateDeploymentGasLimit();\n    }\n    const [userOp, gasPrice] = await Promise.all([this.accountApi.createUnsignedUserOp(this.aaProvider.httpRpcClient, tx, options), getGasPrice(provider)]);\n    const resolved = await utils.resolveProperties(userOp);\n    const transactionGasLimit = BigNumber.from(resolved.callGasLimit);\n    const transactionCost = transactionGasLimit.mul(gasPrice);\n    const deployCost = deployGasLimit.mul(gasPrice);\n    const totalCost = deployCost.add(transactionCost);\n    return {\n      ether: utils.formatEther(totalCost),\n      wei: totalCost,\n      details: {\n        deployGasLimit,\n        transactionGasLimit,\n        gasPrice,\n        transactionCost,\n        deployCost,\n        totalCost\n      }\n    };\n  }\n  async estimateDeploymentGasLimit() {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const initCode = await this.accountApi.getInitCode();\n    const [initGas, verificationGasLimit] = await Promise.all([this.accountApi.estimateCreationGas(initCode), this.accountApi.getVerificationGasLimit()]);\n    return BigNumber.from(verificationGasLimit).add(initGas);\n  }\n  async prepareBatchRaw(transactions) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const resolvedTxs = await Promise.all(transactions.map(transaction => ethers.utils.resolveProperties(transaction)));\n    const targets = resolvedTxs.map(tx => tx.to || constants.AddressZero);\n    const data = resolvedTxs.map(tx => tx.data || \"0x\");\n    const values = resolvedTxs.map(tx => tx.value || BigNumber.from(0));\n    return {\n      tx: await this.accountApi.prepareExecuteBatch(targets, values, data),\n      batchData: {\n        targets,\n        data,\n        values\n      }\n    };\n  }\n  async prepareBatchTx(transactions) {\n    if (!this.accountApi) {\n      throw new Error(\"Personal wallet not connected\");\n    }\n    const targets = transactions.map(tx => tx.getTarget());\n    const data = transactions.map(tx => tx.encode());\n    const values = await Promise.all(transactions.map(tx => tx.getValue()));\n    return {\n      tx: await this.accountApi.prepareExecuteBatch(targets, values, data),\n      batchData: {\n        targets,\n        data,\n        values\n      }\n    };\n  }\n}\n\nexport { SmartWalletConnector };\n"],"names":["async","hexlifyUserOp","op","userOp","utils","Object","keys","map","key","val","startsWith","reduce","set","_ref","k","v","getUserOpHashV06","entryPoint","chainId","hashedUserOp","sender","nonce","initCodeHash","initCode","callDataHash","callData","callGasLimit","verificationGasLimit","preVerificationGas","maxFeePerGas","maxPriorityFeePerGas","paymasterAndDataHash","paymasterAndData","encoded","encode","components","type","name","userOpHash","enc","randomNonce","hexString","generateRandomUint192","rand1","BigInt","Math","floor","random","rand2","rand3","rand4","rand5","rand6","toString","length","BigNumber","from","DEBUG","HttpRpcClient","constructor","bundlerUrl","entryPointAddress","clientId","secretKey","this","headers","isTwUrl","bundleId","globalThis","APP_BUNDLE_ID","undefined","TW_AUTH_TOKEN","concat","TW_CLI_AUTH_TOKEN","setAnalyticsHeaders","userOpJsonRpcProvider","providers","url","initializing","validateChainId","isZkSyncChain","chain","send","bundlerChain","parseInt","Error","sendUserOpToBundler","userOp1","hexifiedUserOp","jsonRequestData","printUserOperation","estimateUserOpGas","data","verificationGas","add","MANAGED_ACCOUNT_GAS_BUFFER","getUserOperationGasPrice","getUserOperationReceipt","zkPaymasterData","transactionInput","gas","gasLimit","zkBroadcastTransaction","method","PaymasterAPI","VerifyingPaymasterAPI","paymasterUrl","super","getPaymasterAndData","response","fetch","body","JSON","stringify","jsonrpc","id","params","res","json","ok","error","statusText","code","status","console","debug","result","_res$error","message","getVerifyingPaymaster","UserOperationEventListener","resolve","reject","timeout","_defineProperty","boundLisener","listenerCallback","bind","start","filter","filters","UserOperationEvent","setTimeout","queryFilter","once","stop","off","_len","arguments","param","Array","_key","event","args","_this$nonce","log","transactionReceipt","getTransactionReceipt","success","extractFailureReason","resolved","receipt","revertReasonEvents","UserOperationRevertReason","blockHash","revertReason","decode","substring","ERC4337EthersSigner","Signer","config","originalSigner","erc4337provider","httpRpcClient","smartAccountAPI","approving","sendTransaction","transaction","options","_tx$data","tx","createApproveTx","wait","ethers","verifyAllNecessaryFields","multidimensionalNonce","unsigned","createUnsignedUserOp","target","to","value","userOperation","signUserOp","transactionResponse","constructUserOpTransactionResponse","unwrapError","errorIn","errorMsg","_errorBody$error","_errorBody$error2","_failedOpMessage","errorBody","parse","errorStatus","errorCode","failedOpMessage","reason","includes","paymasterInfo","matched","match","split","stack","transactionRequest","connect","provider","getAddress","address","getSenderAccountAddress","signMessage","checkAccountPhantom","Promise","all","getChainId","originalMsgHash","factorySupports712","signature","rpcUrl","chainIdToThirdwebRpc","walletContract","Contract","getMessageHash","signTypedDataInternal","version","verifyingContract","AccountMessage","checkContractWalletSignature","signTransaction","_tx$data2","ERC4337EthersProvider","originalProvider","signer","getSigner","perform","getTransaction","transactionHash","getAccountAddress","waitForTransaction","confirmations","getUserOpHash","hash","getUserOpReceipt","detectNetwork","BaseAccountAPI","accountAddress","paymasterAPI","gasless","erc20PaymasterAddress","erc20TokenAddress","entryPointView","EntryPoint__factory","isPhantom","getCode","getInitCode","getAccountInitCode","getVerificationGasLimit","getNetwork","then","net","senderAddress","getCounterFactualAddress","estimateCreationGas","deployerAddress","deployerCallData","estimateGas","info","_parseNumber","bundlerFeeData","feeData","getDynamicFeeData","_feeData$maxPriorityF","_feeData$maxFeePerGas","Celo","CeloAlfajoresTestnet","CeloBaklavaTestnet","getNonce","a","parseNumber","batchData","prepareExecute","partialOp","isAccountApproved","estimates","unwrapBundlerError","paymasterResult","paymasterResult2","signUserOpHash","interval","endtime","Date","now","userOpReceipt","_error$error","AccountAPI","sdk","ThirdwebSDK","fromPrivateKey","LOCAL_NODE_PKEY","supportedChains","n","getAccountContract","_this$params$accountI","accountContract","accountInfo","abi","getContract","ACCOUNT_CORE_ABI","factory","getFactoryContract","localSigner","factoryInfo","createAccount","_this$params$factoryI","factoryContract","factoryAddress","execute","prepareExecuteBatch","targets","values","datas","prepare","isAcountDeployed","swAddress","ERC20Abi","default","erc20Token","call","gte","pow","sub","amountToApprove","ethersSigner","erc20Contract","interface","encodeFunctionData","SmartWalletConnector","Connector","initialize","_config$factoryInfo","_config$factoryInfo2","_config$factoryInfo3","_config$accountInfo","_config$accountInfo2","_config$accountInfo3","getChainProvider","ENTRYPOINT_ADDRESS","personalWallet","providerConfig","DEFAULT_FACTORY_ADDRESS","defaultFactoryInfo","defaultAccountInfo","accountApi","aaProvider","create4337Provider","connectionArgs","getProvider","isConnected","e","disconnect","switchChain","setupListeners","updateChains","chains","hasPermissionToExecute","_await$accountContrac","signerAddress","restrictions","account","getAllSigners","item","permissions","approvedCallTargets","getTarget","getValue","sendBatch","transactions","prepareBatchTx","executeBatch","sendRaw","executeRaw","sendBatchRaw","batch","prepareBatchRaw","executeBatchRaw","estimate","estimateTx","getOverrides","estimateRaw","_tx$data3","constants","estimateBatch","estimateBatchRaw","deploy","isDeployed","deployIfNeeded","grantPermissions","revokePermissions","revokeAccess","addAdmin","grantAdminPermissions","removeAdmin","revokeAdminPermissions","getAllActiveSigners","getAllAdminsAndSigners","_this$personalWallet","isAdmin","startDate","expirationDate","nativeTokenLimitPerTransaction","_this$config$accountI","fromSigner","_this$config$factoryI","owner","deployGasLimit","estimateDeploymentGasLimit","gasPrice","getGasPrice","transactionGasLimit","transactionCost","mul","deployCost","totalCost","ether","wei","details","initGas","resolvedTxs"],"sourceRoot":""}