{"version":3,"file":"static/js/53564.c4809052.chunk.js","mappings":"uKAgBO,MAAMA,EAAc,aACrBC,EAAY,CAChB,CACEC,KAAM,UACNC,KAAM,OAGJC,EAAa,CACjB,CACEF,KAAM,YA6FHG,eAAeC,EACpBC,GAEA,OAAOC,EAAAA,EAAAA,cAAa,CAClBC,SAAUF,EAAQE,SAClBC,OAAQ,CAACV,EAAaC,EAAWG,GACjCO,OAAQ,CAACJ,EAAQK,KAErB,CC9GO,MAAMZ,EAAc,aACrBC,EAAY,CAChB,CACEC,KAAM,UACNC,KAAM,YAGJC,EAAa,CACjB,CACEF,KAAM,WA2FHG,eAAeQ,EAAIN,GACxB,OAAOC,EAAAA,EAAAA,cAAa,CAClBC,SAAUF,EAAQE,SAClBC,OAAQ,CAACV,EAAaC,EAAWG,GACjCO,OAAQ,CAACJ,EAAQO,UAErB,CC/FOT,eAAeU,EACpBR,GAEA,MAAOS,EAAUC,SAAgBC,QAAQC,IAAI,CAC3CN,EAAI,CACFJ,SAAUF,EAAQE,SAClBK,QAASP,EAAQO,UAEnBR,EAAY,CACVG,SAAUF,EAAQE,SAClBG,GAAIL,EAAQO,UAEXM,OAAM,IAAM,OAEjB,OAAOC,EAAAA,EAAAA,SACCC,EAAAA,EAAAA,GAAmB,CACvBC,OAAQhB,EAAQE,SAASc,OACzBT,QAASP,EAAQO,QACjBE,aACCI,OAAM,KAAM,CACbR,GAAIL,EAAQO,QACZZ,KAAM,UACNW,IAAKG,MAEP,CACEF,QAASP,EAAQO,QACjBE,WACAd,KAAM,UACNsB,MAAO,KACPP,UAGN,C,gECtCOZ,eAAeiB,EACpBf,GAEA,MAAM,OAAEgB,EAAM,QAAET,EAAO,SAAEE,GAAaT,EAEtC,GAAiBS,ECVPS,WAAW,gCDWnB,IACE,OAAOC,KAAKC,MCIZ,SAA4BC,GAChC,MAAO,CAAEC,GAAUD,EAAME,MAAM,KAC/B,OAAOC,EAAAA,EAAAA,IAAeF,EACxB,CDPwBG,CAAkBhB,GACtC,CAAE,MAAOiB,GAMP,MALAC,QAAQC,MACN,qCACA,CAAErB,UAASE,YACXiB,GAEIA,CACR,CAIF,MAAM,SAAEG,SAAmB,wCAG3B,IACE,IAAKpB,EAASqB,SAAS,QACrB,mBAAoBD,EAAS,CAAEb,SAAQV,IAAKG,KAAasB,MAE7D,CAAE,MAAOL,GAEP,MADAC,QAAQC,MAAM,kCAAmC,CAAErB,UAASE,YAAYiB,GAClEA,CACR,CAGA,IACE,IAEE,mBACQG,EAAS,CACbb,SACAV,IAAKG,EAASuB,QACZ,QACAC,EAAAA,EAAAA,IAAY1B,EAAS,CAAE2B,KAAM,KAAMC,MAAM,OAG7CJ,MACJ,CAAE,MAAOK,GAEP,mBACQP,EAAS,CACbb,SACAV,IAAKG,EAASuB,QAAQ,OAAQzB,EAAQ8B,eAExCN,MACJ,CACF,CAAE,MAAOL,GAEP,MADAC,QAAQC,MAAM,8BAA+B,CAAErB,UAASE,YAAYiB,GAC9DA,CACR,CACF,C,kBEJM,SAAUZ,EAASwB,EAAmBtC,GAAwB,IAAAuC,EAAAC,EAClE,OAAQxC,EAAQL,MACd,IAAK,SACH,MAAO,CACL8C,SAAUH,EACVrB,MAAqB,QAAhBsB,EAAS,OAAPvC,QAAO,IAAPA,OAAO,EAAPA,EAASiB,aAAK,IAAAsB,EAAAA,EAAI,KACzBlC,GAAIL,EAAQO,QACZmC,SAAU1C,EAAQS,SAClBd,KAAMK,EAAQL,MAElB,IAAK,UACH,MAAO,CACL8C,SAAUH,EACVrB,MAAqB,QAAhBuB,EAAS,OAAPxC,QAAO,IAAPA,OAAO,EAAPA,EAASiB,aAAK,IAAAuB,EAAAA,EAAI,KACzBnC,GAAIL,EAAQO,QACZmC,SAAU1C,EAAQS,SAClBd,KAAMK,EAAQL,KACde,OAAQV,EAAQU,QAEpB,QACE,MAAM,IAAIiC,MAAM,oBAEtB,C,kCChGA,IAAIC,E,oCCEJ,MAAMC,EAAwB,sBAe9B,SAASC,EAAiBC,GACxB,IAAKC,EAAaD,GAChB,MAAM,IAAIE,UAAU,+BAADC,cAA0CH,EAAK,KAEtE,CAoBM,SAAUC,EAAaD,GAC3B,QAAKA,IAIDA,EAAMI,cAAgBC,YAInBC,OAAOC,UAAUjB,SAASkB,KAAKR,KAAWF,EACnD,CAqBM,SAAUW,EAAoBC,EAAeC,GAIjD,GAHAZ,EAAiBW,GACjBX,EAAiBY,GAEbD,IAAMC,EACR,OAAO,EAGT,GAAID,EAAEE,SAAWD,EAAEC,OACjB,OAAO,EAGT,IAAK,IAAIC,EAAQ,EAAGA,EAAQH,EAAEE,OAAQC,IACpC,GAAIH,EAAEG,KAAWF,EAAEE,GACjB,OAAO,EAIX,OAAO,CACT,CAgBM,SAAUC,EAAmBC,GAEjC,OADAhB,EAAiBgB,IDnGZlB,IACHA,EAAc,IAAImB,aAEbnB,GCiGoBoB,OAAOF,EACpC,CAEA,SAASG,EAAalB,GACpB,GAAqB,kBAAVA,EACT,MAAM,IAAIE,UAAU,2BAADC,cAAsCH,EAAK,KAElE,CAwCM,SAAUvB,EAAe0C,GAE7B,OADAD,EAAaC,GACNL,EAxBH,SAA6BK,GAEjC,OADAD,EAAaC,GACNd,WAAWe,KAChBC,WAAWC,KAAuBH,EAlBnBI,WAAW,IAAK,KAAKA,WAAW,IAAK,OAqBnDC,GAAMA,EAAEC,YAAY,IAEzB,CAgB4BC,CAAmBP,GAC/C,C","sources":["../node_modules/thirdweb/src/extensions/erc1155/__generated__/IERC1155/read/totalSupply.ts","../node_modules/thirdweb/src/extensions/erc1155/__generated__/IERC1155/read/uri.ts","../node_modules/thirdweb/src/extensions/erc1155/read/getNFT.ts","../node_modules/thirdweb/src/utils/nft/fetchTokenMetadata.ts","../node_modules/thirdweb/src/utils/base64/base64.ts","../node_modules/thirdweb/src/utils/nft/parseNft.ts","../node_modules/thirdweb/src/utils/text-decoder.ts","../node_modules/thirdweb/src/utils/uint8-array.ts"],"sourcesContent":["import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"totalSupply\" function.\n */\nexport type TotalSupplyParams = {\n  id: AbiParameterToPrimitiveType<{ type: \"uint256\"; name: \"id\" }>;\n};\n\nexport const FN_SELECTOR = \"0xbd85b039\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"uint256\",\n    name: \"id\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"uint256\",\n  },\n] as const;\n\n/**\n * Checks if the `totalSupply` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `totalSupply` method is supported.\n * @extension ERC1155\n * @example\n * ```ts\n * import { isTotalSupplySupported } from \"thirdweb/extensions/erc1155\";\n *\n * const supported = await isTotalSupplySupported(contract);\n * ```\n */\nexport async function isTotalSupplySupported(contract: ThirdwebContract<any>) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"totalSupply\" function.\n * @param options - The options for the totalSupply function.\n * @returns The encoded ABI parameters.\n * @extension ERC1155\n * @example\n * ```ts\n * import { encodeTotalSupplyParams } \"thirdweb/extensions/erc1155\";\n * const result = encodeTotalSupplyParams({\n *  id: ...,\n * });\n * ```\n */\nexport function encodeTotalSupplyParams(options: TotalSupplyParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.id]);\n}\n\n/**\n * Encodes the \"totalSupply\" function into a Hex string with its parameters.\n * @param options - The options for the totalSupply function.\n * @returns The encoded hexadecimal string.\n * @extension ERC1155\n * @example\n * ```ts\n * import { encodeTotalSupply } \"thirdweb/extensions/erc1155\";\n * const result = encodeTotalSupply({\n *  id: ...,\n * });\n * ```\n */\nexport function encodeTotalSupply(options: TotalSupplyParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeTotalSupplyParams(options).slice(\n      2,\n    )) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the totalSupply function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC1155\n * @example\n * ```ts\n * import { decodeTotalSupplyResult } from \"thirdweb/extensions/erc1155\";\n * const result = decodeTotalSupplyResult(\"...\");\n * ```\n */\nexport function decodeTotalSupplyResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"totalSupply\" function on the contract.\n * @param options - The options for the totalSupply function.\n * @returns The parsed result of the function call.\n * @extension ERC1155\n * @example\n * ```ts\n * import { totalSupply } from \"thirdweb/extensions/erc1155\";\n *\n * const result = await totalSupply({\n *  contract,\n *  id: ...,\n * });\n *\n * ```\n */\nexport async function totalSupply(\n  options: BaseTransactionOptions<TotalSupplyParams>,\n) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.id],\n  });\n}\n","import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"uri\" function.\n */\nexport type UriParams = {\n  tokenId: AbiParameterToPrimitiveType<{ type: \"uint256\"; name: \"tokenId\" }>;\n};\n\nexport const FN_SELECTOR = \"0x0e89341c\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"uint256\",\n    name: \"tokenId\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"string\",\n  },\n] as const;\n\n/**\n * Checks if the `uri` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `uri` method is supported.\n * @extension ERC1155\n * @example\n * ```ts\n * import { isUriSupported } from \"thirdweb/extensions/erc1155\";\n *\n * const supported = await isUriSupported(contract);\n * ```\n */\nexport async function isUriSupported(contract: ThirdwebContract<any>) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"uri\" function.\n * @param options - The options for the uri function.\n * @returns The encoded ABI parameters.\n * @extension ERC1155\n * @example\n * ```ts\n * import { encodeUriParams } \"thirdweb/extensions/erc1155\";\n * const result = encodeUriParams({\n *  tokenId: ...,\n * });\n * ```\n */\nexport function encodeUriParams(options: UriParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.tokenId]);\n}\n\n/**\n * Encodes the \"uri\" function into a Hex string with its parameters.\n * @param options - The options for the uri function.\n * @returns The encoded hexadecimal string.\n * @extension ERC1155\n * @example\n * ```ts\n * import { encodeUri } \"thirdweb/extensions/erc1155\";\n * const result = encodeUri({\n *  tokenId: ...,\n * });\n * ```\n */\nexport function encodeUri(options: UriParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeUriParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the uri function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC1155\n * @example\n * ```ts\n * import { decodeUriResult } from \"thirdweb/extensions/erc1155\";\n * const result = decodeUriResult(\"...\");\n * ```\n */\nexport function decodeUriResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"uri\" function on the contract.\n * @param options - The options for the uri function.\n * @returns The parsed result of the function call.\n * @extension ERC1155\n * @example\n * ```ts\n * import { uri } from \"thirdweb/extensions/erc1155\";\n *\n * const result = await uri({\n *  contract,\n *  tokenId: ...,\n * });\n *\n * ```\n */\nexport async function uri(options: BaseTransactionOptions<UriParams>) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.tokenId],\n  });\n}\n","import type { BaseTransactionOptions } from \"../../../transaction/types.js\";\nimport { fetchTokenMetadata } from \"../../../utils/nft/fetchTokenMetadata.js\";\nimport { type NFT, parseNFT } from \"../../../utils/nft/parseNft.js\";\nimport { totalSupply } from \"../__generated__/IERC1155/read/totalSupply.js\";\nimport { uri } from \"../__generated__/IERC1155/read/uri.js\";\n\n/**\n * Parameters for getting an NFT.\n */\nexport type GetNFTParams = {\n  tokenId: bigint;\n};\n\n/**\n * Retrieves information about a specific ERC1155 non-fungible token (NFT).\n * @param options - The options for retrieving the NFT.\n * @returns A promise that resolves to the NFT object.\n * @extension ERC1155\n * @example\n * ```ts\n * import { getNFT } from \"thirdweb/extensions/erc1155\";\n * const nft = await getNFT({\n *  contract,\n *  tokenId: 1n,\n * });\n * ```\n */\nexport async function getNFT(\n  options: BaseTransactionOptions<GetNFTParams>,\n): Promise<NFT> {\n  const [tokenUri, supply] = await Promise.all([\n    uri({\n      contract: options.contract,\n      tokenId: options.tokenId,\n    }),\n    totalSupply({\n      contract: options.contract,\n      id: options.tokenId,\n      // in cases where the supply is not available -> fall back to 0\n    }).catch(() => 0n),\n  ]);\n  return parseNFT(\n    await fetchTokenMetadata({\n      client: options.contract.client,\n      tokenId: options.tokenId,\n      tokenUri,\n    }).catch(() => ({\n      id: options.tokenId,\n      type: \"ERC1155\",\n      uri: tokenUri,\n    })),\n    {\n      tokenId: options.tokenId,\n      tokenUri,\n      type: \"ERC1155\",\n      owner: null,\n      supply,\n    },\n  );\n}\n","import type { ThirdwebClient } from \"../../client/client.js\";\nimport { isBase64JSON, parseBase64String } from \"../base64/base64.js\";\nimport { numberToHex } from \"../encoding/hex.js\";\nimport type { NFTMetadata } from \"./parseNft.js\";\n\n/**\n * @internal\n */\nexport type FetchTokenMetadataOptions = {\n  client: ThirdwebClient;\n  tokenId: bigint;\n  tokenUri: string;\n};\n\n/**\n * Fetches the metadata for a token.\n *\n * @param options - The options for fetching the token metadata.\n * @returns The token metadata.\n * @internal\n */\nexport async function fetchTokenMetadata(\n  options: FetchTokenMetadataOptions,\n): Promise<NFTMetadata> {\n  const { client, tokenId, tokenUri } = options;\n  // handle case where the URI is a base64 encoded JSON (onchain nft)\n  if (isBase64JSON(tokenUri)) {\n    try {\n      return JSON.parse(parseBase64String(tokenUri));\n    } catch (e) {\n      console.error(\n        \"Failed to fetch base64 encoded NFT\",\n        { tokenId, tokenUri },\n        e,\n      );\n      throw e;\n    }\n  }\n\n  // in all other cases we will need the `download` function from storage\n  const { download } = await import(\"../../storage/download.js\");\n\n  // handle non-dynamic uris (most common case -> skip the other checks)\n  try {\n    if (!tokenUri.includes(\"{id}\")) {\n      return await (await download({ client, uri: tokenUri })).json();\n    }\n  } catch (e) {\n    console.error(\"Failed to fetch non-dynamic NFT\", { tokenId, tokenUri }, e);\n    throw e;\n  }\n\n  // DYNAMIC NFT FORMATS (2 options, sadly has to be waterfall)\n  try {\n    try {\n      // try first dynamic id format\n      return await (\n        await download({\n          client,\n          uri: tokenUri.replace(\n            \"{id}\",\n            numberToHex(tokenId, { size: 32 }).slice(2),\n          ),\n        })\n      ).json();\n    } catch (err) {\n      // otherwise attempt the second format\n      return await (\n        await download({\n          client,\n          uri: tokenUri.replace(\"{id}\", tokenId.toString()),\n        })\n      ).json();\n    }\n  } catch (e) {\n    console.error(\"Failed to fetch dynamic NFT\", { tokenId, tokenUri }, e);\n    throw e;\n  }\n}\n","import { base64ToString } from \"../uint8-array.js\";\n\ntype Base64Prefix = \"data:application/json;base64\";\ntype Base64String = `${Base64Prefix},${string}`;\n\n/**\n * Checks if a given string is a base64 encoded JSON string.\n * @param input - The string to be checked.\n * @returns True if the input string starts with \"data:application/json;base64\", false otherwise.\n * @example\n * ```ts\n * isBase64JSON(\"data:application/json;base64,eyJ0ZXN0IjoiYmFzZTY0In0=\")\n * // true\n * ```\n */\nexport function isBase64JSON(input: string): input is Base64String {\n  if (input.startsWith(\"data:application/json;base64\")) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Parses a base64 string and returns the decoded string.\n * @param input - The base64 string to parse.\n * @returns The decoded string.\n * @example\n * ```ts\n * parseBase64String(\"data:application/json;base64,eyJ0ZXN0IjoiYmFzZTY0In0=\")\n * // '{\"test\":\"base64\"}'\n * ```\n */\nexport function parseBase64String(input: Base64String) {\n  const [, base64] = input.split(\",\") as [Base64Prefix, string];\n  return base64ToString(base64);\n}\n","import type { FileOrBufferOrString } from \"../../storage/upload/types.js\";\nimport type { Prettify } from \"../type-utils.js\";\n\n/**\n * Represents the input data for creating an NFT (Non-Fungible Token).\n */\nexport type NFTInput = Prettify<\n  {\n    name?: string;\n    description?: string;\n    image?: FileOrBufferOrString;\n    animation_url?: FileOrBufferOrString;\n    external_url?: FileOrBufferOrString;\n    background_color?: string;\n    // TODO check if we truly need both of these?\n    properties?: Record<string, unknown> | Array<Record<string, unknown>>;\n  } & Record<string, unknown>\n>;\n\nexport type NFTMetadata = {\n  id: bigint;\n  uri: string;\n  name?: string;\n  description?: string;\n  image?: string;\n  animation_url?: string;\n  external_url?: string;\n  background_color?: string;\n  properties?: Record<string, unknown>;\n  attributes?: Record<string, unknown>;\n} & Record<string, unknown>;\n\nexport type NFT =\n  | {\n      metadata: NFTMetadata;\n      owner: string | null;\n      id: bigint;\n      tokenURI: string;\n      type: \"ERC721\";\n    }\n  | {\n      metadata: NFTMetadata;\n      owner: string | null;\n      id: bigint;\n      tokenURI: string;\n      type: \"ERC1155\";\n      supply: bigint;\n    };\n\n/**\n * @internal\n */\nexport type ParseNFTOptions =\n  | {\n      tokenId: bigint;\n      tokenUri: string;\n      type: \"ERC721\";\n      owner?: string | null;\n    }\n  | {\n      tokenId: bigint;\n      tokenUri: string;\n      type: \"ERC1155\";\n      owner?: string | null;\n      supply: bigint;\n    };\n\n/**\n * Parses the NFT metadata and options to create an NFT object.\n * @param base - The base NFT metadata.\n * @param options - The options for parsing the NFT.\n * @returns The parsed NFT object.\n * @internal\n */\nexport function parseNFT(base: NFTMetadata, options: ParseNFTOptions): NFT {\n  switch (options.type) {\n    case \"ERC721\":\n      return {\n        metadata: base,\n        owner: options?.owner ?? null,\n        id: options.tokenId,\n        tokenURI: options.tokenUri,\n        type: options.type,\n      };\n    case \"ERC1155\":\n      return {\n        metadata: base,\n        owner: options?.owner ?? null,\n        id: options.tokenId,\n        tokenURI: options.tokenUri,\n        type: options.type,\n        supply: options.supply,\n      };\n    default:\n      throw new Error(\"Invalid NFT type\");\n  }\n}\n","let textDecoder: TextDecoder;\n\n/**\n * Re-using the same textdecoder is faster.\n *\n * @returns\n * @internal\n */\nexport function cachedTextDecoder(): TextDecoder {\n  if (!textDecoder) {\n    textDecoder = new TextDecoder();\n  }\n  return textDecoder;\n}\n","import { cachedTextDecoder } from \"./text-decoder.js\";\n\nconst uint8ArrayStringified = \"[object Uint8Array]\";\n\n/**\n * Throw a `TypeError` if the given value is not an instance of `Uint8Array`.\n * @example\n * ```ts\n * import {assertUint8Array} from 'uint8array-extras';\n *\n * try {\n * assertUint8Array(new ArrayBuffer(10)); // Throws a TypeError\n * } catch (error) {\n * console.error(error.message);\n * }\n * ```\n */\nfunction assertUint8Array(value: unknown): asserts value is Uint8Array {\n  if (!isUint8Array(value)) {\n    throw new TypeError(`Expected \\`Uint8Array\\`, got \\`${typeof value}\\``);\n  }\n}\n\n/**\n * Check if the given value is an instance of `Uint8Array`.\n *\n * Replacement for [`Buffer.isBuffer()`](https://nodejs.org/api/buffer.html#static-method-bufferisbufferobj).\n * @example\n * ```ts\n * import {isUint8Array} from 'uint8array-extras';\n *\n * console.log(isUint8Array(new Uint8Array()));\n * //=> true\n *\n * console.log(isUint8Array(Buffer.from('x')));\n * //=> true\n *\n * console.log(isUint8Array(new ArrayBuffer(10)));\n * //=> false\n * ```\n */\nexport function isUint8Array(value: unknown): value is Uint8Array {\n  if (!value) {\n    return false;\n  }\n\n  if (value.constructor === Uint8Array) {\n    return true;\n  }\n\n  return Object.prototype.toString.call(value) === uint8ArrayStringified;\n}\n\n/**\n * Check if two arrays are identical by verifying that they contain the same bytes in the same sequence.\n *\n * Replacement for [`Buffer#equals()`](https://nodejs.org/api/buffer.html#bufequalsotherbuffer).\n * @example\n * ```ts\n * import {areUint8ArraysEqual} from 'uint8array-extras';\n *\n * const a = new Uint8Array([1, 2, 3]);\n * const b = new Uint8Array([1, 2, 3]);\n * const c = new Uint8Array([4, 5, 6]);\n *\n * console.log(areUint8ArraysEqual(a, b));\n * //=> true\n *\n * console.log(areUint8ArraysEqual(a, c));\n * //=> false\n * ```\n */\nexport function areUint8ArraysEqual(a: Uint8Array, b: Uint8Array): boolean {\n  assertUint8Array(a);\n  assertUint8Array(b);\n\n  if (a === b) {\n    return true;\n  }\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let index = 0; index < a.length; index++) {\n    if (a[index] !== b[index]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Convert a `Uint8Array` (containing a UTF-8 string) to a string.\n *\n * Replacement for [`Buffer#toString()`](https://nodejs.org/api/buffer.html#buftostringencoding-start-end).\n * @example\n * ```ts\n * import {uint8ArrayToString} from 'uint8array-extras';\n *\n * const byteArray = new Uint8Array([72, 101, 108, 108, 111]);\n *\n * console.log(uint8ArrayToString(byteArray));\n * //=> 'Hello'\n * ```\n */\nexport function uint8ArrayToString(array: Uint8Array): string {\n  assertUint8Array(array);\n  return cachedTextDecoder().decode(array);\n}\n\nfunction assertString(value: unknown): asserts value is string {\n  if (typeof value !== \"string\") {\n    throw new TypeError(`Expected \\`string\\`, got \\`${typeof value}\\``);\n  }\n}\n\nfunction base64UrlToBase64(base64url: string) {\n  return base64url.replaceAll(\"-\", \"+\").replaceAll(\"_\", \"/\");\n}\n\n/**\n * Convert a Base64-encoded or [Base64URL](https://base64.guru/standards/base64url)-encoded string to a `Uint8Array`.\n *\n * Replacement for [`Buffer.from('SGVsbG8=', 'base64')`](https://nodejs.org/api/buffer.html#static-method-bufferfromstring-encoding).\n * @example\n * ```ts\n * import {base64ToUint8Array} from 'uint8array-extras';\n *\n * console.log(base64ToUint8Array('SGVsbG8='));\n * //=> Uint8Array [72, 101, 108, 108, 111]\n * ```\n */\nexport function base64ToUint8Array(base64String: string): Uint8Array {\n  assertString(base64String);\n  return Uint8Array.from(\n    globalThis.atob(base64UrlToBase64(base64String)),\n\n    // biome-ignore lint/style/noNonNullAssertion: we know that the code points exist\n    (x) => x.codePointAt(0)!,\n  );\n}\n\n/**\n * Decode a Base64-encoded or [Base64URL](https://base64.guru/standards/base64url)-encoded string to a string.\n *\n * Replacement for `Buffer.from('SGVsbG8=', 'base64').toString()` and [`atob()`](https://developer.mozilla.org/en-US/docs/Web/API/atob).\n * @example\n * ```ts\n * import {base64ToString} from 'uint8array-extras';\n *\n * console.log(base64ToString('SGVsbG8='));\n * //=> 'Hello'\n * ```\n */\nexport function base64ToString(base64String: string): string {\n  assertString(base64String);\n  return uint8ArrayToString(base64ToUint8Array(base64String));\n}\n\nfunction base64ToBase64Url(base64: string): string {\n  return base64.replaceAll(\"+\", \"-\").replaceAll(\"/\", \"_\").replace(/=+$/, \"\");\n}\n// Reference: https://phuoc.ng/collection/this-vs-that/concat-vs-push/\nconst MAX_BLOCK_SIZE = 65_535;\n\nexport function uint8ArrayToBase64(\n  array: Uint8Array,\n  { urlSafe = false } = {},\n): string {\n  assertUint8Array(array);\n\n  let base64: string;\n\n  if (array.length < MAX_BLOCK_SIZE) {\n    // Required as `btoa` and `atob` don't properly support Unicode: https://developer.mozilla.org/en-US/docs/Glossary/Base64#the_unicode_problem\n    // @ts-expect-error - TS doesn't know about `String#fromCodePoint`\n    base64 = globalThis.btoa(String.fromCodePoint.apply(this, array));\n  } else {\n    base64 = \"\";\n    for (const value of array) {\n      base64 += String.fromCodePoint(value);\n    }\n\n    base64 = globalThis.btoa(base64);\n  }\n\n  return urlSafe ? base64ToBase64Url(base64) : base64;\n}\n\nexport function concatUint8Arrays(\n  arrays: Uint8Array[],\n  totalLength?: number,\n): Uint8Array {\n  if (arrays.length === 0) {\n    return new Uint8Array(0);\n  }\n\n  const calculatedTotalLength =\n    totalLength ??\n    arrays.reduce(\n      (accumulator, currentValue) => accumulator + currentValue.length,\n      0,\n    );\n\n  const returnValue = new Uint8Array(calculatedTotalLength);\n\n  let offset = 0;\n  for (const array of arrays) {\n    assertUint8Array(array);\n    returnValue.set(array, offset);\n    offset += array.length;\n  }\n\n  return returnValue;\n}\n\nexport function compareUint8Arrays(a: Uint8Array, b: Uint8Array): number {\n  assertUint8Array(a);\n  assertUint8Array(b);\n\n  const length = Math.min(a.length, b.length);\n\n  for (let index = 0; index < length; index++) {\n    // biome-ignore lint/style/noNonNullAssertion: we check the length above so the index is always in bounds\n    const diff = a[index]! - b[index]!;\n    if (diff !== 0) {\n      return Math.sign(diff);\n    }\n  }\n\n  // At this point, all the compared elements are equal.\n  // The shorter array should come first if the arrays are of different lengths.\n  return Math.sign(a.length - b.length);\n}\n"],"names":["FN_SELECTOR","FN_INPUTS","type","name","FN_OUTPUTS","async","totalSupply","options","readContract","contract","method","params","id","uri","tokenId","getNFT","tokenUri","supply","Promise","all","catch","parseNFT","fetchTokenMetadata","client","owner","startsWith","JSON","parse","input","base64","split","base64ToString","parseBase64String","e","console","error","download","includes","json","replace","numberToHex","size","slice","err","toString","base","_options$owner","_options$owner2","metadata","tokenURI","Error","textDecoder","uint8ArrayStringified","assertUint8Array","value","isUint8Array","TypeError","concat","constructor","Uint8Array","Object","prototype","call","areUint8ArraysEqual","a","b","length","index","uint8ArrayToString","array","TextDecoder","decode","assertString","base64String","from","globalThis","atob","replaceAll","x","codePointAt","base64ToUint8Array"],"sourceRoot":""}