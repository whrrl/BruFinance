{"version":3,"file":"static/js/88992.557ac03c.chunk.js","mappings":"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","sources":["../node_modules/thirdweb/node_modules/viem/constants/unit.ts","../node_modules/thirdweb/node_modules/viem/utils/unit/formatUnits.ts","../node_modules/thirdweb/node_modules/viem/utils/unit/formatGwei.ts","../node_modules/thirdweb/node_modules/viem/errors/transaction.ts","../node_modules/thirdweb/node_modules/viem/utils/blob/blobsToCommitments.ts","../node_modules/thirdweb/node_modules/viem/utils/blob/blobsToProofs.ts","../node_modules/thirdweb/node_modules/viem/node_modules/@noble/hashes/src/_sha2.ts","../node_modules/thirdweb/node_modules/viem/node_modules/@noble/hashes/src/sha256.ts","../node_modules/thirdweb/node_modules/viem/utils/blob/commitmentToVersionedHash.ts","../node_modules/thirdweb/node_modules/viem/utils/hash/sha256.ts","../node_modules/thirdweb/node_modules/viem/constants/blob.ts","../node_modules/thirdweb/node_modules/viem/constants/kzg.ts","../node_modules/thirdweb/node_modules/viem/errors/blob.ts","../node_modules/thirdweb/node_modules/viem/utils/blob/toBlobSidecars.ts","../node_modules/thirdweb/node_modules/viem/utils/blob/toBlobs.ts","../node_modules/thirdweb/node_modules/viem/errors/chain.ts","../node_modules/thirdweb/node_modules/viem/errors/node.ts","../node_modules/thirdweb/node_modules/viem/utils/transaction/assertTransaction.ts","../node_modules/thirdweb/node_modules/viem/utils/transaction/serializeAccessList.ts","../node_modules/thirdweb/node_modules/viem/utils/transaction/serializeTransaction.ts","../node_modules/thirdweb/node_modules/viem/utils/transaction/getTransactionType.ts","../node_modules/thirdweb/node_modules/viem/utils/blob/commitmentsToVersionedHashes.ts","../node_modules/thirdweb/src/gas/estimate-l1-fee.ts","../node_modules/thirdweb/node_modules/viem/utils/encoding/toRlp.ts"],"sourcesContent":["export const etherUnits = {\n  gwei: 9,\n  wei: 18,\n}\nexport const gweiUnits = {\n  ether: -9,\n  wei: 9,\n}\nexport const weiUnits = {\n  ether: -18,\n  gwei: -9,\n}\n","import type { ErrorType } from '../../errors/utils.js'\n\nexport type FormatUnitsErrorType = ErrorType\n\n/**\n *  Divides a number by a given exponent of base 10 (10exponent), and formats it into a string representation of the number..\n *\n * - Docs: https://viem.sh/docs/utilities/formatUnits\n *\n * @example\n * import { formatUnits } from 'viem'\n *\n * formatUnits(420000000000n, 9)\n * // '420'\n */\nexport function formatUnits(value: bigint, decimals: number) {\n  let display = value.toString()\n\n  const negative = display.startsWith('-')\n  if (negative) display = display.slice(1)\n\n  display = display.padStart(decimals, '0')\n\n  let [integer, fraction] = [\n    display.slice(0, display.length - decimals),\n    display.slice(display.length - decimals),\n  ]\n  fraction = fraction.replace(/(0+)$/, '')\n  return `${negative ? '-' : ''}${integer || '0'}${\n    fraction ? `.${fraction}` : ''\n  }`\n}\n","import { gweiUnits } from '../../constants/unit.js'\n\nimport { type FormatUnitsErrorType, formatUnits } from './formatUnits.js'\n\nexport type FormatGweiErrorType = FormatUnitsErrorType\n\n/**\n * Converts numerical wei to a string representation of gwei.\n *\n * - Docs: https://viem.sh/docs/utilities/formatGwei\n *\n * @example\n * import { formatGwei } from 'viem'\n *\n * formatGwei(1000000000n)\n * // '1'\n */\nexport function formatGwei(wei: bigint, unit: 'wei' = 'wei') {\n  return formatUnits(wei, gweiUnits[unit])\n}\n","import type { Account } from '../accounts/types.js'\nimport type { SendTransactionParameters } from '../actions/wallet/sendTransaction.js'\nimport type { BlockTag } from '../types/block.js'\nimport type { Chain } from '../types/chain.js'\nimport type { Hash, Hex } from '../types/misc.js'\nimport type { TransactionType } from '../types/transaction.js'\nimport { formatEther } from '../utils/unit/formatEther.js'\nimport { formatGwei } from '../utils/unit/formatGwei.js'\n\nimport { BaseError } from './base.js'\n\nexport function prettyPrint(\n  args: Record<string, bigint | number | string | undefined | false | unknown>,\n) {\n  const entries = Object.entries(args)\n    .map(([key, value]) => {\n      if (value === undefined || value === false) return null\n      return [key, value]\n    })\n    .filter(Boolean) as [string, string][]\n  const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0)\n  return entries\n    .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)\n    .join('\\n')\n}\n\nexport type FeeConflictErrorType = FeeConflictError & {\n  name: 'FeeConflictError'\n}\nexport class FeeConflictError extends BaseError {\n  override name = 'FeeConflictError'\n  constructor() {\n    super(\n      [\n        'Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.',\n        'Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others.',\n      ].join('\\n'),\n    )\n  }\n}\n\nexport type InvalidLegacyVErrorType = InvalidLegacyVError & {\n  name: 'InvalidLegacyVError'\n}\nexport class InvalidLegacyVError extends BaseError {\n  override name = 'InvalidLegacyVError'\n\n  constructor({ v }: { v: bigint }) {\n    super(`Invalid \\`v\\` value \"${v}\". Expected 27 or 28.`)\n  }\n}\n\nexport type InvalidSerializableTransactionErrorType =\n  InvalidSerializableTransactionError & {\n    name: 'InvalidSerializableTransactionError'\n  }\nexport class InvalidSerializableTransactionError extends BaseError {\n  override name = 'InvalidSerializableTransactionError'\n\n  constructor({ transaction }: { transaction: Record<string, unknown> }) {\n    super('Cannot infer a transaction type from provided transaction.', {\n      metaMessages: [\n        'Provided Transaction:',\n        '{',\n        prettyPrint(transaction),\n        '}',\n        '',\n        'To infer the type, either provide:',\n        '- a `type` to the Transaction, or',\n        '- an EIP-1559 Transaction with `maxFeePerGas`, or',\n        '- an EIP-2930 Transaction with `gasPrice` & `accessList`, or',\n        '- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or',\n        '- a Legacy Transaction with `gasPrice`',\n      ],\n    })\n  }\n}\n\nexport type InvalidSerializedTransactionTypeErrorType =\n  InvalidSerializedTransactionTypeError & {\n    name: 'InvalidSerializedTransactionTypeError'\n  }\nexport class InvalidSerializedTransactionTypeError extends BaseError {\n  override name = 'InvalidSerializedTransactionType'\n\n  serializedType: Hex\n\n  constructor({ serializedType }: { serializedType: Hex }) {\n    super(`Serialized transaction type \"${serializedType}\" is invalid.`)\n\n    this.serializedType = serializedType\n  }\n}\n\nexport type InvalidSerializedTransactionErrorType =\n  InvalidSerializedTransactionError & {\n    name: 'InvalidSerializedTransactionError'\n  }\nexport class InvalidSerializedTransactionError extends BaseError {\n  override name = 'InvalidSerializedTransactionError'\n\n  serializedTransaction: Hex\n  type: TransactionType\n\n  constructor({\n    attributes,\n    serializedTransaction,\n    type,\n  }: {\n    attributes: Record<string, unknown>\n    serializedTransaction: Hex\n    type: TransactionType\n  }) {\n    const missing = Object.entries(attributes)\n      .map(([key, value]) => (typeof value === 'undefined' ? key : undefined))\n      .filter(Boolean)\n    super(`Invalid serialized transaction of type \"${type}\" was provided.`, {\n      metaMessages: [\n        `Serialized Transaction: \"${serializedTransaction}\"`,\n        missing.length > 0 ? `Missing Attributes: ${missing.join(', ')}` : '',\n      ].filter(Boolean),\n    })\n\n    this.serializedTransaction = serializedTransaction\n    this.type = type\n  }\n}\n\nexport type InvalidStorageKeySizeErrorType = InvalidStorageKeySizeError & {\n  name: 'InvalidStorageKeySizeError'\n}\nexport class InvalidStorageKeySizeError extends BaseError {\n  override name = 'InvalidStorageKeySizeError'\n\n  constructor({ storageKey }: { storageKey: Hex }) {\n    super(\n      `Size for storage key \"${storageKey}\" is invalid. Expected 32 bytes. Got ${Math.floor(\n        (storageKey.length - 2) / 2,\n      )} bytes.`,\n    )\n  }\n}\n\nexport type TransactionExecutionErrorType = TransactionExecutionError & {\n  name: 'TransactionExecutionError'\n}\nexport class TransactionExecutionError extends BaseError {\n  override cause: BaseError\n\n  override name = 'TransactionExecutionError'\n\n  constructor(\n    cause: BaseError,\n    {\n      account,\n      docsPath,\n      chain,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to,\n      value,\n    }: Omit<SendTransactionParameters, 'account' | 'chain'> & {\n      account: Account\n      chain?: Chain | undefined\n      docsPath?: string | undefined\n    },\n  ) {\n    const prettyArgs = prettyPrint({\n      chain: chain && `${chain?.name} (id: ${chain?.id})`,\n      from: account?.address,\n      to,\n      value:\n        typeof value !== 'undefined' &&\n        `${formatEther(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,\n      data,\n      gas,\n      gasPrice:\n        typeof gasPrice !== 'undefined' && `${formatGwei(gasPrice)} gwei`,\n      maxFeePerGas:\n        typeof maxFeePerGas !== 'undefined' &&\n        `${formatGwei(maxFeePerGas)} gwei`,\n      maxPriorityFeePerGas:\n        typeof maxPriorityFeePerGas !== 'undefined' &&\n        `${formatGwei(maxPriorityFeePerGas)} gwei`,\n      nonce,\n    })\n\n    super(cause.shortMessage, {\n      cause,\n      docsPath,\n      metaMessages: [\n        ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),\n        'Request Arguments:',\n        prettyArgs,\n      ].filter(Boolean) as string[],\n    })\n    this.cause = cause\n  }\n}\n\nexport type TransactionNotFoundErrorType = TransactionNotFoundError & {\n  name: 'TransactionNotFoundError'\n}\nexport class TransactionNotFoundError extends BaseError {\n  override name = 'TransactionNotFoundError'\n  constructor({\n    blockHash,\n    blockNumber,\n    blockTag,\n    hash,\n    index,\n  }: {\n    blockHash?: Hash | undefined\n    blockNumber?: bigint | undefined\n    blockTag?: BlockTag | undefined\n    hash?: Hash | undefined\n    index?: number | undefined\n  }) {\n    let identifier = 'Transaction'\n    if (blockTag && index !== undefined)\n      identifier = `Transaction at block time \"${blockTag}\" at index \"${index}\"`\n    if (blockHash && index !== undefined)\n      identifier = `Transaction at block hash \"${blockHash}\" at index \"${index}\"`\n    if (blockNumber && index !== undefined)\n      identifier = `Transaction at block number \"${blockNumber}\" at index \"${index}\"`\n    if (hash) identifier = `Transaction with hash \"${hash}\"`\n    super(`${identifier} could not be found.`)\n  }\n}\n\nexport type TransactionReceiptNotFoundErrorType =\n  TransactionReceiptNotFoundError & {\n    name: 'TransactionReceiptNotFoundError'\n  }\nexport class TransactionReceiptNotFoundError extends BaseError {\n  override name = 'TransactionReceiptNotFoundError'\n  constructor({ hash }: { hash: Hash }) {\n    super(\n      `Transaction receipt with hash \"${hash}\" could not be found. The Transaction may not be processed on a block yet.`,\n    )\n  }\n}\n\nexport type WaitForTransactionReceiptTimeoutErrorType =\n  WaitForTransactionReceiptTimeoutError & {\n    name: 'WaitForTransactionReceiptTimeoutError'\n  }\nexport class WaitForTransactionReceiptTimeoutError extends BaseError {\n  override name = 'WaitForTransactionReceiptTimeoutError'\n  constructor({ hash }: { hash: Hash }) {\n    super(\n      `Timed out while waiting for transaction with hash \"${hash}\" to be confirmed.`,\n    )\n  }\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Kzg } from '../../types/kzg.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type BlobsToCommitmentsParameters<\n  blobs extends readonly ByteArray[] | readonly Hex[] =\n    | readonly ByteArray[]\n    | readonly Hex[],\n  to extends To | undefined = undefined,\n> = {\n  /** Blobs to transform into commitments. */\n  blobs: blobs | readonly ByteArray[] | readonly Hex[]\n  /** KZG implementation. */\n  kzg: Pick<Kzg, 'blobToKzgCommitment'>\n  /** Return type. */\n  to?: to | To | undefined\n}\n\nexport type BlobsToCommitmentsReturnType<to extends To> =\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\n  | (to extends 'hex' ? readonly Hex[] : never)\n\nexport type BlobsToCommitmentsErrorType =\n  | HexToBytesErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\n/**\n * Compute commitments from a list of blobs.\n *\n * @example\n * ```ts\n * import { blobsToCommitments, toBlobs } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * ```\n */\nexport function blobsToCommitments<\n  const blobs extends readonly ByteArray[] | readonly Hex[],\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: BlobsToCommitmentsParameters<blobs, to>,\n): BlobsToCommitmentsReturnType<to> {\n  const { kzg } = parameters\n\n  const to =\n    parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes')\n  const blobs = (\n    typeof parameters.blobs[0] === 'string'\n      ? parameters.blobs.map((x) => hexToBytes(x as any))\n      : parameters.blobs\n  ) as ByteArray[]\n\n  const commitments: ByteArray[] = []\n  for (const blob of blobs)\n    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)))\n\n  return (to === 'bytes'\n    ? commitments\n    : commitments.map((x) =>\n        bytesToHex(x),\n      )) as {} as BlobsToCommitmentsReturnType<to>\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { Kzg } from '../../types/kzg.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type blobsToProofsParameters<\n  blobs extends readonly ByteArray[] | readonly Hex[],\n  commitments extends readonly ByteArray[] | readonly Hex[],\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n  ///\n  _blobsType =\n    | (blobs extends readonly Hex[] ? readonly Hex[] : never)\n    | (blobs extends readonly ByteArray[] ? readonly ByteArray[] : never),\n> = {\n  /** Blobs to transform into proofs. */\n  blobs: blobs\n  /** Commitments for the blobs. */\n  commitments: commitments &\n    (commitments extends _blobsType\n      ? {}\n      : `commitments must be the same type as blobs`)\n  /** KZG implementation. */\n  kzg: Pick<Kzg, 'computeBlobKzgProof'>\n  /** Return type. */\n  to?: to | To | undefined\n}\n\nexport type blobsToProofsReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray[] : never)\n  | (to extends 'hex' ? Hex[] : never)\n\nexport type blobsToProofsErrorType =\n  | BytesToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\n/**\n * Compute the proofs for a list of blobs and their commitments.\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   toBlobs\n * } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * const proofs = blobsToProofs({ blobs, commitments, kzg })\n * ```\n */\nexport function blobsToProofs<\n  const blobs extends readonly ByteArray[] | readonly Hex[],\n  const commitments extends readonly ByteArray[] | readonly Hex[],\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: blobsToProofsParameters<blobs, commitments, to>,\n): blobsToProofsReturnType<to> {\n  const { kzg } = parameters\n\n  const to =\n    parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes')\n\n  const blobs = (\n    typeof parameters.blobs[0] === 'string'\n      ? parameters.blobs.map((x) => hexToBytes(x as any))\n      : parameters.blobs\n  ) as ByteArray[]\n  const commitments = (\n    typeof parameters.commitments[0] === 'string'\n      ? parameters.commitments.map((x) => hexToBytes(x as any))\n      : parameters.commitments\n  ) as ByteArray[]\n\n  const proofs: ByteArray[] = []\n  for (let i = 0; i < blobs.length; i++) {\n    const blob = blobs[i]\n    const commitment = commitments[i]\n    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)))\n  }\n\n  return (to === 'bytes'\n    ? proofs\n    : proofs.map((x) => bytesToHex(x))) as {} as blobsToProofsReturnType<to>\n}\n","import { exists, output } from './_assert.js';\nimport { Hash, createView, Input, toBytes } from './utils.js';\n\n// Polyfill for Safari 14\nfunction setBigUint64(view: DataView, byteOffset: number, value: bigint, isLE: boolean): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n// Base SHA2 class (RFC 6234)\nexport abstract class SHA2<T extends SHA2<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    readonly padOffset: number,\n    readonly isLE: boolean\n  ) {\n    super();\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    exists(this);\n    const { view, buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    exists(this);\n    output(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n","import { SHA2 } from './_sha2.js';\nimport { rotr, wrapConstructor } from './utils.js';\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n\n// Choice: a ? b : c\nconst Chi = (a: number, b: number, c: number) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a: number, b: number, c: number) => (a & b) ^ (a & c) ^ (b & c);\n\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */new Uint32Array([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */new Uint32Array([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends SHA2<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  A = IV[0] | 0;\n  B = IV[1] | 0;\n  C = IV[2] | 0;\n  D = IV[3] | 0;\n  E = IV[4] | 0;\n  F = IV[5] | 0;\n  G = IV[6] | 0;\n  H = IV[7] | 0;\n\n  constructor() {\n    super(64, 32, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean() {\n    SHA256_W.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n  A = 0xc1059ed8 | 0;\n  B = 0x367cd507 | 0;\n  C = 0x3070dd17 | 0;\n  D = 0xf70e5939 | 0;\n  E = 0xffc00b31 | 0;\n  F = 0x68581511 | 0;\n  G = 0x64f98fa7 | 0;\n  H = 0xbefa4fa4 | 0;\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\nimport { type Sha256ErrorType, sha256 } from '../hash/sha256.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type CommitmentToVersionedHashParameters<\n  commitment extends Uint8Array | Hex = Uint8Array | Hex,\n  to extends To | undefined = undefined,\n> = {\n  /** Commitment from blob. */\n  commitment: commitment | Uint8Array | Hex\n  /** Return type. */\n  to?: to | To | undefined\n  /** Version to tag onto the hash. */\n  version?: number | undefined\n}\n\nexport type CommitmentToVersionedHashReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type CommitmentToVersionedHashErrorType =\n  | Sha256ErrorType\n  | BytesToHexErrorType\n  | ErrorType\n\n/**\n * Transform a commitment to it's versioned hash.\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   commitmentToVersionedHash,\n *   toBlobs\n * } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const [commitment] = blobsToCommitments({ blobs, kzg })\n * const versionedHash = commitmentToVersionedHash({ commitment })\n * ```\n */\nexport function commitmentToVersionedHash<\n  const commitment extends Hex | ByteArray,\n  to extends To =\n    | (commitment extends Hex ? 'hex' : never)\n    | (commitment extends ByteArray ? 'bytes' : never),\n>(\n  parameters: CommitmentToVersionedHashParameters<commitment, to>,\n): CommitmentToVersionedHashReturnType<to> {\n  const { commitment, version = 1 } = parameters\n  const to = parameters.to ?? (typeof commitment === 'string' ? 'hex' : 'bytes')\n\n  const versionedHash = sha256(commitment, 'bytes')\n  versionedHash.set([version], 0)\n  return (\n    to === 'bytes' ? versionedHash : bytesToHex(versionedHash)\n  ) as CommitmentToVersionedHashReturnType<to>\n}\n","import { sha256 as noble_sha256 } from '@noble/hashes/sha256'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { type IsHexErrorType, isHex } from '../data/isHex.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type Sha256Hash<TTo extends To> =\n  | (TTo extends 'bytes' ? ByteArray : never)\n  | (TTo extends 'hex' ? Hex : never)\n\nexport type Sha256ErrorType =\n  | IsHexErrorType\n  | ToBytesErrorType\n  | ToHexErrorType\n  | ErrorType\n\nexport function sha256<TTo extends To = 'hex'>(\n  value: Hex | ByteArray,\n  to_?: TTo | undefined,\n): Sha256Hash<TTo> {\n  const to = to_ || 'hex'\n  const bytes = noble_sha256(\n    isHex(value, { strict: false }) ? toBytes(value) : value,\n  )\n  if (to === 'bytes') return bytes as Sha256Hash<TTo>\n  return toHex(bytes) as Sha256Hash<TTo>\n}\n","// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters\n\n/** Blob limit per transaction. */\nexport const blobsPerTransaction = 6\n\n/** The number of bytes in a BLS scalar field element. */\nexport const bytesPerFieldElement = 32\n\n/** The number of field elements in a blob. */\nexport const fieldElementsPerBlob = 4096\n\n/** The number of bytes in a blob. */\nexport const bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob\n\n/** Blob bytes limit per transaction. */\nexport const maxBytesPerTransaction =\n  bytesPerBlob * blobsPerTransaction -\n  // terminator byte (0x80).\n  1 -\n  // zero byte (0x00) appended to each field element.\n  1 * fieldElementsPerBlob * blobsPerTransaction\n","// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters\n\n/** The number of bytes in a KZG commitment. */\nexport const bytesPerCommitment = 48\n\n/** The number of bytes in a KZG proof. */\nexport const bytesPerProof = 48\n\nexport const versionedHashVersionKzg = 1\n","import { versionedHashVersionKzg } from '../constants/kzg.js'\nimport type { Hash } from '../types/misc.js'\n\nimport { BaseError } from './base.js'\n\nexport type BlobSizeTooLargeErrorType = BlobSizeTooLargeError & {\n  name: 'BlobSizeTooLargeError'\n}\nexport class BlobSizeTooLargeError extends BaseError {\n  override name = 'BlobSizeTooLargeError'\n  constructor({ maxSize, size }: { maxSize: number; size: number }) {\n    super('Blob size is too large.', {\n      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size} bytes`],\n    })\n  }\n}\n\nexport type EmptyBlobErrorType = EmptyBlobError & {\n  name: 'EmptyBlobError'\n}\nexport class EmptyBlobError extends BaseError {\n  override name = 'EmptyBlobError'\n  constructor() {\n    super('Blob data must not be empty.')\n  }\n}\n\nexport type InvalidVersionedHashSizeErrorType =\n  InvalidVersionedHashSizeError & {\n    name: 'InvalidVersionedHashSizeError'\n  }\nexport class InvalidVersionedHashSizeError extends BaseError {\n  override name = 'InvalidVersionedHashSizeError'\n  constructor({\n    hash,\n    size,\n  }: {\n    hash: Hash\n    size: number\n  }) {\n    super(`Versioned hash \"${hash}\" size is invalid.`, {\n      metaMessages: ['Expected: 32', `Received: ${size}`],\n    })\n  }\n}\n\nexport type InvalidVersionedHashVersionErrorType =\n  InvalidVersionedHashVersionError & {\n    name: 'InvalidVersionedHashVersionError'\n  }\nexport class InvalidVersionedHashVersionError extends BaseError {\n  override name = 'InvalidVersionedHashVersionError'\n  constructor({\n    hash,\n    version,\n  }: {\n    hash: Hash\n    version: number\n  }) {\n    super(`Versioned hash \"${hash}\" version is invalid.`, {\n      metaMessages: [\n        `Expected: ${versionedHashVersionKzg}`,\n        `Received: ${version}`,\n      ],\n    })\n  }\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { BlobSidecars } from '../../types/eip4844.js'\nimport type { Kzg } from '../../types/kzg.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport type { OneOf } from '../../types/utils.js'\nimport {\n  type BlobsToCommitmentsErrorType,\n  blobsToCommitments,\n} from './blobsToCommitments.js'\nimport { blobsToProofs, type blobsToProofsErrorType } from './blobsToProofs.js'\nimport { type ToBlobsErrorType, toBlobs } from './toBlobs.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type ToBlobSidecarsParameters<\n  data extends Hex | ByteArray | undefined = undefined,\n  blobs extends readonly Hex[] | readonly ByteArray[] | undefined = undefined,\n  to extends To =\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n  ///\n  _blobsType =\n    | (blobs extends readonly Hex[] ? readonly Hex[] : never)\n    | (blobs extends readonly ByteArray[] ? readonly ByteArray[] : never),\n> = {\n  /** Return type. */\n  to?: to | To | undefined\n} & OneOf<\n  | {\n      /** Data to transform into blobs. */\n      data: data | Hex | ByteArray\n      /** KZG implementation. */\n      kzg: Kzg\n    }\n  | {\n      /** Blobs. */\n      blobs: blobs | readonly Hex[] | readonly ByteArray[]\n      /** Commitment for each blob. */\n      commitments: _blobsType | readonly Hex[] | readonly ByteArray[]\n      /** Proof for each blob. */\n      proofs: _blobsType | readonly Hex[] | readonly ByteArray[]\n    }\n>\n\nexport type ToBlobSidecarsReturnType<to extends To> =\n  | (to extends 'bytes' ? BlobSidecars<ByteArray> : never)\n  | (to extends 'hex' ? BlobSidecars<Hex> : never)\n\nexport type ToBlobSidecarsErrorType =\n  | BlobsToCommitmentsErrorType\n  | ToBlobsErrorType\n  | blobsToProofsErrorType\n  | ErrorType\n\n/**\n * Transforms arbitrary data (or blobs, commitments, & proofs) into a sidecar array.\n *\n * @example\n * ```ts\n * import { toBlobSidecars, stringToHex } from 'viem'\n *\n * const sidecars = toBlobSidecars({ data: stringToHex('hello world') })\n * ```\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   toBlobs,\n *   blobsToProofs,\n *   toBlobSidecars,\n *   stringToHex\n * } from 'viem'\n *\n * const blobs = toBlobs({ data: stringToHex('hello world') })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * const proofs = blobsToProofs({ blobs, commitments, kzg })\n *\n * const sidecars = toBlobSidecars({ blobs, commitments, proofs })\n * ```\n */\nexport function toBlobSidecars<\n  const data extends Hex | ByteArray | undefined = undefined,\n  const blobs extends\n    | readonly Hex[]\n    | readonly ByteArray[]\n    | undefined = undefined,\n  to extends To =\n    | (data extends Hex ? 'hex' : never)\n    | (data extends ByteArray ? 'bytes' : never)\n    | (blobs extends readonly Hex[] ? 'hex' : never)\n    | (blobs extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: ToBlobSidecarsParameters<data, blobs, to>,\n): ToBlobSidecarsReturnType<to> {\n  const { data, kzg, to } = parameters\n  const blobs = parameters.blobs ?? toBlobs({ data: data!, to })\n  const commitments =\n    parameters.commitments ?? blobsToCommitments({ blobs, kzg: kzg!, to })\n  const proofs =\n    parameters.proofs ?? blobsToProofs({ blobs, commitments, kzg: kzg!, to })\n\n  const sidecars: BlobSidecars = []\n  for (let i = 0; i < blobs.length; i++)\n    sidecars.push({\n      blob: blobs[i],\n      commitment: commitments[i],\n      proof: proofs[i],\n    })\n\n  return sidecars as ToBlobSidecarsReturnType<to>\n}\n","import {\n  bytesPerBlob,\n  bytesPerFieldElement,\n  fieldElementsPerBlob,\n  maxBytesPerTransaction,\n} from '../../constants/blob.js'\nimport {\n  BlobSizeTooLargeError,\n  type BlobSizeTooLargeErrorType,\n  EmptyBlobError,\n  type EmptyBlobErrorType,\n} from '../../errors/blob.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport { createCursor } from '../cursor.js'\nimport { type SizeErrorType, size } from '../data/size.js'\nimport { type HexToBytesErrorType, hexToBytes } from '../encoding/toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from '../encoding/toHex.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type ToBlobsParameters<\n  data extends Hex | ByteArray = Hex | ByteArray,\n  to extends To | undefined = undefined,\n> = {\n  /** Data to transform to a blob. */\n  data: data | Hex | ByteArray\n  /** Return type. */\n  to?: to | To | undefined\n}\n\nexport type ToBlobsReturnType<to extends To> =\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\n  | (to extends 'hex' ? readonly Hex[] : never)\n\nexport type ToBlobsErrorType =\n  | BlobSizeTooLargeErrorType\n  | BytesToHexErrorType\n  | EmptyBlobErrorType\n  | HexToBytesErrorType\n  | SizeErrorType\n  | ErrorType\n\n/**\n * Transforms arbitrary data to blobs.\n *\n * @example\n * ```ts\n * import { toBlobs, stringToHex } from 'viem'\n *\n * const blobs = toBlobs({ data: stringToHex('hello world') })\n * ```\n */\nexport function toBlobs<\n  const data extends Hex | ByteArray,\n  to extends To =\n    | (data extends Hex ? 'hex' : never)\n    | (data extends ByteArray ? 'bytes' : never),\n>(parameters: ToBlobsParameters<data, to>): ToBlobsReturnType<to> {\n  const to =\n    parameters.to ?? (typeof parameters.data === 'string' ? 'hex' : 'bytes')\n  const data = (\n    typeof parameters.data === 'string'\n      ? hexToBytes(parameters.data)\n      : parameters.data\n  ) as ByteArray\n\n  const size_ = size(data)\n  if (!size_) throw new EmptyBlobError()\n  if (size_ > maxBytesPerTransaction)\n    throw new BlobSizeTooLargeError({\n      maxSize: maxBytesPerTransaction,\n      size: size_,\n    })\n\n  const blobs = []\n\n  let active = true\n  let position = 0\n  while (active) {\n    const blob = createCursor(new Uint8Array(bytesPerBlob))\n\n    let size = 0\n    while (size < fieldElementsPerBlob) {\n      const bytes = data.slice(position, position + (bytesPerFieldElement - 1))\n\n      // Push a zero byte so the field element doesn't overflow the BLS modulus.\n      blob.pushByte(0x00)\n\n      // Push the current segment of data bytes.\n      blob.pushBytes(bytes)\n\n      // If we detect that the current segment of data bytes is less than 31 bytes,\n      // we can stop processing and push a terminator byte to indicate the end of the blob.\n      if (bytes.length < 31) {\n        blob.pushByte(0x80)\n        active = false\n        break\n      }\n\n      size++\n      position += 31\n    }\n\n    blobs.push(blob)\n  }\n\n  return (\n    to === 'bytes'\n      ? blobs.map((x) => x.bytes)\n      : blobs.map((x) => bytesToHex(x.bytes))\n  ) as any\n}\n","import type { Chain } from '../types/chain.js'\n\nimport { BaseError } from './base.js'\n\nexport type ChainDoesNotSupportContractErrorType =\n  ChainDoesNotSupportContract & {\n    name: 'ChainDoesNotSupportContract'\n  }\nexport class ChainDoesNotSupportContract extends BaseError {\n  override name = 'ChainDoesNotSupportContract'\n  constructor({\n    blockNumber,\n    chain,\n    contract,\n  }: {\n    blockNumber?: bigint | undefined\n    chain: Chain\n    contract: { name: string; blockCreated?: number | undefined }\n  }) {\n    super(\n      `Chain \"${chain.name}\" does not support contract \"${contract.name}\".`,\n      {\n        metaMessages: [\n          'This could be due to any of the following:',\n          ...(blockNumber &&\n          contract.blockCreated &&\n          contract.blockCreated > blockNumber\n            ? [\n                `- The contract \"${contract.name}\" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`,\n              ]\n            : [\n                `- The chain does not have the contract \"${contract.name}\" configured.`,\n              ]),\n        ],\n      },\n    )\n  }\n}\n\nexport type ChainMismatchErrorType = ChainMismatchError & {\n  name: 'ChainMismatchError'\n}\nexport class ChainMismatchError extends BaseError {\n  override name = 'ChainMismatchError'\n\n  constructor({\n    chain,\n    currentChainId,\n  }: {\n    chain: Chain\n    currentChainId: number\n  }) {\n    super(\n      `The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id}  ${chain.name}).`,\n      {\n        metaMessages: [\n          `Current Chain ID:  ${currentChainId}`,\n          `Expected Chain ID: ${chain.id}  ${chain.name}`,\n        ],\n      },\n    )\n  }\n}\n\nexport type ChainNotFoundErrorType = ChainNotFoundError & {\n  name: 'ChainNotFoundError'\n}\nexport class ChainNotFoundError extends BaseError {\n  override name = 'ChainNotFoundError'\n\n  constructor() {\n    super(\n      [\n        'No chain was provided to the request.',\n        'Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient.',\n      ].join('\\n'),\n    )\n  }\n}\n\nexport type ClientChainNotConfiguredErrorType =\n  ClientChainNotConfiguredError & {\n    name: 'ClientChainNotConfiguredError'\n  }\nexport class ClientChainNotConfiguredError extends BaseError {\n  override name = 'ClientChainNotConfiguredError'\n\n  constructor() {\n    super('No chain was provided to the Client.')\n  }\n}\n\nexport type InvalidChainIdErrorType = InvalidChainIdError & {\n  name: 'InvalidChainIdError'\n}\nexport class InvalidChainIdError extends BaseError {\n  override name = 'InvalidChainIdError'\n\n  constructor({ chainId }: { chainId?: number | undefined }) {\n    super(\n      typeof chainId === 'number'\n        ? `Chain ID \"${chainId}\" is invalid.`\n        : 'Chain ID is invalid.',\n    )\n  }\n}\n","import { formatGwei } from '../utils/unit/formatGwei.js'\n\nimport { BaseError } from './base.js'\n\n/**\n * geth:    https://github.com/ethereum/go-ethereum/blob/master/core/error.go\n *          https://github.com/ethereum/go-ethereum/blob/master/core/types/transaction.go#L34-L41\n *\n * erigon:  https://github.com/ledgerwatch/erigon/blob/master/core/error.go\n *          https://github.com/ledgerwatch/erigon/blob/master/core/types/transaction.go#L41-L46\n *\n * anvil:   https://github.com/foundry-rs/foundry/blob/master/anvil/src/eth/error.rs#L108\n */\nexport type ExecutionRevertedErrorType = ExecutionRevertedError & {\n  code: 3\n  name: 'ExecutionRevertedError'\n}\nexport class ExecutionRevertedError extends BaseError {\n  static code = 3\n  static nodeMessage = /execution reverted/\n\n  override name = 'ExecutionRevertedError'\n\n  constructor({\n    cause,\n    message,\n  }: { cause?: BaseError | undefined; message?: string | undefined } = {}) {\n    const reason = message\n      ?.replace('execution reverted: ', '')\n      ?.replace('execution reverted', '')\n    super(\n      `Execution reverted ${\n        reason ? `with reason: ${reason}` : 'for an unknown reason'\n      }.`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport type FeeCapTooHighErrorType = FeeCapTooHighError & {\n  name: 'FeeCapTooHighError'\n}\nexport class FeeCapTooHighError extends BaseError {\n  static nodeMessage =\n    /max fee per gas higher than 2\\^256-1|fee cap higher than 2\\^256-1/\n  override name = 'FeeCapTooHigh'\n  constructor({\n    cause,\n    maxFeePerGas,\n  }: {\n    cause?: BaseError | undefined\n    maxFeePerGas?: bigint | undefined\n  } = {}) {\n    super(\n      `The fee cap (\\`maxFeePerGas\\`${\n        maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ''\n      }) cannot be higher than the maximum allowed value (2^256-1).`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport type FeeCapTooLowErrorType = FeeCapTooLowError & {\n  name: 'FeeCapTooLowError'\n}\nexport class FeeCapTooLowError extends BaseError {\n  static nodeMessage =\n    /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/\n  override name = 'FeeCapTooLow'\n  constructor({\n    cause,\n    maxFeePerGas,\n  }: {\n    cause?: BaseError | undefined\n    maxFeePerGas?: bigint | undefined\n  } = {}) {\n    super(\n      `The fee cap (\\`maxFeePerGas\\`${\n        maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ''\n      } gwei) cannot be lower than the block base fee.`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport type NonceTooHighErrorType = NonceTooHighError & {\n  name: 'NonceTooHighError'\n}\nexport class NonceTooHighError extends BaseError {\n  static nodeMessage = /nonce too high/\n  override name = 'NonceTooHighError'\n  constructor({\n    cause,\n    nonce,\n  }: { cause?: BaseError | undefined; nonce?: number | undefined } = {}) {\n    super(\n      `Nonce provided for the transaction ${\n        nonce ? `(${nonce}) ` : ''\n      }is higher than the next one expected.`,\n      { cause },\n    )\n  }\n}\n\nexport type NonceTooLowErrorType = NonceTooLowError & {\n  name: 'NonceTooLowError'\n}\nexport class NonceTooLowError extends BaseError {\n  static nodeMessage =\n    /nonce too low|transaction already imported|already known/\n  override name = 'NonceTooLowError'\n  constructor({\n    cause,\n    nonce,\n  }: { cause?: BaseError | undefined; nonce?: number | undefined } = {}) {\n    super(\n      [\n        `Nonce provided for the transaction ${\n          nonce ? `(${nonce}) ` : ''\n        }is lower than the current nonce of the account.`,\n        'Try increasing the nonce or find the latest nonce with `getTransactionCount`.',\n      ].join('\\n'),\n      { cause },\n    )\n  }\n}\n\nexport type NonceMaxValueErrorType = NonceMaxValueError & {\n  name: 'NonceMaxValueError'\n}\nexport class NonceMaxValueError extends BaseError {\n  static nodeMessage = /nonce has max value/\n  override name = 'NonceMaxValueError'\n  constructor({\n    cause,\n    nonce,\n  }: { cause?: BaseError | undefined; nonce?: number | undefined } = {}) {\n    super(\n      `Nonce provided for the transaction ${\n        nonce ? `(${nonce}) ` : ''\n      }exceeds the maximum allowed nonce.`,\n      { cause },\n    )\n  }\n}\n\nexport type InsufficientFundsErrorType = InsufficientFundsError & {\n  name: 'InsufficientFundsError'\n}\nexport class InsufficientFundsError extends BaseError {\n  static nodeMessage = /insufficient funds/\n  override name = 'InsufficientFundsError'\n  constructor({ cause }: { cause?: BaseError | undefined } = {}) {\n    super(\n      [\n        'The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.',\n      ].join('\\n'),\n      {\n        cause,\n        metaMessages: [\n          'This error could arise when the account does not have enough funds to:',\n          ' - pay for the total gas fee,',\n          ' - pay for the value to send.',\n          ' ',\n          'The cost of the transaction is calculated as `gas * gas fee + value`, where:',\n          ' - `gas` is the amount of gas needed for transaction to execute,',\n          ' - `gas fee` is the gas fee,',\n          ' - `value` is the amount of ether to send to the recipient.',\n        ],\n      },\n    )\n  }\n}\n\nexport type IntrinsicGasTooHighErrorType = IntrinsicGasTooHighError & {\n  name: 'IntrinsicGasTooHighError'\n}\nexport class IntrinsicGasTooHighError extends BaseError {\n  static nodeMessage = /intrinsic gas too high|gas limit reached/\n  override name = 'IntrinsicGasTooHighError'\n  constructor({\n    cause,\n    gas,\n  }: { cause?: BaseError | undefined; gas?: bigint | undefined } = {}) {\n    super(\n      `The amount of gas ${\n        gas ? `(${gas}) ` : ''\n      }provided for the transaction exceeds the limit allowed for the block.`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport type IntrinsicGasTooLowErrorType = IntrinsicGasTooLowError & {\n  name: 'IntrinsicGasTooLowError'\n}\nexport class IntrinsicGasTooLowError extends BaseError {\n  static nodeMessage = /intrinsic gas too low/\n  override name = 'IntrinsicGasTooLowError'\n  constructor({\n    cause,\n    gas,\n  }: { cause?: BaseError | undefined; gas?: bigint | undefined } = {}) {\n    super(\n      `The amount of gas ${\n        gas ? `(${gas}) ` : ''\n      }provided for the transaction is too low.`,\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport type TransactionTypeNotSupportedErrorType =\n  TransactionTypeNotSupportedError & {\n    name: 'TransactionTypeNotSupportedError'\n  }\nexport class TransactionTypeNotSupportedError extends BaseError {\n  static nodeMessage = /transaction type not valid/\n  override name = 'TransactionTypeNotSupportedError'\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super('The transaction type is not supported for this chain.', {\n      cause,\n    })\n  }\n}\n\nexport type TipAboveFeeCapErrorType = TipAboveFeeCapError & {\n  name: 'TipAboveFeeCapError'\n}\nexport class TipAboveFeeCapError extends BaseError {\n  static nodeMessage =\n    /max priority fee per gas higher than max fee per gas|tip higher than fee cap/\n  override name = 'TipAboveFeeCapError'\n  constructor({\n    cause,\n    maxPriorityFeePerGas,\n    maxFeePerGas,\n  }: {\n    cause?: BaseError | undefined\n    maxPriorityFeePerGas?: bigint | undefined\n    maxFeePerGas?: bigint | undefined\n  } = {}) {\n    super(\n      [\n        `The provided tip (\\`maxPriorityFeePerGas\\`${\n          maxPriorityFeePerGas\n            ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei`\n            : ''\n        }) cannot be higher than the fee cap (\\`maxFeePerGas\\`${\n          maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ''\n        }).`,\n      ].join('\\n'),\n      {\n        cause,\n      },\n    )\n  }\n}\n\nexport type UnknownNodeErrorType = UnknownNodeError & {\n  name: 'UnknownNodeError'\n}\nexport class UnknownNodeError extends BaseError {\n  override name = 'UnknownNodeError'\n\n  constructor({ cause }: { cause?: BaseError | undefined }) {\n    super(`An error occurred while executing: ${cause?.shortMessage}`, {\n      cause,\n    })\n  }\n}\n","import { versionedHashVersionKzg } from '../../constants/kzg.js'\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport { BaseError, type BaseErrorType } from '../../errors/base.js'\nimport {\n  EmptyBlobError,\n  type EmptyBlobErrorType,\n  InvalidVersionedHashSizeError,\n  type InvalidVersionedHashSizeErrorType,\n  InvalidVersionedHashVersionError,\n  type InvalidVersionedHashVersionErrorType,\n} from '../../errors/blob.js'\nimport {\n  InvalidChainIdError,\n  type InvalidChainIdErrorType,\n} from '../../errors/chain.js'\nimport {\n  FeeCapTooHighError,\n  type FeeCapTooHighErrorType,\n  TipAboveFeeCapError,\n  type TipAboveFeeCapErrorType,\n} from '../../errors/node.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  TransactionSerializableEIP1559,\n  TransactionSerializableEIP2930,\n  TransactionSerializableEIP4844,\n  TransactionSerializableLegacy,\n} from '../../types/transaction.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { size } from '../data/size.js'\nimport { slice } from '../data/slice.js'\nimport { hexToNumber } from '../encoding/fromHex.js'\n\nexport type AssertTransactionEIP4844ErrorType =\n  | AssertTransactionEIP1559ErrorType\n  | EmptyBlobErrorType\n  | InvalidVersionedHashSizeErrorType\n  | InvalidVersionedHashVersionErrorType\n  | ErrorType\n\nexport function assertTransactionEIP4844(\n  transaction: TransactionSerializableEIP4844,\n) {\n  const { blobVersionedHashes } = transaction\n  if (blobVersionedHashes) {\n    if (blobVersionedHashes.length === 0) throw new EmptyBlobError()\n    for (const hash of blobVersionedHashes) {\n      const size_ = size(hash)\n      const version = hexToNumber(slice(hash, 0, 1))\n      if (size_ !== 32)\n        throw new InvalidVersionedHashSizeError({ hash, size: size_ })\n      if (version !== versionedHashVersionKzg)\n        throw new InvalidVersionedHashVersionError({\n          hash,\n          version,\n        })\n    }\n  }\n  assertTransactionEIP1559(transaction as {} as TransactionSerializableEIP1559)\n}\n\nexport type AssertTransactionEIP1559ErrorType =\n  | BaseErrorType\n  | IsAddressErrorType\n  | InvalidAddressErrorType\n  | InvalidChainIdErrorType\n  | FeeCapTooHighErrorType\n  | TipAboveFeeCapErrorType\n  | ErrorType\n\nexport function assertTransactionEIP1559(\n  transaction: TransactionSerializableEIP1559,\n) {\n  const { chainId, maxPriorityFeePerGas, maxFeePerGas, to } = transaction\n  if (chainId <= 0) throw new InvalidChainIdError({ chainId })\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)\n    throw new FeeCapTooHighError({ maxFeePerGas })\n  if (\n    maxPriorityFeePerGas &&\n    maxFeePerGas &&\n    maxPriorityFeePerGas > maxFeePerGas\n  )\n    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas })\n}\n\nexport type AssertTransactionEIP2930ErrorType =\n  | BaseErrorType\n  | IsAddressErrorType\n  | InvalidAddressErrorType\n  | InvalidChainIdErrorType\n  | FeeCapTooHighErrorType\n  | ErrorType\n\nexport function assertTransactionEIP2930(\n  transaction: TransactionSerializableEIP2930,\n) {\n  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } =\n    transaction\n  if (chainId <= 0) throw new InvalidChainIdError({ chainId })\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (maxPriorityFeePerGas || maxFeePerGas)\n    throw new BaseError(\n      '`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.',\n    )\n  if (gasPrice && gasPrice > 2n ** 256n - 1n)\n    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice })\n}\n\nexport type AssertTransactionLegacyErrorType =\n  | BaseErrorType\n  | IsAddressErrorType\n  | InvalidAddressErrorType\n  | InvalidChainIdErrorType\n  | FeeCapTooHighErrorType\n  | ErrorType\n\nexport function assertTransactionLegacy(\n  transaction: TransactionSerializableLegacy,\n) {\n  const {\n    chainId,\n    maxPriorityFeePerGas,\n    gasPrice,\n    maxFeePerGas,\n    to,\n    accessList,\n  } = transaction\n  if (to && !isAddress(to)) throw new InvalidAddressError({ address: to })\n  if (typeof chainId !== 'undefined' && chainId <= 0)\n    throw new InvalidChainIdError({ chainId })\n  if (maxPriorityFeePerGas || maxFeePerGas)\n    throw new BaseError(\n      '`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.',\n    )\n  if (gasPrice && gasPrice > 2n ** 256n - 1n)\n    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice })\n  if (accessList)\n    throw new BaseError(\n      '`accessList` is not a valid Legacy Transaction attribute.',\n    )\n}\n","import {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport {\n  InvalidStorageKeySizeError,\n  type InvalidStorageKeySizeErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { AccessList } from '../../types/transaction.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport type { RecursiveArray } from '../encoding/toRlp.js'\n\nexport type SerializeAccessListErrorType =\n  | InvalidStorageKeySizeErrorType\n  | InvalidAddressErrorType\n  | IsAddressErrorType\n  | ErrorType\n\n/*\n * Serialize an  EIP-2930 access list\n * @remarks\n * Use to create a transaction serializer with support for EIP-2930 access lists\n *\n * @param accessList - Array of objects of address and arrays of Storage Keys\n * @throws InvalidAddressError, InvalidStorageKeySizeError\n * @returns Array of hex strings\n */\nexport function serializeAccessList(\n  accessList?: AccessList | undefined,\n): RecursiveArray<Hex> {\n  if (!accessList || accessList.length === 0) return []\n\n  const serializedAccessList = []\n  for (let i = 0; i < accessList.length; i++) {\n    const { address, storageKeys } = accessList[i]\n\n    for (let j = 0; j < storageKeys.length; j++) {\n      if (storageKeys[j].length - 2 !== 64) {\n        throw new InvalidStorageKeySizeError({ storageKey: storageKeys[j] })\n      }\n    }\n\n    if (!isAddress(address, { strict: false })) {\n      throw new InvalidAddressError({ address })\n    }\n\n    serializedAccessList.push([address, storageKeys])\n  }\n  return serializedAccessList\n}\n","import {\n  InvalidLegacyVError,\n  type InvalidLegacyVErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ByteArray,\n  Hex,\n  Signature,\n  SignatureLegacy,\n} from '../../types/misc.js'\nimport type {\n  TransactionSerializable,\n  TransactionSerializableEIP1559,\n  TransactionSerializableEIP2930,\n  TransactionSerializableEIP4844,\n  TransactionSerializableGeneric,\n  TransactionSerializableLegacy,\n  TransactionSerialized,\n  TransactionSerializedEIP1559,\n  TransactionSerializedEIP2930,\n  TransactionSerializedEIP4844,\n  TransactionSerializedLegacy,\n  TransactionType,\n} from '../../types/transaction.js'\nimport type { OneOf } from '../../types/utils.js'\nimport {\n  type BlobsToCommitmentsErrorType,\n  blobsToCommitments,\n} from '../blob/blobsToCommitments.js'\nimport {\n  blobsToProofs,\n  type blobsToProofsErrorType,\n} from '../blob/blobsToProofs.js'\nimport {\n  type CommitmentsToVersionedHashesErrorType,\n  commitmentsToVersionedHashes,\n} from '../blob/commitmentsToVersionedHashes.js'\nimport {\n  type ToBlobSidecarsErrorType,\n  toBlobSidecars,\n} from '../blob/toBlobSidecars.js'\nimport { type ConcatHexErrorType, concatHex } from '../data/concat.js'\nimport { trim } from '../data/trim.js'\nimport { type ToHexErrorType, bytesToHex, toHex } from '../encoding/toHex.js'\nimport { type ToRlpErrorType, toRlp } from '../encoding/toRlp.js'\n\nimport {\n  type AssertTransactionEIP1559ErrorType,\n  type AssertTransactionEIP2930ErrorType,\n  type AssertTransactionEIP4844ErrorType,\n  type AssertTransactionLegacyErrorType,\n  assertTransactionEIP1559,\n  assertTransactionEIP2930,\n  assertTransactionEIP4844,\n  assertTransactionLegacy,\n} from './assertTransaction.js'\nimport {\n  type GetTransactionType,\n  type GetTransationTypeErrorType,\n  getTransactionType,\n} from './getTransactionType.js'\nimport {\n  type SerializeAccessListErrorType,\n  serializeAccessList,\n} from './serializeAccessList.js'\n\nexport type SerializedTransactionReturnType<\n  transaction extends TransactionSerializable = TransactionSerializable,\n  ///\n  _transactionType extends TransactionType = GetTransactionType<transaction>,\n> = TransactionSerialized<_transactionType>\n\nexport type SerializeTransactionFn<\n  transaction extends TransactionSerializableGeneric = TransactionSerializable,\n  ///\n  _transactionType extends TransactionType = never,\n> = typeof serializeTransaction<\n  OneOf<TransactionSerializable | transaction>,\n  _transactionType\n>\n\nexport type SerializeTransactionErrorType =\n  | GetTransationTypeErrorType\n  | SerializeTransactionEIP1559ErrorType\n  | SerializeTransactionEIP2930ErrorType\n  | SerializeTransactionEIP4844ErrorType\n  | SerializeTransactionLegacyErrorType\n  | ErrorType\n\nexport function serializeTransaction<\n  const transaction extends TransactionSerializable,\n  ///\n  _transactionType extends TransactionType = GetTransactionType<transaction>,\n>(\n  transaction: transaction,\n  signature?: Signature | undefined,\n): SerializedTransactionReturnType<transaction, _transactionType> {\n  const type = getTransactionType(transaction) as GetTransactionType\n\n  if (type === 'eip1559')\n    return serializeTransactionEIP1559(\n      transaction as TransactionSerializableEIP1559,\n      signature,\n    ) as SerializedTransactionReturnType<transaction>\n\n  if (type === 'eip2930')\n    return serializeTransactionEIP2930(\n      transaction as TransactionSerializableEIP2930,\n      signature,\n    ) as SerializedTransactionReturnType<transaction>\n\n  if (type === 'eip4844')\n    return serializeTransactionEIP4844(\n      transaction as TransactionSerializableEIP4844,\n      signature,\n    ) as SerializedTransactionReturnType<transaction>\n\n  return serializeTransactionLegacy(\n    transaction as TransactionSerializableLegacy,\n    signature as SignatureLegacy,\n  ) as SerializedTransactionReturnType<transaction>\n}\n\ntype SerializeTransactionEIP4844ErrorType =\n  | AssertTransactionEIP4844ErrorType\n  | BlobsToCommitmentsErrorType\n  | CommitmentsToVersionedHashesErrorType\n  | blobsToProofsErrorType\n  | ToBlobSidecarsErrorType\n  | ConcatHexErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | SerializeAccessListErrorType\n  | ErrorType\n\nfunction serializeTransactionEIP4844(\n  transaction: TransactionSerializableEIP4844,\n  signature?: Signature | undefined,\n): TransactionSerializedEIP4844 {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    data,\n  } = transaction\n\n  assertTransactionEIP4844(transaction)\n\n  let blobVersionedHashes = transaction.blobVersionedHashes\n  let sidecars = transaction.sidecars\n  // If `blobs` are passed, we will need to compute the KZG commitments & proofs.\n  if (\n    transaction.blobs &&\n    (typeof blobVersionedHashes === 'undefined' ||\n      typeof sidecars === 'undefined')\n  ) {\n    const blobs = (\n      typeof transaction.blobs[0] === 'string'\n        ? transaction.blobs\n        : (transaction.blobs as ByteArray[]).map((x) => bytesToHex(x))\n    ) as Hex[]\n    const kzg = transaction.kzg!\n    const commitments = blobsToCommitments({\n      blobs,\n      kzg,\n    })\n\n    if (typeof blobVersionedHashes === 'undefined')\n      blobVersionedHashes = commitmentsToVersionedHashes({\n        commitments,\n      })\n    if (typeof sidecars === 'undefined') {\n      const proofs = blobsToProofs({ blobs, commitments, kzg })\n      sidecars = toBlobSidecars({ blobs, commitments, proofs })\n    }\n  }\n\n  const serializedAccessList = serializeAccessList(accessList)\n\n  const serializedTransaction = [\n    toHex(chainId),\n    nonce ? toHex(nonce) : '0x',\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',\n    maxFeePerGas ? toHex(maxFeePerGas) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n    serializedAccessList,\n    maxFeePerBlobGas ? toHex(maxFeePerBlobGas) : '0x',\n    blobVersionedHashes ?? [],\n    ...toYParitySignatureArray(transaction, signature),\n  ] as const\n\n  const blobs: Hex[] = []\n  const commitments: Hex[] = []\n  const proofs: Hex[] = []\n  if (sidecars)\n    for (let i = 0; i < sidecars.length; i++) {\n      const { blob, commitment, proof } = sidecars[i]\n      blobs.push(blob)\n      commitments.push(commitment)\n      proofs.push(proof)\n    }\n\n  return concatHex([\n    '0x03',\n    sidecars\n      ? // If sidecars are enabled, envelope turns into a \"wrapper\":\n        toRlp([serializedTransaction, blobs, commitments, proofs])\n      : // If sidecars are disabled, standard envelope is used:\n        toRlp(serializedTransaction),\n  ]) as TransactionSerializedEIP4844\n}\n\ntype SerializeTransactionEIP1559ErrorType =\n  | AssertTransactionEIP1559ErrorType\n  | ConcatHexErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | SerializeAccessListErrorType\n  | ErrorType\n\nfunction serializeTransactionEIP1559(\n  transaction: TransactionSerializableEIP1559,\n  signature?: Signature | undefined,\n): TransactionSerializedEIP1559 {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    accessList,\n    data,\n  } = transaction\n\n  assertTransactionEIP1559(transaction)\n\n  const serializedAccessList = serializeAccessList(accessList)\n\n  const serializedTransaction = [\n    toHex(chainId),\n    nonce ? toHex(nonce) : '0x',\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : '0x',\n    maxFeePerGas ? toHex(maxFeePerGas) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n    serializedAccessList,\n    ...toYParitySignatureArray(transaction, signature),\n  ]\n\n  return concatHex([\n    '0x02',\n    toRlp(serializedTransaction),\n  ]) as TransactionSerializedEIP1559\n}\n\ntype SerializeTransactionEIP2930ErrorType =\n  | AssertTransactionEIP2930ErrorType\n  | ConcatHexErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | SerializeAccessListErrorType\n  | ErrorType\n\nfunction serializeTransactionEIP2930(\n  transaction: TransactionSerializableEIP2930,\n  signature?: Signature | undefined,\n): TransactionSerializedEIP2930 {\n  const { chainId, gas, data, nonce, to, value, accessList, gasPrice } =\n    transaction\n\n  assertTransactionEIP2930(transaction)\n\n  const serializedAccessList = serializeAccessList(accessList)\n\n  const serializedTransaction = [\n    toHex(chainId),\n    nonce ? toHex(nonce) : '0x',\n    gasPrice ? toHex(gasPrice) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n    serializedAccessList,\n    ...toYParitySignatureArray(transaction, signature),\n  ]\n\n  return concatHex([\n    '0x01',\n    toRlp(serializedTransaction),\n  ]) as TransactionSerializedEIP2930\n}\n\ntype SerializeTransactionLegacyErrorType =\n  | AssertTransactionLegacyErrorType\n  | InvalidLegacyVErrorType\n  | ToHexErrorType\n  | ToRlpErrorType\n  | ErrorType\n\nfunction serializeTransactionLegacy(\n  transaction: TransactionSerializableLegacy,\n  signature?: SignatureLegacy | undefined,\n): TransactionSerializedLegacy {\n  const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction\n\n  assertTransactionLegacy(transaction)\n\n  let serializedTransaction = [\n    nonce ? toHex(nonce) : '0x',\n    gasPrice ? toHex(gasPrice) : '0x',\n    gas ? toHex(gas) : '0x',\n    to ?? '0x',\n    value ? toHex(value) : '0x',\n    data ?? '0x',\n  ]\n\n  if (signature) {\n    const v = (() => {\n      // EIP-155 (inferred chainId)\n      if (signature.v >= 35n) {\n        const inferredChainId = (signature.v - 35n) / 2n\n        if (inferredChainId > 0) return signature.v\n        return 27n + (signature.v === 35n ? 0n : 1n)\n      }\n\n      // EIP-155 (explicit chainId)\n      if (chainId > 0)\n        return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n)\n\n      // Pre-EIP-155 (no chainId)\n      const v = 27n + (signature.v === 27n ? 0n : 1n)\n      if (signature.v !== v) throw new InvalidLegacyVError({ v: signature.v })\n      return v\n    })()\n\n    serializedTransaction = [\n      ...serializedTransaction,\n      toHex(v),\n      signature.r,\n      signature.s,\n    ]\n  } else if (chainId > 0) {\n    serializedTransaction = [\n      ...serializedTransaction,\n      toHex(chainId),\n      '0x',\n      '0x',\n    ]\n  }\n\n  return toRlp(serializedTransaction) as TransactionSerializedLegacy\n}\n\nexport function toYParitySignatureArray(\n  transaction: TransactionSerializableGeneric,\n  signature?: Signature | undefined,\n) {\n  const { r, s, v, yParity } = signature ?? transaction\n  if (typeof r === 'undefined') return []\n  if (typeof s === 'undefined') return []\n  if (typeof v === 'undefined' && typeof yParity === 'undefined') return []\n\n  const yParity_ = (() => {\n    if (typeof yParity === 'number') return yParity ? toHex(1) : '0x'\n    if (v === 0n) return '0x'\n    if (v === 1n) return toHex(1)\n\n    return v === 27n ? '0x' : toHex(1)\n  })()\n  return [yParity_, trim(r), trim(s)]\n}\n","import {\n  InvalidSerializableTransactionError,\n  type InvalidSerializableTransactionErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  FeeValuesEIP1559,\n  FeeValuesEIP4844,\n  FeeValuesLegacy,\n} from '../../index.js'\nimport type {\n  TransactionRequestEIP1559,\n  TransactionRequestEIP2930,\n  TransactionRequestEIP4844,\n  TransactionRequestGeneric,\n  TransactionRequestLegacy,\n  TransactionSerializableEIP1559,\n  TransactionSerializableEIP2930,\n  TransactionSerializableEIP4844,\n  TransactionSerializableGeneric,\n  TransactionSerializableLegacy,\n} from '../../types/transaction.js'\nimport type {\n  Assign,\n  ExactPartial,\n  IsNever,\n  OneOf,\n  Opaque,\n} from '../../types/utils.js'\n\ntype BaseProperties = {\n  accessList?: undefined\n  blobs?: undefined\n  blobVersionedHashes?: undefined\n  gasPrice?: undefined\n  maxFeePerBlobGas?: undefined\n  maxFeePerGas?: undefined\n  maxPriorityFeePerGas?: undefined\n  sidecars?: undefined\n}\n\ntype LegacyProperties = Assign<BaseProperties, FeeValuesLegacy>\ntype EIP1559Properties = Assign<\n  BaseProperties,\n  OneOf<\n    | {\n        maxFeePerGas: FeeValuesEIP1559['maxFeePerGas']\n      }\n    | {\n        maxPriorityFeePerGas: FeeValuesEIP1559['maxPriorityFeePerGas']\n      },\n    FeeValuesEIP1559\n  > & {\n    accessList?: TransactionSerializableEIP2930['accessList'] | undefined\n  }\n>\ntype EIP2930Properties = Assign<\n  BaseProperties,\n  ExactPartial<FeeValuesLegacy> & {\n    accessList: TransactionSerializableEIP2930['accessList']\n  }\n>\ntype EIP4844Properties = Assign<\n  BaseProperties,\n  ExactPartial<FeeValuesEIP4844> &\n    OneOf<\n      | {\n          blobs: TransactionSerializableEIP4844['blobs']\n        }\n      | {\n          blobVersionedHashes: TransactionSerializableEIP4844['blobVersionedHashes']\n        }\n      | {\n          sidecars: TransactionSerializableEIP4844['sidecars']\n        },\n      TransactionSerializableEIP4844\n    >\n>\n\nexport type GetTransactionType<\n  transaction extends OneOf<\n    TransactionSerializableGeneric | TransactionRequestGeneric\n  > = TransactionSerializableGeneric,\n  result =\n    | (transaction extends\n        | Opaque<TransactionSerializableLegacy, transaction>\n        | Opaque<TransactionRequestLegacy, transaction>\n        | LegacyProperties\n        ? 'legacy'\n        : never)\n    | (transaction extends\n        | Opaque<TransactionSerializableEIP1559, transaction>\n        | Opaque<TransactionRequestEIP1559, transaction>\n        | EIP1559Properties\n        ? 'eip1559'\n        : never)\n    | (transaction extends\n        | Opaque<TransactionSerializableEIP2930, transaction>\n        | Opaque<TransactionRequestEIP2930, transaction>\n        | EIP2930Properties\n        ? 'eip2930'\n        : never)\n    | (transaction extends\n        | Opaque<TransactionSerializableEIP4844, transaction>\n        | Opaque<TransactionRequestEIP4844, transaction>\n        | EIP4844Properties\n        ? 'eip4844'\n        : never)\n    | (transaction['type'] extends string ? transaction['type'] : never),\n> = IsNever<result> extends false ? result : string\n\nexport type GetTransationTypeErrorType =\n  | InvalidSerializableTransactionErrorType\n  | ErrorType\n\nexport function getTransactionType<\n  const transaction extends OneOf<\n    TransactionSerializableGeneric | TransactionRequestGeneric\n  >,\n>(transaction: transaction): GetTransactionType<transaction> {\n  if (transaction.type)\n    return transaction.type as GetTransactionType<transaction>\n\n  if (\n    typeof transaction.blobs !== 'undefined' ||\n    typeof transaction.blobVersionedHashes !== 'undefined' ||\n    typeof transaction.maxFeePerBlobGas !== 'undefined' ||\n    typeof transaction.sidecars !== 'undefined'\n  )\n    return 'eip4844' as any\n\n  if (\n    typeof transaction.maxFeePerGas !== 'undefined' ||\n    typeof transaction.maxPriorityFeePerGas !== 'undefined'\n  ) {\n    return 'eip1559' as any\n  }\n\n  if (typeof transaction.gasPrice !== 'undefined') {\n    if (typeof transaction.accessList !== 'undefined') return 'eip2930' as any\n    return 'legacy' as any\n  }\n\n  throw new InvalidSerializableTransactionError({ transaction })\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CommitmentToVersionedHashErrorType,\n  commitmentToVersionedHash,\n} from './commitmentToVersionedHash.js'\n\ntype To = 'hex' | 'bytes'\n\nexport type CommitmentsToVersionedHashesParameters<\n  commitments extends readonly Uint8Array[] | readonly Hex[] =\n    | readonly Uint8Array[]\n    | readonly Hex[],\n  to extends To | undefined = undefined,\n> = {\n  /** Commitments from blobs. */\n  commitments: commitments | readonly Uint8Array[] | readonly Hex[]\n  /** Return type. */\n  to?: to | To | undefined\n  /** Version to tag onto the hashes. */\n  version?: number | undefined\n}\n\nexport type CommitmentsToVersionedHashesReturnType<to extends To> =\n  | (to extends 'bytes' ? readonly ByteArray[] : never)\n  | (to extends 'hex' ? readonly Hex[] : never)\n\nexport type CommitmentsToVersionedHashesErrorType =\n  | CommitmentToVersionedHashErrorType\n  | ErrorType\n\n/**\n * Transform a list of commitments to their versioned hashes.\n *\n * @example\n * ```ts\n * import {\n *   blobsToCommitments,\n *   commitmentsToVersionedHashes,\n *   toBlobs\n * } from 'viem'\n * import { kzg } from './kzg'\n *\n * const blobs = toBlobs({ data: '0x1234' })\n * const commitments = blobsToCommitments({ blobs, kzg })\n * const versionedHashes = commitmentsToVersionedHashes({ commitments })\n * ```\n */\nexport function commitmentsToVersionedHashes<\n  const commitments extends readonly Uint8Array[] | readonly Hex[],\n  to extends To =\n    | (commitments extends readonly Hex[] ? 'hex' : never)\n    | (commitments extends readonly ByteArray[] ? 'bytes' : never),\n>(\n  parameters: CommitmentsToVersionedHashesParameters<commitments, to>,\n): CommitmentsToVersionedHashesReturnType<to> {\n  const { commitments, version } = parameters\n\n  const to =\n    parameters.to ?? (typeof commitments[0] === 'string' ? 'hex' : 'bytes')\n\n  const hashes: Uint8Array[] | Hex[] = []\n  for (const commitment of commitments) {\n    hashes.push(\n      commitmentToVersionedHash({\n        commitment,\n        to,\n        version,\n      }) as any,\n    )\n  }\n  return hashes as any\n}\n","import { serializeTransaction } from \"viem\";\nimport { getContract } from \"../contract/contract.js\";\nimport { toSerializableTransaction } from \"../transaction/actions/to-serializable-transaction.js\";\nimport type { PreparedTransaction } from \"../transaction/prepare-transaction.js\";\nimport { readContract } from \"../transaction/read-contract.js\";\n\nexport type EstimateL1FeeOptions = {\n  transaction: PreparedTransaction;\n  gasPriceOracleAddress?: string;\n};\n\nconst OPStackGasPriceOracleAddress =\n  \"0x420000000000000000000000000000000000000F\";\n\n/**\n * @internal\n */\nexport async function estimateL1Fee(options: EstimateL1FeeOptions) {\n  const { transaction, gasPriceOracleAddress } = options;\n  const oracleContract = getContract({\n    client: transaction.client,\n    address: gasPriceOracleAddress || OPStackGasPriceOracleAddress,\n    chain: transaction.chain,\n  });\n\n  // purposefully remove gasPrice from the transaction\n\n  const { gasPrice, ...serializableTx } = await toSerializableTransaction({\n    transaction,\n  });\n  const serialized = serializeTransaction({\n    ...serializableTx,\n    type: \"eip1559\",\n  });\n  //serializeTransaction(transaction);\n  return readContract({\n    contract: oracleContract,\n    method: \"function getL1Fee(bytes memory _data) view returns (uint256)\",\n    params: [serialized],\n  });\n}\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CreateCursorErrorType,\n  type Cursor,\n  createCursor,\n} from '../cursor.js'\n\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\n\nexport type RecursiveArray<T> = T | readonly RecursiveArray<T>[]\n\ntype To = 'hex' | 'bytes'\n\ntype Encodable = {\n  length: number\n  encode(cursor: Cursor): void\n}\n\nexport type ToRlpReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type ToRlpErrorType =\n  | CreateCursorErrorType\n  | BytesToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\nexport function toRlp<to extends To = 'hex'>(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  const encodable = getEncodable(bytes)\n  const cursor = createCursor(new Uint8Array(encodable.length))\n  encodable.encode(cursor)\n\n  if (to === 'hex') return bytesToHex(cursor.bytes) as ToRlpReturnType<to>\n  return cursor.bytes as ToRlpReturnType<to>\n}\n\nexport type BytesToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function bytesToRlp<to extends To = 'bytes'>(\n  bytes: RecursiveArray<ByteArray>,\n  to: to | To | undefined = 'bytes',\n): ToRlpReturnType<to> {\n  return toRlp(bytes, to)\n}\n\nexport type HexToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function hexToRlp<to extends To = 'hex'>(\n  hex: RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  return toRlp(hex, to)\n}\n\nfunction getEncodable(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n): Encodable {\n  if (Array.isArray(bytes))\n    return getEncodableList(bytes.map((x) => getEncodable(x)))\n  return getEncodableBytes(bytes as any)\n}\n\nfunction getEncodableList(list: Encodable[]): Encodable {\n  const bodyLength = list.reduce((acc, x) => acc + x.length, 0)\n\n  const sizeOfBodyLength = getSizeOfLength(bodyLength)\n  const length = (() => {\n    if (bodyLength <= 55) return 1 + bodyLength\n    return 1 + sizeOfBodyLength + bodyLength\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bodyLength <= 55) {\n        cursor.pushByte(0xc0 + bodyLength)\n      } else {\n        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength)\n        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength)\n        else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength)\n        else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength)\n        else cursor.pushUint32(bodyLength)\n      }\n      for (const { encode } of list) {\n        encode(cursor)\n      }\n    },\n  }\n}\n\nfunction getEncodableBytes(bytesOrHex: ByteArray | Hex): Encodable {\n  const bytes =\n    typeof bytesOrHex === 'string' ? hexToBytes(bytesOrHex) : bytesOrHex\n\n  const sizeOfBytesLength = getSizeOfLength(bytes.length)\n  const length = (() => {\n    if (bytes.length === 1 && bytes[0] < 0x80) return 1\n    if (bytes.length <= 55) return 1 + bytes.length\n    return 1 + sizeOfBytesLength + bytes.length\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bytes.length === 1 && bytes[0] < 0x80) {\n        cursor.pushBytes(bytes)\n      } else if (bytes.length <= 55) {\n        cursor.pushByte(0x80 + bytes.length)\n        cursor.pushBytes(bytes)\n      } else {\n        cursor.pushByte(0x80 + 55 + sizeOfBytesLength)\n        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length)\n        else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length)\n        else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length)\n        else cursor.pushUint32(bytes.length)\n        cursor.pushBytes(bytes)\n      }\n    },\n  }\n}\n\nfunction getSizeOfLength(length: number) {\n  if (length < 2 ** 8) return 1\n  if (length < 2 ** 16) return 2\n  if (length < 2 ** 24) return 3\n  if (length < 2 ** 32) return 4\n  throw new BaseError('Length is too large.')\n}\n"],"names":["gweiUnits","ether","wei","formatUnits","value","decimals","display","toString","negative","startsWith","slice","padStart","integer","fraction","length","replace","concat","formatGwei","arguments","undefined","prettyPrint","args","entries","Object","map","_ref","key","filter","Boolean","maxLength","reduce","acc","_ref2","Math","max","_ref3","padEnd","join","BaseError","InvalidLegacyVError","constructor","_ref4","v","super","defineProperty","InvalidSerializableTransactionError","_ref5","transaction","metaMessages","InvalidStorageKeySizeError","_ref9","storageKey","floor","blobsToCommitments","parameters","_parameters$to","kzg","to","blobs","x","hexToBytes","commitments","blob","push","Uint8Array","from","blobToKzgCommitment","bytesToHex","blobsToProofs","proofs","i","commitment","computeBlobKzgProof","SHA2","Hash","blockLen","outputLen","padOffset","isLE","finished","pos","destroyed","this","buffer","view","createView","update","data","exists","len","toBytes","take","min","set","subarray","process","dataView","roundClean","digestInto","out","output","fill","byteOffset","setBigUint64","_32n","BigInt","_u32_max","wh","Number","wl","h","l","setUint32","oview","Error","outLen","state","get","digest","res","destroy","_cloneInto","Maj","a","b","c","SHA256_K","Uint32Array","IV","SHA256_W","SHA256","A","B","C","D","E","F","G","H","offset","getUint32","W15","W2","s0","rotr","s1","T1","T2","Chi","sha256","wrapConstructor","commitmentToVersionedHash","version","versionedHash","to_","bytes","noble_sha256","isHex","strict","toHex","bytesPerFieldElement","fieldElementsPerBlob","bytesPerBlob","maxBytesPerTransaction","versionedHashVersionKzg","BlobSizeTooLargeError","maxSize","size","EmptyBlobError","InvalidVersionedHashSizeError","hash","InvalidVersionedHashVersionError","toBlobSidecars","_parameters$blobs","_parameters$commitmen","_parameters$proofs","size_","active","position","createCursor","pushByte","pushBytes","toBlobs","sidecars","proof","InvalidChainIdError","chainId","ExecutionRevertedError","_message$replace","cause","message","reason","FeeCapTooHighError","maxFeePerGas","FeeCapTooLowError","NonceTooHighError","nonce","NonceTooLowError","NonceMaxValueError","InsufficientFundsError","IntrinsicGasTooHighError","gas","IntrinsicGasTooLowError","TransactionTypeNotSupportedError","TipAboveFeeCapError","maxPriorityFeePerGas","assertTransactionEIP1559","isAddress","InvalidAddressError","address","serializeAccessList","accessList","serializedAccessList","storageKeys","j","serializeTransaction","signature","type","blobVersionedHashes","maxFeePerBlobGas","gasPrice","getTransactionType","serializedTransaction","toYParitySignatureArray","concatHex","toRlp","serializeTransactionEIP1559","assertTransactionEIP2930","serializeTransactionEIP2930","_blobVersionedHashes","hexToNumber","assertTransactionEIP4844","hashes","commitmentsToVersionedHashes","serializeTransactionEIP4844","assertTransactionLegacy","r","s","serializeTransactionLegacy","yParity","trim","OPStackGasPriceOracleAddress","async","estimateL1Fee","options","gasPriceOracleAddress","oracleContract","getContract","client","chain","serializableTx","toSerializableTransaction","serialized","readContract","contract","method","params","encodable","getEncodable","cursor","encode","Array","isArray","list","bodyLength","sizeOfBodyLength","getSizeOfLength","pushUint8","pushUint16","pushUint24","pushUint32","getEncodableList","bytesOrHex","sizeOfBytesLength","getEncodableBytes"],"sourceRoot":""}