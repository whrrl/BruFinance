"use strict";(self.webpackChunkbru_finance=self.webpackChunkbru_finance||[]).push([[34042],{34042:(t,e,a)=>{a.d(e,{SmartWalletConnector:()=>K});var i=a(19532),r=a(3678),s=a(89106),n=a(19547),o=a(50992),c=a(2776),d=a(54612),h=a(38298),l=a(94385),u=a(10974),g=a(61059),p=a(81237),w=a(54322),m=a(48987),f=a(2614),y=a(73594),A=a(84406),v=a(29537),P=a(80267),T=a(84983),I=a(10019),b=a(63112),x=a(81274),G=a(17396),O=a(15452),C=a(3754);a(28379);async function U(t){const e=await r.resolveProperties(t);return Object.keys(e).map((t=>{let a=e[t];return"string"===typeof a&&a.startsWith("0x")||(a=s.hexValue(a)),[t,a]})).reduce(((t,e)=>{let[a,i]=e;return{...t,[a]:i}}),{})}const L=()=>{let t=(()=>{const t=BigInt(Math.floor(4294967296*Math.random())),e=BigInt(Math.floor(4294967296*Math.random())),a=BigInt(Math.floor(4294967296*Math.random())),i=BigInt(Math.floor(4294967296*Math.random())),r=BigInt(Math.floor(4294967296*Math.random())),s=BigInt(Math.floor(4294967296*Math.random()));return t<<BigInt(160)|e<<BigInt(128)|a<<BigInt(96)|i<<BigInt(64)|r<<BigInt(32)|s})().toString(16);return t.length%2!==0&&(t="0"+t),t="0x"+t,c.gH.from(s.concat([t,"0x0000000000000000"]))};class E{}class _{constructor(t,e,a,i,r){this.bundlerUrl=t,this.entryPointAddress=e,this.chainId=a;const s={};if((0,A.i)(this.bundlerUrl)){const t="undefined"!==typeof globalThis&&"APP_BUNDLE_ID"in globalThis?globalThis.APP_BUNDLE_ID:void 0;r?s["x-secret-key"]=r:i&&(s["x-client-id"]=i,t&&(s["x-bundle-id"]=t)),"undefined"!==typeof globalThis&&"TW_AUTH_TOKEN"in globalThis&&"string"===typeof globalThis.TW_AUTH_TOKEN&&(s.authorization="Bearer ".concat(globalThis.TW_AUTH_TOKEN)),"undefined"!==typeof globalThis&&"TW_CLI_AUTH_TOKEN"in globalThis&&"string"===typeof globalThis.TW_CLI_AUTH_TOKEN&&(s.authorization="Bearer ".concat(globalThis.TW_CLI_AUTH_TOKEN),s["x-authorize-wallet"]="true"),(0,v.s)(s)}this.userOpJsonRpcProvider=new d.B({url:this.bundlerUrl,headers:s},{name:"Connected bundler network",chainId:a}),this.initializing=this.validateChainId()}async validateChainId(){const t=await this.userOpJsonRpcProvider.send("eth_chainId",[]),e=parseInt(t);if(e!==this.chainId)throw new Error("bundler ".concat(this.bundlerUrl," is on chainId ").concat(e,", but provider is on chainId ").concat(this.chainId))}async sendUserOpToBundler(t){await this.initializing;const e=await U(t),a=[e,this.entryPointAddress];return await this.printUserOperation("eth_sendUserOperation",a),await this.userOpJsonRpcProvider.send("eth_sendUserOperation",[e,this.entryPointAddress])}async estimateUserOpGas(t){await this.initializing;const e=await U(t),a=[e,this.entryPointAddress];await this.printUserOperation("eth_estimateUserOperationGas",a);const i=await this.userOpJsonRpcProvider.send("eth_estimateUserOperationGas",[e,this.entryPointAddress]);return{preVerificationGas:c.gH.from(i.preVerificationGas),verificationGas:c.gH.from(i.verificationGas),verificationGasLimit:c.gH.from(i.verificationGasLimit),callGasLimit:c.gH.from(i.callGasLimit).add(P.M)}}async getUserOperationGasPrice(){return await this.initializing,await this.userOpJsonRpcProvider.send("thirdweb_getUserOperationGasPrice",[])}async getUserOperationReceipt(t){return await this.initializing,await this.userOpJsonRpcProvider.send("eth_getUserOperationReceipt",[t])}async printUserOperation(t,e){}}class D extends E{constructor(t,e,a,i){super(),this.paymasterUrl=t,this.entryPoint=e,this.clientId=a,this.secretKey=i}async getPaymasterAndData(t){const e={"Content-Type":"application/json"};if((0,A.i)(this.paymasterUrl)){if(this.secretKey&&this.clientId)throw new Error("Cannot use both secret key and client ID. Please use secretKey for server-side applications and clientId for client-side applications.");if(this.secretKey)e["x-secret-key"]=this.secretKey;else if(this.clientId){e["x-client-id"]=this.clientId;const t="undefined"!==typeof globalThis&&"APP_BUNDLE_ID"in globalThis?globalThis.APP_BUNDLE_ID:void 0;t&&(e["x-bundle-id"]=t)}"undefined"!==typeof globalThis&&"TW_AUTH_TOKEN"in globalThis&&"string"===typeof globalThis.TW_AUTH_TOKEN&&(e.authorization="Bearer ".concat(globalThis.TW_AUTH_TOKEN)),"undefined"!==typeof globalThis&&"TW_CLI_AUTH_TOKEN"in globalThis&&"string"===typeof globalThis.TW_CLI_AUTH_TOKEN&&(e.authorization="Bearer ".concat(globalThis.TW_CLI_AUTH_TOKEN),e["x-authorize-wallet"]="true"),(0,v.s)(e)}const a=await fetch(this.paymasterUrl,{method:"POST",headers:e,body:JSON.stringify({jsonrpc:"2.0",id:1,method:"pm_sponsorUserOperation",params:[await U(t),this.entryPoint]})}),i=await a.json();if(!a.ok){const t=i.error||a.statusText,e=i.code||"UNKNOWN";throw new Error("Paymaster error: ".concat(t,"\nStatus: ").concat(a.status,"\nCode: ").concat(e))}if(i.result)return"string"===typeof i.result?{paymasterAndData:i.result}:i.result;{var r;const t=(null===(r=i.error)||void 0===r?void 0:r.message)||i.error||a.statusText||"unknown error";throw new Error("Paymaster error from ".concat(this.paymasterUrl,": ").concat(t))}}}const H=(t,e,a,i)=>new D(t,e,a,i);class k{constructor(t,e,a,i,r,s,n){this.resolve=t,this.reject=e,this.entryPoint=a,this.sender=i,this.userOpHash=r,this.nonce=s,this.timeout=n,(0,I._)(this,"resolved",!1),this.boundLisener=this.listenerCallback.bind(this)}start(){const t=this.entryPoint.filters.UserOperationEvent(this.userOpHash);setTimeout((async()=>{const e=await this.entryPoint.queryFilter(t,-10);e.length>0?this.listenerCallback(e[0]):this.entryPoint.once(t,this.boundLisener)}),100)}stop(){this.entryPoint.off("UserOperationEvent",this.boundLisener)}async listenerCallback(){for(var t=arguments.length,e=new Array(t),a=0;a<t;a++)e[a]=arguments[a];const i=arguments[arguments.length-1];if(!i.args)return void console.error("got event without args",i);var r;if(i.args.userOpHash!==this.userOpHash)return void console.log("== event with wrong userOpHash: sender/nonce: event.".concat(i.args.sender,"@").concat(i.args.nonce.toString(),"!= userOp.").concat(this.sender,"@").concat(parseInt(null===(r=this.nonce)||void 0===r?void 0:r.toString())));const s=await i.getTransactionReceipt();i.args.success||await this.extractFailureReason(s),this.stop(),this.resolve(s),this.resolved=!0}async extractFailureReason(t){t.status=0;const e=await this.entryPoint.queryFilter(this.entryPoint.filters.UserOperationRevertReason(this.userOpHash,this.sender),t.blockHash);if(e[0]){let t=e[0].args.revertReason;t.startsWith("0x08c379a0")&&(t=o.D.decode(["string"],"0x"+t.substring(10)).toString()),this.reject(new Error("UserOp failed with reason: ".concat(t)))}}}class N extends h.Signer{constructor(t,e,a,i,s){super(),r.defineReadOnly(this,"provider",a),this.config=t,this.originalSigner=e,this.erc4337provider=a,this.httpRpcClient=i,this.smartAccountAPI=s,this.approving=!1}async sendTransaction(t,e){var a;if(!this.approving){this.approving=!0;const t=await this.smartAccountAPI.createApproveTx();t&&await(await this.sendTransaction(t)).wait(),this.approving=!1}const i=await r.resolveProperties(t);await this.verifyAllNecessaryFields(i);const s=L(),n=await this.smartAccountAPI.createUnsignedUserOp(this.httpRpcClient,{target:i.to||"",data:(null===(a=i.data)||void 0===a?void 0:a.toString())||"0x",value:i.value,gasLimit:i.gasLimit,nonce:s,maxFeePerGas:i.maxFeePerGas,maxPriorityFeePerGas:i.maxPriorityFeePerGas},e),o=await this.smartAccountAPI.signUserOp(n),c=await this.erc4337provider.constructUserOpTransactionResponse(o);try{await this.httpRpcClient.sendUserOpToBundler(o)}catch(d){throw this.unwrapError(d)}return c}unwrapError(t){try{let r="Unknown Error";if(t.error)r="The bundler has failed to include UserOperation in a batch: ".concat(t.error);else if(t.body&&"string"===typeof t.body){var e,a,i;const s=JSON.parse(t.body),n=t.status||"UNKNOWN",o=(null===s||void 0===s?void 0:s.code)||"UNKNOWN";let c=(null===s||void 0===s||null===(e=s.error)||void 0===e?void 0:e.message)||(null===s||void 0===s||null===(a=s.error)||void 0===a?void 0:a.data)||(null===s||void 0===s?void 0:s.error)||t.reason;if(null!==(i=c)&&void 0!==i&&i.includes("FailedOp")){let t="";const e=c.match(/FailedOp\((.*)\)/);if(e){const a=e[1].split(",");t="(paymaster address: ".concat(a[1],")"),c=a[2]}r="The bundler has failed to include UserOperation in a batch: ".concat(c," ").concat(t)}else r="RPC error: ".concat(c,"\nStatus: ").concat(n,"\nCode: ").concat(o)}const s=new Error(r);return s.stack=t.stack,s}catch(r){}return t}async verifyAllNecessaryFields(t){if(!t.to)throw new Error("Missing call target");if(!t.data&&!t.value)throw new Error("Missing call data or value")}connect(t){throw new Error("changing providers is not supported")}async getAddress(){return this.address||(this.address=await this.erc4337provider.getSenderAccountAddress()),this.address}async signMessage(t){if(await this.smartAccountAPI.checkAccountPhantom()){console.log("Account contract not deployed yet. Deploying account before signing message");const t=await this.sendTransaction({to:await this.getAddress(),data:"0x"});await t.wait()}const[e,a]=await Promise.all([this.getChainId(),this.getAddress()]),i=l.A(t);let r,s;const n=(0,O.Q)(e,this.config.clientId),c={};if((0,A.i)(n)){const t="undefined"!==typeof globalThis&&"APP_BUNDLE_ID"in globalThis?globalThis.APP_BUNDLE_ID:void 0;this.config.secretKey?c["x-secret-key"]=this.config.secretKey:this.config.clientId&&(c["x-client-id"]=this.config.clientId,t&&(c["x-bundle-id"]=t)),"undefined"!==typeof globalThis&&"TW_AUTH_TOKEN"in globalThis&&"string"===typeof globalThis.TW_AUTH_TOKEN&&(c.authorization="Bearer ".concat(globalThis.TW_AUTH_TOKEN)),"undefined"!==typeof globalThis&&"TW_CLI_AUTH_TOKEN"in globalThis&&"string"===typeof globalThis.TW_CLI_AUTH_TOKEN&&(c.authorization="Bearer ".concat(globalThis.TW_CLI_AUTH_TOKEN),c["x-authorize-wallet"]="true"),(0,v.s)(c)}try{const t=new d.B({url:n,headers:c},e),s=new u.NZ(a,["function getMessageHash(bytes32 _hash) public view returns (bytes32)"],t);await s.getMessageHash(i),r=!0}catch{r=!1}if(r){s=(await(0,b.aN)(this,{name:"Account",version:"1",chainId:e,verifyingContract:a},{AccountMessage:[{name:"message",type:"bytes"}]},{message:o.D.encode(["bytes32"],[i])})).signature}else s=await this.originalSigner.signMessage(t);if(await(0,P.c)(t,s,a,e,this.config.clientId,this.config.secretKey))return s;throw new Error("Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.")}async signTransaction(t,e){var a;const i=await r.resolveProperties(t);await this.verifyAllNecessaryFields(i);const s=L(),n=await this.smartAccountAPI.createUnsignedUserOp(this.httpRpcClient,{target:i.to||"",data:(null===(a=i.data)||void 0===a?void 0:a.toString())||"0x",value:i.value,gasLimit:i.gasLimit,nonce:s},e),o=await this.smartAccountAPI.signUserOp(n);return JSON.stringify(await U(o))}}class F extends g.DJ{constructor(t,e,a,i,r,s,n){super({name:"ERC-4337 Custom Network",chainId:t}),this.chainId=t,this.config=e,this.originalSigner=a,this.originalProvider=i,this.httpRpcClient=r,this.entryPoint=s,this.smartAccountAPI=n,this.signer=new N(e,a,this,r,n)}getSigner(){return this.signer}async perform(t,e){if("sendTransaction"===t||"getTransactionReceipt"===t)throw new Error("Should not get here. Investigate.");return"estimateGas"===t?c.gH.from(5e5):await this.originalProvider.perform(t,e)}async getTransaction(t){return await super.getTransaction(t)}async getTransactionReceipt(t){const e=await t,a=await this.getSenderAccountAddress();return await new Promise(((t,i)=>{new k(t,i,this.entryPoint,a,e).start()}))}async getSenderAccountAddress(){return await this.smartAccountAPI.getAccountAddress()}async waitForTransaction(t,e,a){const i=await this.getSenderAccountAddress();return await new Promise(((e,r)=>{new k(e,r,this.entryPoint,i,t,void 0,a).start()}))}async constructUserOpTransactionResponse(t){const e=await r.resolveProperties(t),a=await this.smartAccountAPI.getUserOpHash(e);return{hash:a,confirmations:0,from:e.sender,nonce:0,gasLimit:c.gH.from(e.callGasLimit),value:c.gH.from(0),data:s.hexValue(e.callData),chainId:this.chainId,wait:async t=>{const i=await this.smartAccountAPI.getUserOpReceipt(this.httpRpcClient,a);return 0!==e.initCode.length&&await this.smartAccountAPI.checkAccountPhantom(),i}}}async detectNetwork(){return this.originalProvider.detectNetwork()}}class B{constructor(t){(0,I._)(this,"isPhantom",!0),this.provider=t.provider,this.entryPointAddress=t.entryPointAddress,this.accountAddress=t.accountAddress,this.paymasterAPI=t.paymasterAPI,this.gasless=t.gasless,this.erc20PaymasterAddress=t.erc20PaymasterAddress,this.erc20TokenAddress=t.erc20TokenAddress,this.entryPointView=T.EntryPoint__factory.connect(t.entryPointAddress,t.provider).connect(p.L)}async checkAccountPhantom(){if(!this.isPhantom)return this.isPhantom;return(await this.provider.getCode(this.getAccountAddress())).length>2&&(this.isPhantom=!1),this.isPhantom}async getInitCode(){return await this.checkAccountPhantom()?await this.getAccountInitCode():"0x"}async getVerificationGasLimit(){return 1e5}async getUserOpHash(t){const e=await this.provider.getNetwork().then((t=>t.chainId));return async function(t,e,a){const i=await r.resolveProperties(t),s={sender:i.sender,nonce:i.nonce,initCodeHash:n.keccak256(i.initCode),callDataHash:n.keccak256(i.callData),callGasLimit:i.callGasLimit,verificationGasLimit:i.verificationGasLimit,preVerificationGas:i.preVerificationGas,maxFeePerGas:i.maxFeePerGas,maxPriorityFeePerGas:i.maxPriorityFeePerGas,paymasterAndDataHash:n.keccak256(i.paymasterAndData)},c=o.D.encode([{components:[{type:"address",name:"sender"},{type:"uint256",name:"nonce"},{type:"bytes32",name:"initCodeHash"},{type:"bytes32",name:"callDataHash"},{type:"uint256",name:"callGasLimit"},{type:"uint256",name:"verificationGasLimit"},{type:"uint256",name:"preVerificationGas"},{type:"uint256",name:"maxFeePerGas"},{type:"uint256",name:"maxPriorityFeePerGas"},{type:"bytes32",name:"paymasterAndDataHash"}],name:"hashedUserOp",type:"tuple"}],[{...s}]),d=n.keccak256(c),h=o.D.encode(["bytes32","address","uint256"],[d,e,a]);return n.keccak256(h)}(t,this.entryPointAddress,e)}async getAccountAddress(){return this.senderAddress||(this.accountAddress?this.senderAddress=this.accountAddress:this.senderAddress=await this.getCounterFactualAddress()),this.senderAddress}async estimateCreationGas(t){if(!t||"0x"===t)return 0;const e=t.substring(0,42),a="0x"+t.substring(42);return await this.provider.estimateGas({to:e,data:a})}async createUnsignedUserOp(t,e,a){var i;let{maxFeePerGas:r,maxPriorityFeePerGas:s}=e;if((0,A.i)(t.bundlerUrl)){const e=await t.getUserOperationGasPrice();r=c.gH.from(e.maxFeePerGas),s=c.gH.from(e.maxPriorityFeePerGas)}else if(!r||!s){const t=await(0,x.a)(this.provider);var n;if(!s)s=null!==(n=t.maxPriorityFeePerGas)&&void 0!==n?n:void 0;if(!r){var o;r=null!==(o=t.maxFeePerGas)&&void 0!==o?o:void 0;const e=(await this.provider.getNetwork()).chainId;e!==C._yE.chainId&&e!==C.eLx.chainId&&e!==C.vyO.chainId||(s=r)}}if(!r||!s)throw new Error("maxFeePerGas or maxPriorityFeePerGas could not be calculated, please pass them explicitely");const[d,h]=await Promise.all([this.getAccountAddress(),e.nonce?Promise.resolve(e.nonce):this.getNonce()]),l=await this.getInitCode(),u=null!==(i=function(t){if(!t||""===t)return null;return c.gH.from(t.toString())}(e.value))&&void 0!==i?i:c.gH.from(0),g=null!==a&&void 0!==a&&a.batchData?e.data:await this.prepareExecute(e.target,u,e.data).then((async t=>(e.gasLimit||await this.provider.estimateGas({from:d,to:e.target,data:e.data,value:u}),t.encode()))),p={sender:d,nonce:h,initCode:l,callData:g,maxFeePerGas:r,maxPriorityFeePerGas:s,callGasLimit:c.gH.from(1e6),verificationGasLimit:c.gH.from(1e6),preVerificationGas:c.gH.from(1e6),paymasterAndData:"0x",signature:"0xfffffffffffffffffffffffffffffff0000000000000000000000000000000007aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1c"},w=void 0!==(null===a||void 0===a?void 0:a.gasless)?a.gasless:this.gasless;if(this.erc20PaymasterAddress&&this.erc20TokenAddress&&await this.isAccountApproved()){let e;p.paymasterAndData=this.erc20PaymasterAddress;try{e=await t.estimateUserOpGas(p)}catch(m){throw this.unwrapBundlerError(m)}p.callGasLimit=e.callGasLimit,p.verificationGasLimit=e.verificationGasLimit,p.preVerificationGas=e.preVerificationGas}else if(w){const e=await this.paymasterAPI.getPaymasterAndData(p),a=e.paymasterAndData;if(a&&"0x"!==a&&(p.paymasterAndData=a),e.callGasLimit&&e.verificationGasLimit&&e.preVerificationGas)p.callGasLimit=c.gH.from(e.callGasLimit),p.verificationGasLimit=c.gH.from(e.verificationGasLimit),p.preVerificationGas=c.gH.from(e.preVerificationGas);else{let e;try{e=await t.estimateUserOpGas(p)}catch(m){throw this.unwrapBundlerError(m)}if(p.callGasLimit=e.callGasLimit,p.verificationGasLimit=e.verificationGasLimit,p.preVerificationGas=e.preVerificationGas,a&&"0x"!==a){const t=await this.paymasterAPI.getPaymasterAndData(p);t.paymasterAndData&&"0x"!==t.paymasterAndData&&(p.paymasterAndData=t.paymasterAndData)}}}else{let e;try{e=await t.estimateUserOpGas(p)}catch(m){throw this.unwrapBundlerError(m)}p.callGasLimit=e.callGasLimit,p.verificationGasLimit=e.verificationGasLimit,p.preVerificationGas=e.preVerificationGas}return{...p,signature:""}}async signUserOp(t){const e=await this.getUserOpHash(t),a=await this.signUserOpHash(e);return{...t,signature:a}}async getUserOpReceipt(t,e){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:12e4,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e3;const r=Date.now()+a;for(;Date.now()<r;){const a=await t.getUserOperationReceipt(e);if(a)return await this.provider.waitForTransaction(a.receipt.transactionHash);await new Promise((t=>setTimeout(t,i)))}throw new Error("Timeout waiting for userOp to be mined")}unwrapBundlerError(t){var e;const a=(null===t||void 0===t||null===(e=t.error)||void 0===e?void 0:e.message)||t.error||t.message||t;return new Error(a)}}class S extends B{constructor(t,e){super({...t,provider:e}),this.params=t,this.sdk=G.T.fromPrivateKey(G.L,t.chain,{clientId:t.clientId,secretKey:t.secretKey,supportedChains:"object"===typeof t.chain?[t.chain]:void 0})}async getChainId(){return await this.provider.getNetwork().then((t=>t.chainId))}async getAccountContract(){var t;this.accountContract||(null!==(t=this.params.accountInfo)&&void 0!==t&&t.abi?this.accountContract=await this.sdk.getContract(await this.getAccountAddress(),this.params.accountInfo.abi):this.accountContract=await this.sdk.getContract(await this.getAccountAddress(),P.A));return this.accountContract}async getAccountInitCode(){const t=await this.getFactoryContract(),e=await this.params.localSigner.getAddress(),a=await this.params.factoryInfo.createAccount(t,e);return s.hexConcat([t.getAddress(),a.encode()])}async getFactoryContract(){var t;return this.factoryContract||(null!==(t=this.params.factoryInfo)&&void 0!==t&&t.abi?this.factoryContract=await this.sdk.getContract(this.params.factoryAddress,this.params.factoryInfo.abi):this.factoryContract=await this.sdk.getContract(this.params.factoryAddress)),this.factoryContract}async getCounterFactualAddress(){if(this.params.accountAddress)return this.params.accountAddress;const t=await this.getFactoryContract(),e=await this.params.localSigner.getAddress();return this.params.factoryInfo.getAccountAddress(t,e)}async getNonce(){if(await this.checkAccountPhantom())return c.gH.from(0);const t=await this.getAccountContract();return this.params.accountInfo.getNonce(t)}async prepareExecute(t,e,a){const i=await this.getAccountContract();return this.params.accountInfo.execute(i,t,e,a)}async prepareExecuteBatch(t,e,a){return(await this.getAccountContract()).prepare("executeBatch",[t,e,a])}async signUserOpHash(t){return await this.params.localSigner.signMessage(s.arrayify(t))}async isAcountDeployed(){return!await this.checkAccountPhantom()}async isAccountApproved(){if(!this.params.erc20PaymasterAddress||!this.params.erc20TokenAddress)return!0;const t=await this.getCounterFactualAddress(),e=(await Promise.resolve().then(a.t.bind(a,96337,19))).default,i=await this.sdk.getContract(this.params.erc20TokenAddress,e);return(await i.call("allowance",[t,this.params.erc20PaymasterAddress])).gte(c.gH.from(2).pow(96).sub(1))}async createApproveTx(){if(await this.isAccountApproved())return;const t=c.gH.from(2).pow(96).sub(1),e=new w.Wallet(G.L,this.provider),a=new u.NZ(this.params.erc20TokenAddress,["function approve(address spender, uint256 amount) public returns (bool)"],e);return{to:this.params.erc20TokenAddress,from:await this.getAccountAddress(),value:0,data:a.interface.encodeFunctionData("approve",[this.params.erc20PaymasterAddress,t])}}}class K extends i.C{constructor(t){super(),this.config=t}async initialize(t){var e,a,i,r,s,n;const o=this.config,c=(0,b.a$)(o.chain,{clientId:o.clientId,secretKey:o.secretKey});this.chainId=(await c.getNetwork()).chainId;const d=this.config.bundlerUrl||"https://".concat(this.chainId,".bundler.thirdweb.com"),h=this.config.paymasterUrl||"https://".concat(this.chainId,".bundler.thirdweb.com"),l=o.entryPointAddress||P.E,u=await t.personalWallet.getSigner(),g={chain:o.chain,localSigner:u,entryPointAddress:l,bundlerUrl:d,paymasterAPI:this.config.paymasterAPI?this.config.paymasterAPI:H(h,l,this.config.clientId,this.config.secretKey),gasless:o.gasless,factoryAddress:o.factoryAddress,accountAddress:t.accountAddress,factoryInfo:{createAccount:(null===(e=o.factoryInfo)||void 0===e?void 0:e.createAccount)||this.defaultFactoryInfo().createAccount,getAccountAddress:(null===(a=o.factoryInfo)||void 0===a?void 0:a.getAccountAddress)||this.defaultFactoryInfo().getAccountAddress,abi:null===(i=o.factoryInfo)||void 0===i?void 0:i.abi},accountInfo:{execute:(null===(r=o.accountInfo)||void 0===r?void 0:r.execute)||this.defaultAccountInfo().execute,getNonce:(null===(s=o.accountInfo)||void 0===s?void 0:s.getNonce)||this.defaultAccountInfo().getNonce,abi:null===(n=o.accountInfo)||void 0===n?void 0:n.abi},clientId:o.clientId,secretKey:o.secretKey,erc20PaymasterAddress:o.erc20PaymasterAddress,erc20TokenAddress:o.erc20TokenAddress};this.personalWallet=t.personalWallet;const p=new S(g,c);this.aaProvider=function(t,e,a,i){const r=T.EntryPoint__factory.connect(t.entryPointAddress,a),s=new _(t.bundlerUrl,t.entryPointAddress,i,t.clientId,t.secretKey);return new F(i,t,t.localSigner,a,s,r,e)}(g,p,c,this.chainId),this.accountApi=p}async connect(t){return await this.initialize(t),await this.getAddress()}getProvider(){if(!this.aaProvider)throw new Error("Personal wallet not connected");return Promise.resolve(this.aaProvider)}async getSigner(){if(!this.aaProvider)throw new Error("Personal wallet not connected");return Promise.resolve(this.aaProvider.getSigner())}async getAddress(){return(await this.getSigner()).getAddress()}async isConnected(){try{return!!await this.getAddress()}catch(t){return!1}}async disconnect(){this.personalWallet=void 0,this.aaProvider=void 0}async switchChain(t){const e=await this.getProvider();if((await e.getNetwork()).chainId!==t)throw new Error("Not supported.")}setupListeners(){return Promise.resolve()}updateChains(t){}async hasPermissionToExecute(t){var e;const a=await this.getAccountContract(),i=await this.getSigner(),r=await i.getAddress(),s=null===(e=(await a.account.getAllSigners()).filter((t=>m.getAddress(t.signer)===m.getAddress(r)))[0])||void 0===e?void 0:e.permissions;return!!s&&s.approvedCallTargets.includes(t.getTarget())}async send(t,e){return(await this.getSigner()).sendTransaction({to:t.getTarget(),data:t.encode(),value:await t.getValue()},e)}async execute(t,e){const a=await this.send(t,e);return{receipt:await a.wait()}}async sendBatch(t,e){if(!this.accountApi)throw new Error("Personal wallet not connected");const a=await this.getSigner(),{tx:i,batchData:r}=await this.prepareBatchTx(t);return await a.sendTransaction({to:await a.getAddress(),data:i.encode(),value:0},{...e,batchData:r})}async executeBatch(t,e){const a=await this.sendBatch(t,e);return{receipt:await a.wait()}}async sendRaw(t,e){if(!this.accountApi)throw new Error("Personal wallet not connected");return(await this.getSigner()).sendTransaction(t,e)}async executeRaw(t,e){const a=await this.sendRaw(t,e);return{receipt:await a.wait()}}async sendBatchRaw(t,e){if(!this.accountApi)throw new Error("Personal wallet not connected");const a=await this.getSigner(),i=await this.prepareBatchRaw(t);return a.sendTransaction({to:await a.getAddress(),data:i.tx.encode(),value:0},{...e,batchData:i.batchData})}async executeBatchRaw(t,e){const a=await this.sendBatchRaw(t,e);return{receipt:await a.wait()}}async estimate(t,e){if(!this.accountApi)throw new Error("Personal wallet not connected");return this.estimateTx({target:t.getTarget(),data:t.encode(),value:await t.getValue(),gasLimit:await t.getOverrides().gasLimit,maxFeePerGas:await t.getOverrides().maxFeePerGas,maxPriorityFeePerGas:await t.getOverrides().maxPriorityFeePerGas,nonce:await t.getOverrides().nonce},e)}async estimateRaw(t,e){var a;if(!this.accountApi)throw new Error("Personal wallet not connected");const i=await r.resolveProperties(t);return this.estimateTx({target:i.to||p.L,data:(null===(a=i.data)||void 0===a?void 0:a.toString())||"",value:i.value||c.gH.from(0),gasLimit:i.gasLimit,maxFeePerGas:i.maxFeePerGas,maxPriorityFeePerGas:i.maxPriorityFeePerGas,nonce:i.nonce},e)}async estimateBatch(t,e){if(!this.accountApi)throw new Error("Personal wallet not connected");const{tx:a,batchData:i}=await this.prepareBatchTx(t);return this.estimateTx({target:a.getTarget(),data:a.encode(),value:await a.getValue(),gasLimit:await a.getOverrides().gasLimit,maxFeePerGas:await a.getOverrides().maxFeePerGas,maxPriorityFeePerGas:await a.getOverrides().maxPriorityFeePerGas,nonce:await a.getOverrides().nonce},{...e,batchData:i})}async estimateBatchRaw(t,e){if(!this.accountApi)throw new Error("Personal wallet not connected");const{tx:a,batchData:i}=await this.prepareBatchRaw(t);return this.estimateTx({target:a.getTarget(),data:a.encode(),value:await a.getValue(),gasLimit:await a.getOverrides().gasLimit,maxFeePerGas:await a.getOverrides().maxFeePerGas,maxPriorityFeePerGas:await a.getOverrides().maxPriorityFeePerGas,nonce:await a.getOverrides().nonce},{...e,batchData:i})}async deploy(t){if(!this.accountApi)throw new Error("Personal wallet not connected");const e=await this.getSigner(),a=await e.sendTransaction({to:await e.getAddress(),data:"0x"},{...t,batchData:{targets:[],data:[],values:[]}});return{receipt:await a.wait()}}async isDeployed(){if(!this.accountApi)throw new Error("Personal wallet not connected");return await this.accountApi.isAcountDeployed()}async deployIfNeeded(t){await this.isDeployed()||await this.deploy(t)}async grantPermissions(t,e){return(await this.getAccountContract()).account.grantPermissions(t,e)}async revokePermissions(t){return(await this.getAccountContract()).account.revokeAccess(t)}async addAdmin(t){return(await this.getAccountContract()).account.grantAdminPermissions(t)}async removeAdmin(t){return(await this.getAccountContract()).account.revokeAdminPermissions(t)}async getAllActiveSigners(){if(await this.isDeployed()){return(await this.getAccountContract()).account.getAllAdminsAndSigners()}{var t;const e=await(null===(t=this.personalWallet)||void 0===t?void 0:t.getSigner());if(!e)throw new Error("Personal wallet not connected");return[{isAdmin:!0,signer:await e.getAddress(),permissions:{startDate:new Date(0),expirationDate:new Date(0),nativeTokenLimitPerTransaction:c.gH.from(0),approvedCallTargets:[]}}]}}async getAccountContract(){var t;const e=G.T.fromSigner(await this.getSigner(),this.config.chain,{clientId:this.config.clientId,secretKey:this.config.secretKey});return null!==(t=this.config.accountInfo)&&void 0!==t&&t.abi?e.getContract(await this.getAddress(),this.config.accountInfo.abi):e.getContract(await this.getAddress(),P.A)}async getFactoryContract(){var t;const e=G.T.fromSigner(await this.getSigner(),this.config.chain,{clientId:this.config.clientId,secretKey:this.config.secretKey});return null!==(t=this.config.factoryInfo)&&void 0!==t&&t.abi?e.getContract(this.config.factoryAddress,this.config.factoryInfo.abi):e.getContract(this.config.factoryAddress)}defaultFactoryInfo(){return{createAccount:async(t,e)=>t.prepare("createAccount",[e,f.YW("")]),getAccountAddress:async(t,e)=>await t.call("getAddress",[e,f.YW("")])}}defaultAccountInfo(){return{execute:async(t,e,a,i)=>t.prepare("execute",[e,a,i]),getNonce:async t=>t.call("getNonce",[])}}async estimateTx(t,e){if(!this.accountApi||!this.aaProvider)throw new Error("Personal wallet not connected");let a=c.gH.from(0);const[i,s]=await Promise.all([this.getProvider(),this.isDeployed()]);s||(a=await this.estimateDeploymentGasLimit());const[n,o]=await Promise.all([this.accountApi.createUnsignedUserOp(this.aaProvider.httpRpcClient,t,e),(0,x.b)(i)]),d=await r.resolveProperties(n),h=c.gH.from(d.callGasLimit),l=h.mul(o),u=a.mul(o),g=u.add(l);return{ether:y.formatEther(g),wei:g,details:{deployGasLimit:a,transactionGasLimit:h,gasPrice:o,transactionCost:l,deployCost:u,totalCost:g}}}async estimateDeploymentGasLimit(){if(!this.accountApi)throw new Error("Personal wallet not connected");const t=await this.accountApi.getInitCode(),[e,a]=await Promise.all([this.accountApi.estimateCreationGas(t),this.accountApi.getVerificationGasLimit()]);return c.gH.from(a).add(e)}async prepareBatchRaw(t){if(!this.accountApi)throw new Error("Personal wallet not connected");const e=await Promise.all(t.map((t=>r.resolveProperties(t)))),a=e.map((t=>t.to||p.L)),i=e.map((t=>t.data||"0x")),s=e.map((t=>t.value||c.gH.from(0)));return{tx:await this.accountApi.prepareExecuteBatch(a,s,i),batchData:{targets:a,data:i,values:s}}}async prepareBatchTx(t){if(!this.accountApi)throw new Error("Personal wallet not connected");const e=t.map((t=>t.getTarget())),a=t.map((t=>t.encode())),i=await Promise.all(t.map((t=>t.getValue())));return{tx:await this.accountApi.prepareExecuteBatch(e,i,a),batchData:{targets:e,data:a,values:i}}}}}}]);
//# sourceMappingURL=34042.852d7837.chunk.js.map