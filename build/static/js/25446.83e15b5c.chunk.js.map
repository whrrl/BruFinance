{"version":3,"file":"static/js/25446.83e15b5c.chunk.js","mappings":"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","sources":["../node_modules/thirdweb/src/utils/signatures/helpers/parseTypedData.ts","../node_modules/thirdweb/src/utils/bigint.ts","../node_modules/thirdweb/src/transaction/actions/zksync/getEip721Domain.ts","../node_modules/thirdweb/src/transaction/actions/zksync/send-eip712-transaction.ts","../node_modules/thirdweb/src/utils/encoding/helpers/concat-hex.ts","../node_modules/thirdweb/node_modules/viem/utils/hash/toEventSelector.ts","../node_modules/thirdweb/node_modules/viem/utils/abi/decodeEventLog.ts","../node_modules/thirdweb/node_modules/viem/utils/abi/parseEventLogs.ts","../node_modules/thirdweb/node_modules/viem/errors/log.ts","../node_modules/thirdweb/node_modules/viem/utils/abi/getAbiItem.ts","../node_modules/thirdweb/node_modules/viem/utils/abi/encodeEventTopics.ts","../node_modules/thirdweb/src/extensions/erc4337/__generated__/IEntryPoint/events/UserOperationRevertReason.ts","../node_modules/thirdweb/src/event/prepare-event.ts","../node_modules/thirdweb/src/event/utils.ts","../node_modules/thirdweb/src/chains/chain-definitions/zksync-sepolia.ts","../node_modules/thirdweb/src/chains/chain-definitions/zksync.ts","../node_modules/thirdweb/src/wallets/smart/lib/utils.ts","../node_modules/thirdweb/src/wallets/smart/lib/bundler.ts","../node_modules/thirdweb/src/event/actions/parse-logs.ts","../node_modules/thirdweb/src/wallets/smart/lib/paymaster.ts","../node_modules/thirdweb/src/wallets/smart/lib/userop.ts","../node_modules/thirdweb/src/wallets/smart/lib/calls.ts","../node_modules/thirdweb/src/wallets/smart/index.ts","../node_modules/thirdweb/node_modules/viem/utils/encoding/toRlp.ts","../node_modules/thirdweb/node_modules/viem/utils/signature/hashTypedData.ts","../node_modules/thirdweb/node_modules/viem/utils/regex.ts","../node_modules/thirdweb/node_modules/viem/utils/typedData.ts"],"sourcesContent":["import type { TypedData } from \"abitype\";\nimport type { TypedDataDefinition } from \"viem\";\nimport { type Hex, hexToNumber, isHex } from \"../../encoding/hex.js\";\n\ntype UnknownDomain = unknown & { chainId?: unknown }; // TODO: create our own typed data types so this is cleaner\ntype HexDomain = unknown & { chainId: Hex }; // TODO: create our own typed data types so this is cleaner\n\n/**\n * @internal\n */\nexport function parseTypedData<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n>(\n  typedData: TypedDataDefinition<typedData, primaryType>,\n): TypedDataDefinition<typedData, primaryType> {\n  const domain = typedData.domain as UnknownDomain;\n  if (domain?.chainId !== undefined && isHex(domain.chainId)) {\n    typedData.domain = {\n      ...(typedData.domain as HexDomain),\n      chainId: hexToNumber((typedData.domain as unknown as HexDomain).chainId),\n    } as unknown as TypedDataDefinition<typedData, primaryType>[\"domain\"];\n  }\n  return typedData;\n}\n","import { uint8ArrayToHex } from \"./encoding/hex.js\";\n\n/**\n * Returns the minimum of two BigInt values.\n * @param a - The first BigInt value.\n * @param b - The second BigInt value.\n * @returns The smaller of the two BigInt values.\n * @example\n * ```ts\n * min(1n, 2n)\n * // 1n\n */\nexport function min(a: bigint, b: bigint) {\n  return a < b ? a : b;\n}\n\n/**\n * Returns the maximum of two BigInt values.\n * @param a - The first BigInt value.\n * @param b - The second BigInt value.\n * @returns The larger of the two BigInt values.\n * @example\n * ```ts\n * max(1n, 2n)\n * // 2n\n */\nexport function max(a: bigint, b: bigint) {\n  return a > b ? a : b;\n}\n\n/**\n * Provides error checking on string or number bigint inputs.\n * @param value - A possibly integer-like string, number, or bigint.\n * @returns The bigint representation of the input.\n * @example\n * ```ts\n * toBigInt(\"2\")\n * // 2n\n */\nexport function toBigInt(value: string | number | bigint | Uint8Array): bigint {\n  if (\n    [\"string\", \"number\"].includes(typeof value) &&\n    !Number.isInteger(Number(value))\n  ) {\n    throw new Error(\n      `Expected value to be an integer to convert to a bigint, got ${value} of type ${typeof value}`,\n    );\n  }\n\n  if (value instanceof Uint8Array) {\n    return BigInt(uint8ArrayToHex(value));\n  }\n\n  return BigInt(value);\n}\n","import type { TransactionSerializable } from \"viem\";\nimport type { Address } from \"../../../utils/address.js\";\nimport type {\n  EIP721SerializedTransaction,\n  EIP721TransactionOptions,\n} from \"../../prepare-transaction.js\";\n\nexport type EIP721TransactionSerializable = TransactionSerializable & {\n  from: Address;\n} & EIP721TransactionOptions;\nexport const gasPerPubdataDefault = 50000n;\n\nexport const getEip712Domain = (transaction: EIP721TransactionSerializable) => {\n  const message = transactionToMessage(transaction);\n\n  return {\n    domain: {\n      name: \"zkSync\",\n      version: \"2\",\n      chainId: transaction.chainId,\n    },\n    types: {\n      Transaction: [\n        { name: \"txType\", type: \"uint256\" },\n        { name: \"from\", type: \"uint256\" },\n        { name: \"to\", type: \"uint256\" },\n        { name: \"gasLimit\", type: \"uint256\" },\n        { name: \"gasPerPubdataByteLimit\", type: \"uint256\" },\n        { name: \"maxFeePerGas\", type: \"uint256\" },\n        { name: \"maxPriorityFeePerGas\", type: \"uint256\" },\n        { name: \"paymaster\", type: \"uint256\" },\n        { name: \"nonce\", type: \"uint256\" },\n        { name: \"value\", type: \"uint256\" },\n        { name: \"data\", type: \"bytes\" },\n        { name: \"factoryDeps\", type: \"bytes32[]\" },\n        { name: \"paymasterInput\", type: \"bytes\" },\n      ],\n    },\n    primaryType: \"Transaction\",\n    message: message,\n  };\n};\n\nfunction transactionToMessage(\n  transaction: EIP721TransactionSerializable,\n): EIP721SerializedTransaction {\n  const {\n    gas,\n    nonce,\n    to,\n    from,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    paymaster,\n    paymasterInput,\n    gasPerPubdata,\n    data,\n  } = transaction;\n\n  return {\n    txType: 113n,\n    from: BigInt(from),\n    to: to ? BigInt(to) : 0n,\n    gasLimit: gas ?? 0n,\n    gasPerPubdataByteLimit: gasPerPubdata ?? gasPerPubdataDefault,\n    maxFeePerGas: maxFeePerGas ?? 0n,\n    maxPriorityFeePerGas: maxPriorityFeePerGas ?? 0n,\n    paymaster: paymaster ? BigInt(paymaster) : 0n,\n    nonce: nonce ? BigInt(nonce) : 0n,\n    value: value ?? 0n,\n    data: data ? data : \"0x0\",\n    // TODO suport factoryDeps\n    factoryDeps: [],\n    paymasterInput: paymasterInput ? paymasterInput : \"0x\",\n  };\n}\n","import { toRlp } from \"viem\";\nimport { eth_sendRawTransaction } from \"../../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../../rpc/rpc.js\";\nimport { toBigInt } from \"../../../utils/bigint.js\";\nimport { concatHex } from \"../../../utils/encoding/helpers/concat-hex.js\";\nimport { type Hex, numberToHex, toHex } from \"../../../utils/encoding/hex.js\";\nimport { resolvePromisedValue } from \"../../../utils/promise/resolve-promised-value.js\";\nimport type { Account } from \"../../../wallets/interfaces/wallet.js\";\nimport type { PreparedTransaction } from \"../../prepare-transaction.js\";\nimport { encode } from \"../encode.js\";\nimport { toSerializableTransaction } from \"../to-serializable-transaction.js\";\nimport type { WaitForReceiptOptions } from \"../wait-for-tx-receipt.js\";\nimport {\n  type EIP721TransactionSerializable,\n  gasPerPubdataDefault,\n  getEip712Domain,\n} from \"./getEip721Domain.js\";\n\nexport type SendEip712TransactionOptions = {\n  account: Account;\n  // TODO: update this to `Transaction<\"prepared\">` once the type is available to ensure only prepared transactions are accepted\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any prepared transaction type\n  transaction: PreparedTransaction<any>;\n};\n\n/**\n * Sends a transaction using the provided wallet.\n * @param options - The options for sending the transaction.\n * @returns A promise that resolves to the transaction hash.\n * @throws An error if the wallet is not connected.\n * @transaction\n * @example\n * ```ts\n * import { sendTransaction } from \"thirdweb\";\n *\n * const { transactionHash } = await sendTransaction({\n *  account,\n *  transaction\n * });\n * ```\n */\nexport async function sendEip712Transaction(\n  options: SendEip712TransactionOptions,\n): Promise<WaitForReceiptOptions> {\n  const { account, transaction } = options;\n\n  const eip712Transaction = await populateEip712Transaction(options);\n\n  const hash = await signEip712Transaction({\n    account,\n    eip712Transaction,\n    chainId: transaction.chain.id,\n  });\n\n  const rpc = getRpcClient(transaction);\n  const result = await eth_sendRawTransaction(rpc, hash);\n\n  return {\n    transactionHash: result,\n    chain: transaction.chain,\n    client: transaction.client,\n  };\n}\n\nexport async function signEip712Transaction(options: {\n  account: Account;\n  eip712Transaction: EIP721TransactionSerializable;\n  chainId: number;\n}): Promise<Hex> {\n  const { account, eip712Transaction, chainId } = options;\n  // EIP712 signing of the serialized tx\n  const eip712Domain = getEip712Domain(eip712Transaction);\n\n  const customSignature = await account.signTypedData({\n    // biome-ignore lint/suspicious/noExplicitAny: TODO type properly\n    ...(eip712Domain as any),\n  });\n\n  return serializeTransactionEIP712({\n    ...eip712Transaction,\n    chainId,\n    customSignature,\n  });\n}\n\nexport async function populateEip712Transaction(\n  options: SendEip712TransactionOptions,\n): Promise<EIP721TransactionSerializable> {\n  const { account, transaction } = options;\n  let [\n    data,\n    to,\n    value,\n    gas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    gasPerPubdata,\n  ] = await Promise.all([\n    encode(transaction),\n    resolvePromisedValue(transaction.to),\n    resolvePromisedValue(transaction.value),\n    resolvePromisedValue(transaction.gas),\n    resolvePromisedValue(transaction.maxFeePerGas),\n    resolvePromisedValue(transaction.maxPriorityFeePerGas),\n    resolvePromisedValue(transaction.eip712).then(\n      (eip712) => eip712?.gasPerPubdata,\n    ),\n  ]);\n  if (!gas || !maxFeePerGas || !maxPriorityFeePerGas) {\n    // fetch fees and gas\n    const rpc = getRpcClient(transaction);\n    const result = (await rpc({\n      // biome-ignore lint/suspicious/noExplicitAny: TODO add to RPC method types\n      method: \"zks_estimateFee\" as any,\n      params: [\n        {\n          from: account.address,\n          to,\n          data,\n          value: value ? numberToHex(value) : undefined,\n          // biome-ignore lint/suspicious/noExplicitAny: TODO add to RPC method types\n        } as any,\n      ],\n    })) as {\n      gas_limit: string;\n      max_fee_per_gas: string;\n      max_priority_fee_per_gas: string;\n      gas_per_pubdata_limit: string;\n    };\n    gas = toBigInt(result.gas_limit);\n    const baseFee = toBigInt(result.max_fee_per_gas);\n    maxFeePerGas = baseFee * 2n; // bumping the base fee per gas to ensure fast inclusion\n    maxPriorityFeePerGas = toBigInt(result.max_priority_fee_per_gas) || 1n;\n    gasPerPubdata = toBigInt(result.gas_per_pubdata_limit);\n  }\n\n  // serialize the transaction (with fees, gas, nonce)\n  const serializableTransaction = await toSerializableTransaction({\n    transaction: {\n      ...transaction,\n      gas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    },\n    from: account.address,\n  });\n\n  return {\n    ...serializableTransaction,\n    ...transaction.eip712,\n    gasPerPubdata,\n    from: account.address as Hex,\n  };\n}\n\nfunction serializeTransactionEIP712(\n  transaction: EIP721TransactionSerializable & {\n    chainId: number;\n    customSignature: Hex;\n  },\n): Hex {\n  const {\n    chainId,\n    gas,\n    nonce,\n    to,\n    from,\n    value,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    customSignature,\n    factoryDeps,\n    paymaster,\n    paymasterInput,\n    gasPerPubdata,\n    data,\n  } = transaction;\n\n  const serializedTransaction = [\n    nonce ? toHex(nonce) : \"0x\",\n    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : \"0x\",\n    maxFeePerGas ? toHex(maxFeePerGas) : \"0x\",\n    gas ? toHex(gas) : \"0x\",\n    to ?? \"0x\",\n    value ? toHex(value) : \"0x\",\n    data ?? \"0x0\",\n    toHex(chainId),\n    toHex(\"\"),\n    toHex(\"\"),\n    toHex(chainId),\n    from ?? \"0x\",\n    gasPerPubdata ? toHex(gasPerPubdata) : toHex(gasPerPubdataDefault),\n    factoryDeps ?? [],\n    customSignature ?? \"0x\", // EIP712 signature\n    paymaster && paymasterInput ? [paymaster, paymasterInput] : [],\n  ];\n\n  // @ts-ignore - TODO: fix types\n  return concatHex([\"0x71\", toRlp(serializedTransaction)]);\n}\n","import type { Hex } from \"./is-hex.js\";\n\n/**\n * Concatenates an array of hexadecimal values into a single hexadecimal value.\n *\n * @param values - An array of hexadecimal values to concatenate.\n * @returns The concatenated hexadecimal value.\n * @utils\n */\nexport function concatHex(values: readonly Hex[]): Hex {\n  return `0x${(values as Hex[]).reduce(\n    (acc, x) => acc + x.replace(\"0x\", \"\"),\n    \"\",\n  )}`;\n}\n","import type { ErrorType } from '../../errors/utils.js'\nimport {\n  type ToSignatureHashErrorType,\n  toSignatureHash,\n} from './toSignatureHash.js'\n\nexport type ToEventSelectorErrorType = ToSignatureHashErrorType | ErrorType\n\n/**\n * Returns the event selector for a given event definition.\n *\n * @example\n * const selector = toEventSelector('Transfer(address indexed from, address indexed to, uint256 amount)')\n * // 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\n */\nexport const toEventSelector = toSignatureHash\n","import type { Abi, AbiParameter } from 'abitype'\n\nimport {\n  AbiDecodingDataSizeTooSmallError,\n  type AbiDecodingDataSizeTooSmallErrorType,\n  AbiEventSignatureEmptyTopicsError,\n  type AbiEventSignatureEmptyTopicsErrorType,\n  AbiEventSignatureNotFoundError,\n  type AbiEventSignatureNotFoundErrorType,\n  DecodeLogDataMismatch,\n  type DecodeLogDataMismatchErrorType,\n  DecodeLogTopicsMismatch,\n  type DecodeLogTopicsMismatchErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractEventArgsFromTopics,\n  ContractEventName,\n  EventDefinition,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type {\n  IsNarrowable,\n  Prettify,\n  UnionEvaluate,\n} from '../../types/utils.js'\nimport { size } from '../data/size.js'\nimport {\n  type ToEventSelectorErrorType,\n  toEventSelector,\n} from '../hash/toEventSelector.js'\n\nimport { PositionOutOfBoundsError } from '../../errors/cursor.js'\nimport {\n  type DecodeAbiParametersErrorType,\n  decodeAbiParameters,\n} from './decodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\n\nexport type DecodeEventLogParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = ContractEventName<abi>,\n  topics extends Hex[] = Hex[],\n  data extends Hex | undefined = undefined,\n  strict extends boolean = true,\n> = {\n  abi: abi\n  data?: data | undefined\n  eventName?: eventName | ContractEventName<abi> | undefined\n  strict?: strict | boolean | undefined\n  topics: [signature: Hex, ...args: topics] | []\n}\n\nexport type DecodeEventLogReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = ContractEventName<abi>,\n  topics extends Hex[] = Hex[],\n  data extends Hex | undefined = undefined,\n  strict extends boolean = true,\n  ///\n  allEventNames extends\n    ContractEventName<abi> = eventName extends ContractEventName<abi>\n    ? eventName\n    : ContractEventName<abi>,\n> = IsNarrowable<abi, Abi> extends true\n  ? {\n      [name in allEventNames]: Prettify<\n        {\n          eventName: name\n        } & UnionEvaluate<\n          ContractEventArgsFromTopics<abi, name, strict> extends infer allArgs\n            ? topics extends readonly []\n              ? data extends undefined\n                ? { args?: undefined }\n                : { args?: allArgs | undefined }\n              : { args: allArgs }\n            : never\n        >\n      >\n    }[allEventNames]\n  : {\n      eventName: eventName\n      args: readonly unknown[] | undefined\n    }\n\nexport type DecodeEventLogErrorType =\n  | AbiDecodingDataSizeTooSmallErrorType\n  | AbiEventSignatureEmptyTopicsErrorType\n  | AbiEventSignatureNotFoundErrorType\n  | DecodeAbiParametersErrorType\n  | DecodeLogTopicsMismatchErrorType\n  | DecodeLogDataMismatchErrorType\n  | FormatAbiItemErrorType\n  | ToEventSelectorErrorType\n  | ErrorType\n\nconst docsPath = '/docs/contract/decodeEventLog'\n\nexport function decodeEventLog<\n  const abi extends Abi | readonly unknown[],\n  eventName extends ContractEventName<abi> | undefined = undefined,\n  topics extends Hex[] = Hex[],\n  data extends Hex | undefined = undefined,\n  strict extends boolean = true,\n>(\n  parameters: DecodeEventLogParameters<abi, eventName, topics, data, strict>,\n): DecodeEventLogReturnType<abi, eventName, topics, data, strict> {\n  const {\n    abi,\n    data,\n    strict: strict_,\n    topics,\n  } = parameters as DecodeEventLogParameters\n\n  const strict = strict_ ?? true\n  const [signature, ...argTopics] = topics\n  if (!signature) throw new AbiEventSignatureEmptyTopicsError({ docsPath })\n\n  const abiItem = abi.find(\n    (x) =>\n      x.type === 'event' &&\n      signature === toEventSelector(formatAbiItem(x) as EventDefinition),\n  )\n  if (!(abiItem && 'name' in abiItem) || abiItem.type !== 'event')\n    throw new AbiEventSignatureNotFoundError(signature, { docsPath })\n\n  const { name, inputs } = abiItem\n  const isUnnamed = inputs?.some((x) => !('name' in x && x.name))\n\n  let args: any = isUnnamed ? [] : {}\n\n  // Decode topics (indexed args).\n  const indexedInputs = inputs.filter((x) => 'indexed' in x && x.indexed)\n  for (let i = 0; i < indexedInputs.length; i++) {\n    const param = indexedInputs[i]\n    const topic = argTopics[i]\n    if (!topic)\n      throw new DecodeLogTopicsMismatch({\n        abiItem,\n        param: param as AbiParameter & { indexed: boolean },\n      })\n    args[isUnnamed ? i : param.name || i] = decodeTopic({ param, value: topic })\n  }\n\n  // Decode data (non-indexed args).\n  const nonIndexedInputs = inputs.filter((x) => !('indexed' in x && x.indexed))\n  if (nonIndexedInputs.length > 0) {\n    if (data && data !== '0x') {\n      try {\n        const decodedData = decodeAbiParameters(nonIndexedInputs, data)\n        if (decodedData) {\n          if (isUnnamed) args = [...args, ...decodedData]\n          else {\n            for (let i = 0; i < nonIndexedInputs.length; i++) {\n              args[nonIndexedInputs[i].name!] = decodedData[i]\n            }\n          }\n        }\n      } catch (err) {\n        if (strict) {\n          if (\n            err instanceof AbiDecodingDataSizeTooSmallError ||\n            err instanceof PositionOutOfBoundsError\n          )\n            throw new DecodeLogDataMismatch({\n              abiItem,\n              data: data,\n              params: nonIndexedInputs,\n              size: size(data),\n            })\n          throw err\n        }\n      }\n    } else if (strict) {\n      throw new DecodeLogDataMismatch({\n        abiItem,\n        data: '0x',\n        params: nonIndexedInputs,\n        size: 0,\n      })\n    }\n  }\n\n  return {\n    eventName: name,\n    args: Object.values(args).length > 0 ? args : undefined,\n  } as unknown as DecodeEventLogReturnType<abi, eventName, topics, data, strict>\n}\n\nfunction decodeTopic({ param, value }: { param: AbiParameter; value: Hex }) {\n  if (\n    param.type === 'string' ||\n    param.type === 'bytes' ||\n    param.type === 'tuple' ||\n    param.type.match(/^(.*)\\[(\\d+)?\\]$/)\n  )\n    return value\n  const decodedArg = decodeAbiParameters([param], value) || []\n  return decodedArg[0]\n}\n","// TODO(v3): checksum address.\n\nimport type { Abi } from 'abitype'\nimport {\n  AbiEventSignatureNotFoundError,\n  DecodeLogDataMismatch,\n  DecodeLogTopicsMismatch,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ContractEventName } from '../../types/contract.js'\nimport type { Log } from '../../types/log.js'\nimport type { RpcLog } from '../../types/rpc.js'\nimport {\n  type DecodeEventLogErrorType,\n  decodeEventLog,\n} from './decodeEventLog.js'\n\nexport type ParseEventLogsParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = ContractEventName<abi>,\n  strict extends boolean | undefined = boolean | undefined,\n> = {\n  /** Contract ABI. */\n  abi: abi\n  /** Contract event. */\n  eventName?:\n    | eventName\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined\n  /** List of logs. */\n  logs: (Log | RpcLog)[]\n  strict?: strict | boolean | undefined\n}\n\nexport type ParseEventLogsReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = ContractEventName<abi>,\n  strict extends boolean | undefined = boolean | undefined,\n  ///\n  derivedEventName extends\n    | ContractEventName<abi>\n    | undefined = eventName extends ContractEventName<abi>[]\n    ? eventName[number]\n    : eventName,\n> = Log<bigint, number, false, undefined, strict, abi, derivedEventName>[]\n\nexport type ParseEventLogsErrorType = DecodeEventLogErrorType | ErrorType\n\n/**\n * Extracts & decodes logs matching the provided signature(s) (`abi` + optional `eventName`)\n * from a set of opaque logs.\n *\n * @param parameters - {@link ParseEventLogsParameters}\n * @returns The logs. {@link ParseEventLogsReturnType}\n *\n * @example\n * import { createClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { parseEventLogs } from 'viem/op-stack'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const receipt = await getTransactionReceipt(client, {\n *   hash: '0xec23b2ba4bc59ba61554507c1b1bc91649e6586eb2dd00c728e8ed0db8bb37ea',\n * })\n *\n * const logs = parseEventLogs({ logs: receipt.logs })\n * // [{ args: { ... }, eventName: 'TransactionDeposited', ... }, ...]\n */\nexport function parseEventLogs<\n  abi extends Abi | readonly unknown[],\n  strict extends boolean | undefined = true,\n  eventName extends\n    | ContractEventName<abi>\n    | ContractEventName<abi>[]\n    | undefined = undefined,\n>({\n  abi,\n  eventName,\n  logs,\n  strict = true,\n}: ParseEventLogsParameters<abi, eventName, strict>): ParseEventLogsReturnType<\n  abi,\n  eventName,\n  strict\n> {\n  return logs\n    .map((log) => {\n      try {\n        const event = decodeEventLog({\n          ...log,\n          abi,\n          strict,\n        })\n        if (eventName && !eventName.includes(event.eventName!)) return null\n        return { ...event, ...log }\n      } catch (err) {\n        let eventName: string | undefined\n        let isUnnamed: boolean | undefined\n\n        if (err instanceof AbiEventSignatureNotFoundError) return null\n        if (\n          err instanceof DecodeLogDataMismatch ||\n          err instanceof DecodeLogTopicsMismatch\n        ) {\n          // If strict mode is on, and log data/topics do not match event definition, skip.\n          if (strict) return null\n          eventName = err.abiItem.name\n          isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name))\n        }\n\n        // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).\n        return { ...log, args: isUnnamed ? [] : {}, eventName }\n      }\n    })\n    .filter(Boolean) as unknown as ParseEventLogsReturnType<\n    abi,\n    eventName,\n    strict\n  >\n}\n","import { BaseError } from './base.js'\n\nexport type FilterTypeNotSupportedErrorType = FilterTypeNotSupportedError & {\n  name: 'FilterTypeNotSupportedError'\n}\nexport class FilterTypeNotSupportedError extends BaseError {\n  override name = 'FilterTypeNotSupportedError'\n  constructor(type: string) {\n    super(`Filter type \"${type}\" is not supported.`)\n  }\n}\n","import type { Abi, AbiParameter, Address } from 'abitype'\n\nimport { AbiItemAmbiguityError } from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  AbiItem,\n  AbiItemArgs,\n  AbiItemName,\n  ExtractAbiItemForArgs,\n  Widen,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { UnionEvaluate } from '../../types/utils.js'\nimport { type IsHexErrorType, isHex } from '../../utils/data/isHex.js'\nimport { type IsAddressErrorType, isAddress } from '../address/isAddress.js'\nimport { toEventSelector } from '../hash/toEventSelector.js'\nimport {\n  type ToFunctionSelectorErrorType,\n  toFunctionSelector,\n} from '../hash/toFunctionSelector.js'\n\nexport type GetAbiItemParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  name extends AbiItemName<abi> = AbiItemName<abi>,\n  args extends AbiItemArgs<abi, name> | undefined = AbiItemArgs<abi, name>,\n  ///\n  allArgs = AbiItemArgs<abi, name>,\n  allNames = AbiItemName<abi>,\n> = {\n  abi: abi\n  name:\n    | allNames // show all options\n    | (name extends allNames ? name : never) // infer value\n    | Hex // function selector\n} & UnionEvaluate<\n  readonly [] extends allArgs\n    ? {\n        args?:\n          | allArgs // show all options\n          // infer value, widen inferred value of `args` conditionally to match `allArgs`\n          | (abi extends Abi\n              ? args extends allArgs\n                ? Widen<args>\n                : never\n              : never)\n          | undefined\n      }\n    : {\n        args?:\n          | allArgs // show all options\n          | (Widen<args> & (args extends allArgs ? unknown : never)) // infer value, widen inferred value of `args` match `allArgs` (e.g. avoid union `args: readonly [123n] | readonly [bigint]`)\n          | undefined\n      }\n>\n\nexport type GetAbiItemErrorType =\n  | IsArgOfTypeErrorType\n  | IsHexErrorType\n  | ToFunctionSelectorErrorType\n  | ErrorType\n\nexport type GetAbiItemReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  name extends AbiItemName<abi> = AbiItemName<abi>,\n  args extends AbiItemArgs<abi, name> | undefined = AbiItemArgs<abi, name>,\n> = abi extends Abi\n  ? Abi extends abi\n    ? AbiItem | undefined\n    : ExtractAbiItemForArgs<\n        abi,\n        name,\n        args extends AbiItemArgs<abi, name> ? args : AbiItemArgs<abi, name>\n      >\n  : AbiItem | undefined\n\nexport function getAbiItem<\n  const abi extends Abi | readonly unknown[],\n  name extends AbiItemName<abi>,\n  const args extends AbiItemArgs<abi, name> | undefined = undefined,\n>(\n  parameters: GetAbiItemParameters<abi, name, args>,\n): GetAbiItemReturnType<abi, name, args> {\n  const { abi, args = [], name } = parameters as unknown as GetAbiItemParameters\n\n  const isSelector = isHex(name, { strict: false })\n  const abiItems = (abi as Abi).filter((abiItem) => {\n    if (isSelector) {\n      if (abiItem.type === 'function')\n        return toFunctionSelector(abiItem) === name\n      if (abiItem.type === 'event') return toEventSelector(abiItem) === name\n      return false\n    }\n    return 'name' in abiItem && abiItem.name === name\n  })\n\n  if (abiItems.length === 0)\n    return undefined as GetAbiItemReturnType<abi, name, args>\n  if (abiItems.length === 1)\n    return abiItems[0] as GetAbiItemReturnType<abi, name, args>\n\n  let matchedAbiItem: AbiItem | undefined = undefined\n  for (const abiItem of abiItems) {\n    if (!('inputs' in abiItem)) continue\n    if (!args || args.length === 0) {\n      if (!abiItem.inputs || abiItem.inputs.length === 0)\n        return abiItem as GetAbiItemReturnType<abi, name, args>\n      continue\n    }\n    if (!abiItem.inputs) continue\n    if (abiItem.inputs.length === 0) continue\n    if (abiItem.inputs.length !== args.length) continue\n    const matched = args.every((arg, index) => {\n      const abiParameter = 'inputs' in abiItem && abiItem.inputs![index]\n      if (!abiParameter) return false\n      return isArgOfType(arg, abiParameter)\n    })\n    if (matched) {\n      // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n      if (\n        matchedAbiItem &&\n        'inputs' in matchedAbiItem &&\n        matchedAbiItem.inputs\n      ) {\n        const ambiguousTypes = getAmbiguousTypes(\n          abiItem.inputs,\n          matchedAbiItem.inputs,\n          args as readonly unknown[],\n        )\n        if (ambiguousTypes)\n          throw new AbiItemAmbiguityError(\n            {\n              abiItem,\n              type: ambiguousTypes[0],\n            },\n            {\n              abiItem: matchedAbiItem,\n              type: ambiguousTypes[1],\n            },\n          )\n      }\n\n      matchedAbiItem = abiItem\n    }\n  }\n\n  if (matchedAbiItem)\n    return matchedAbiItem as GetAbiItemReturnType<abi, name, args>\n  return abiItems[0] as GetAbiItemReturnType<abi, name, args>\n}\n\nexport type IsArgOfTypeErrorType = IsAddressErrorType | ErrorType\n\nexport function isArgOfType(arg: unknown, abiParameter: AbiParameter): boolean {\n  const argType = typeof arg\n  const abiParameterType = abiParameter.type\n  switch (abiParameterType) {\n    case 'address':\n      return isAddress(arg as Address, { strict: false })\n    case 'bool':\n      return argType === 'boolean'\n    case 'function':\n      return argType === 'string'\n    case 'string':\n      return argType === 'string'\n    default: {\n      if (abiParameterType === 'tuple' && 'components' in abiParameter)\n        return Object.values(abiParameter.components).every(\n          (component, index) => {\n            return isArgOfType(\n              Object.values(arg as unknown[] | Record<string, unknown>)[index],\n              component as AbiParameter,\n            )\n          },\n        )\n\n      // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n      // https://regexr.com/6v8hp\n      if (\n        /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(\n          abiParameterType,\n        )\n      )\n        return argType === 'number' || argType === 'bigint'\n\n      // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n      // https://regexr.com/6va55\n      if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n        return argType === 'string' || arg instanceof Uint8Array\n\n      // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n      // https://regexr.com/6va6i\n      if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n        return (\n          Array.isArray(arg) &&\n          arg.every((x: unknown) =>\n            isArgOfType(x, {\n              ...abiParameter,\n              // Pop off `[]` or `[M]` from end of type\n              type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n            } as AbiParameter),\n          )\n        )\n      }\n\n      return false\n    }\n  }\n}\n\nexport function getAmbiguousTypes(\n  sourceParameters: readonly AbiParameter[],\n  targetParameters: readonly AbiParameter[],\n  args: AbiItemArgs,\n): AbiParameter['type'][] | undefined {\n  for (const parameterIndex in sourceParameters) {\n    const sourceParameter = sourceParameters[parameterIndex]\n    const targetParameter = targetParameters[parameterIndex]\n\n    if (\n      sourceParameter.type === 'tuple' &&\n      targetParameter.type === 'tuple' &&\n      'components' in sourceParameter &&\n      'components' in targetParameter\n    )\n      return getAmbiguousTypes(\n        sourceParameter.components,\n        targetParameter.components,\n        (args as any)[parameterIndex],\n      )\n\n    const types = [sourceParameter.type, targetParameter.type]\n\n    const ambiguous = (() => {\n      if (types.includes('address') && types.includes('bytes20')) return true\n      if (types.includes('address') && types.includes('string'))\n        return isAddress(args[parameterIndex] as Address, { strict: false })\n      if (types.includes('address') && types.includes('bytes'))\n        return isAddress(args[parameterIndex] as Address, { strict: false })\n      return false\n    })()\n\n    if (ambiguous) return types\n  }\n\n  return\n}\n","import type {\n  Abi,\n  AbiParameter,\n  AbiParameterToPrimitiveType,\n  ExtractAbiEvents,\n} from 'abitype'\n\nimport {\n  AbiEventNotFoundError,\n  type AbiEventNotFoundErrorType,\n} from '../../errors/abi.js'\nimport {\n  FilterTypeNotSupportedError,\n  type FilterTypeNotSupportedErrorType,\n} from '../../errors/log.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractEventArgs,\n  ContractEventName,\n  EventDefinition,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { IsNarrowable, UnionEvaluate } from '../../types/utils.js'\nimport { type ToBytesErrorType, toBytes } from '../encoding/toBytes.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport {\n  type ToEventSelectorErrorType,\n  toEventSelector,\n} from '../hash/toEventSelector.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from './encodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\nimport { type GetAbiItemErrorType, getAbiItem } from './getAbiItem.js'\n\nconst docsPath = '/docs/contract/encodeEventTopics'\n\nexport type EncodeEventTopicsParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = ContractEventName<abi>,\n  ///\n  hasEvents = abi extends Abi\n    ? Abi extends abi\n      ? true\n      : [ExtractAbiEvents<abi>] extends [never]\n        ? false\n        : true\n    : true,\n  allArgs = ContractEventArgs<\n    abi,\n    eventName extends ContractEventName<abi>\n      ? eventName\n      : ContractEventName<abi>\n  >,\n  allErrorNames = ContractEventName<abi>,\n> = {\n  abi: abi\n  args?: allArgs | undefined\n} & UnionEvaluate<\n  IsNarrowable<abi, Abi> extends true\n    ? abi['length'] extends 1\n      ? { eventName?: eventName | allErrorNames | undefined }\n      : { eventName: eventName | allErrorNames }\n    : { eventName?: eventName | allErrorNames | undefined }\n> &\n  (hasEvents extends true ? unknown : never)\n\nexport type EncodeEventTopicsErrorType =\n  | AbiEventNotFoundErrorType\n  | EncodeArgErrorType\n  | FormatAbiItemErrorType\n  | GetAbiItemErrorType\n  | ToEventSelectorErrorType\n  | ErrorType\n\nexport function encodeEventTopics<\n  const abi extends Abi | readonly unknown[],\n  eventName extends ContractEventName<abi> | undefined = undefined,\n>(parameters: EncodeEventTopicsParameters<abi, eventName>) {\n  const { abi, eventName, args } = parameters as EncodeEventTopicsParameters\n\n  let abiItem = abi[0]\n  if (eventName) {\n    const item = getAbiItem({ abi, name: eventName })\n    if (!item) throw new AbiEventNotFoundError(eventName, { docsPath })\n    abiItem = item\n  }\n\n  if (abiItem.type !== 'event')\n    throw new AbiEventNotFoundError(undefined, { docsPath })\n\n  const definition = formatAbiItem(abiItem)\n  const signature = toEventSelector(definition as EventDefinition)\n\n  let topics: Hex[] = []\n  if (args && 'inputs' in abiItem) {\n    const indexedInputs = abiItem.inputs?.filter(\n      (param) => 'indexed' in param && param.indexed,\n    )\n    const args_ = Array.isArray(args)\n      ? args\n      : Object.values(args).length > 0\n        ? indexedInputs?.map((x: any) => (args as any)[x.name]) ?? []\n        : []\n\n    if (args_.length > 0) {\n      topics =\n        indexedInputs?.map((param, i) =>\n          Array.isArray(args_[i])\n            ? args_[i].map((_: any, j: number) =>\n                encodeArg({ param, value: args_[i][j] }),\n              )\n            : args_[i]\n              ? encodeArg({ param, value: args_[i] })\n              : null,\n        ) ?? []\n    }\n  }\n  return [signature, ...topics]\n}\n\nexport type EncodeArgErrorType =\n  | Keccak256ErrorType\n  | ToBytesErrorType\n  | EncodeAbiParametersErrorType\n  | FilterTypeNotSupportedErrorType\n  | ErrorType\n\nfunction encodeArg({\n  param,\n  value,\n}: { param: AbiParameter; value: AbiParameterToPrimitiveType<AbiParameter> }) {\n  if (param.type === 'string' || param.type === 'bytes')\n    return keccak256(toBytes(value as string))\n  if (param.type === 'tuple' || param.type.match(/^(.*)\\[(\\d+)?\\]$/))\n    throw new FilterTypeNotSupportedError(param.type)\n  return encodeAbiParameters([param], [value])\n}\n","import { prepareEvent } from \"../../../../../event/prepare-event.js\";\nimport type { AbiParameterToPrimitiveType } from \"abitype\";\n\n/**\n * Represents the filters for the \"UserOperationRevertReason\" event.\n */\nexport type UserOperationRevertReasonEventFilters = Partial<{\n  userOpHash: AbiParameterToPrimitiveType<{\n    type: \"bytes32\";\n    name: \"userOpHash\";\n    indexed: true;\n  }>;\n  sender: AbiParameterToPrimitiveType<{\n    type: \"address\";\n    name: \"sender\";\n    indexed: true;\n  }>;\n}>;\n\n/**\n * Creates an event object for the UserOperationRevertReason event.\n * @param filters - Optional filters to apply to the event.\n * @returns The prepared event object.\n * @extension ERC4337\n * @example\n * ```ts\n * import { getContractEvents } from \"thirdweb\";\n * import { userOperationRevertReasonEvent } from \"thirdweb/extensions/erc4337\";\n *\n * const events = await getContractEvents({\n * contract,\n * events: [\n *  userOperationRevertReasonEvent({\n *  userOpHash: ...,\n *  sender: ...,\n * })\n * ],\n * });\n * ```\n */\nexport function userOperationRevertReasonEvent(\n  filters: UserOperationRevertReasonEventFilters = {},\n) {\n  return prepareEvent({\n    signature:\n      \"event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason)\",\n    filters,\n  });\n}\n","import { type AbiEvent, type ParseAbiItem, parseAbiItem } from \"abitype\";\nimport { type Hex, encodeEventTopics, toEventHash } from \"viem\";\nimport type { AbiEventParametersToPrimitiveTypes } from \"./types.js\";\nimport { isAbiEvent } from \"./utils.js\";\n\ntype ParseEvent<event extends AbiEvent | string> =\n  // if the method IS an AbiEvent, return it\n  event extends AbiEvent\n    ? event\n    : event extends string // we now know we are in \"string\" territory\n      ? // if the string starts with `function` then we can parse it\n        event extends `event ${string}`\n        ? ParseAbiItem<event>\n        : // do we have an ABI to check, check the length\n          AbiEvent\n      : // this means its neither have an AbiEvent NOR a string -> never\n        never;\n\ntype EventFilters<abiEvent extends AbiEvent> =\n  AbiEventParametersToPrimitiveTypes<abiEvent[\"inputs\"]>;\n\nexport type PrepareEventOptions<\n  TSignature extends `event ${string}` | AbiEvent,\n> = {\n  signature: TSignature;\n  filters?: Readonly<EventFilters<ParseEvent<TSignature>>>;\n};\n\nexport type PreparedEvent<abiEvent extends AbiEvent> = {\n  abiEvent: abiEvent;\n  hash: Hex;\n  topics: Hex[];\n};\n\n/**\n * Prepares an event by parsing the signature, generating the event hash, and encoding the event topics.\n * @param options - The options for preparing the event.\n * @returns The prepared event object.\n * @example\n * ```ts\n * import { prepareEvent } from \"thirdweb\";\n * const myEvent = prepareEvent({\n *  signature: \"event MyEvent(uint256 myArg)\",\n * });\n * ```\n * @contract\n */\nexport function prepareEvent<TSignature extends `event ${string}` | AbiEvent>(\n  options: PrepareEventOptions<TSignature>,\n): PreparedEvent<ParseEvent<TSignature>> {\n  const { signature } = options;\n  let resolvedSignature: ParseEvent<TSignature>;\n  if (isAbiEvent(signature)) {\n    resolvedSignature = signature as ParseEvent<TSignature>;\n  } else {\n    resolvedSignature = parseAbiItem(signature) as ParseEvent<TSignature>;\n  }\n\n  return {\n    abiEvent: resolvedSignature,\n    hash: toEventHash(resolvedSignature),\n    // @ts-expect-error - TODO: investiagte why this complains, it works fine however\n    topics: encodeEventTopics({\n      abi: [resolvedSignature],\n      args: options.filters,\n    }),\n  };\n}\n","import type { AbiEvent } from \"abitype\";\n\n/**\n * @internal\n */\nexport function isAbiEvent(item: unknown): item is AbiEvent {\n  return !!(\n    item &&\n    typeof item === \"object\" &&\n    \"type\" in item &&\n    item.type === \"event\"\n  );\n}\n","import { defineChain } from \"../utils.js\";\n\nexport const zkSyncSepolia = /*@__PURE__*/ defineChain({\n  id: 300,\n  name: \"ZkSync Sepolia\",\n  nativeCurrency: {\n    decimals: 18,\n    name: \"Ether\",\n    symbol: \"ETH\",\n  },\n  blockExplorers: [\n    {\n      name: \"zkSync Sepolia Block Explorer\",\n      url: \"https://sepolia.explorer.zksync.io\",\n      apiUrl: \"https://block-explorer-api.sepolia.zksync.dev/api\",\n    },\n  ],\n});\n","import { defineChain } from \"../utils.js\";\n\nexport const zkSync = /*@__PURE__*/ defineChain({\n  id: 324,\n  name: \"ZkSync Era\",\n  nativeCurrency: {\n    decimals: 18,\n    name: \"Ether\",\n    symbol: \"ETH\",\n  },\n  blockExplorers: [\n    {\n      name: \"zkSync Era Block Explorer\",\n      url: \"https://explorer.zksync.io\",\n      apiUrl: \"https://block-explorer-api.zksync.dev/api\",\n    },\n  ],\n});\n","import { concat } from \"viem\";\nimport { zkSyncSepolia } from \"../../../chains/chain-definitions/zksync-sepolia.js\";\nimport { zkSync } from \"../../../chains/chain-definitions/zksync.js\";\nimport type { Chain } from \"../../../chains/types.js\";\nimport { isHex, numberToHex, toHex } from \"../../../utils/encoding/hex.js\";\nimport type { UserOperation, UserOperationHexed } from \"../types.js\";\n\nconst generateRandomUint192 = (): bigint => {\n  const rand1 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand2 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand3 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand4 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand5 = BigInt(Math.floor(Math.random() * 0x100000000));\n  const rand6 = BigInt(Math.floor(Math.random() * 0x100000000));\n  return (\n    (rand1 << BigInt(160)) |\n    (rand2 << BigInt(128)) |\n    (rand3 << BigInt(96)) |\n    (rand4 << BigInt(64)) |\n    (rand5 << BigInt(32)) |\n    rand6\n  );\n};\n\n/**\n * @internal\n */\nexport const randomNonce = () => {\n  return BigInt(\n    concat([numberToHex(generateRandomUint192()), \"0x0000000000000000\"]),\n  );\n};\n\n/**\n * @internal\n */\nexport function hexlifyUserOp(userOp: UserOperation): UserOperationHexed {\n  return Object.fromEntries(\n    Object.entries(userOp).map(([key, val]) => [\n      key,\n      // turn any value that's not hex into hex\n      isHex(val) ? val : toHex(val),\n    ]),\n  ) as UserOperationHexed;\n}\n\nexport function isNativeAAChain(chain: Chain) {\n  return chain.id === zkSync.id || chain.id === zkSyncSepolia.id;\n}\n","import { type TransactionSerializable, decodeErrorResult } from \"viem\";\nimport { parseEventLogs } from \"../../../event/actions/parse-logs.js\";\nimport { userOperationRevertReasonEvent } from \"../../../extensions/erc4337/__generated__/IEntryPoint/events/UserOperationRevertReason.js\";\nimport type { TransactionReceipt } from \"../../../transaction/types.js\";\nimport { type Hex, hexToBigInt } from \"../../../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../../../utils/fetch.js\";\nimport { stringify } from \"../../../utils/json.js\";\nimport type {\n  BundlerOptions,\n  EstimationResult,\n  GasPriceResult,\n  PmTransactionData,\n  UserOperation,\n} from \"../types.js\";\nimport {\n  DEBUG,\n  ENTRYPOINT_ADDRESS_v0_6,\n  MANAGED_ACCOUNT_GAS_BUFFER,\n  getDefaultBundlerUrl,\n} from \"./constants.js\";\nimport { hexlifyUserOp } from \"./utils.js\";\n\n/**\n * @internal\n */\nexport async function bundleUserOp(args: {\n  userOp: UserOperation;\n  options: BundlerOptions;\n}): Promise<Hex> {\n  return sendBundlerRequest({\n    ...args,\n    operation: \"eth_sendUserOperation\",\n    params: [\n      hexlifyUserOp(args.userOp),\n      args.options.overrides?.entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6,\n    ],\n  });\n}\n\n/**\n * @internal\n */\nexport async function estimateUserOpGas(args: {\n  userOp: UserOperation;\n  options: BundlerOptions;\n}): Promise<EstimationResult> {\n  const res = await sendBundlerRequest({\n    ...args,\n    operation: \"eth_estimateUserOperationGas\",\n    params: [\n      hexlifyUserOp(args.userOp),\n      args.options.overrides?.entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6,\n    ],\n  });\n\n  // add gas buffer for managed account factory delegate calls\n  return {\n    preVerificationGas: hexToBigInt(res.preVerificationGas),\n    verificationGas: hexToBigInt(res.verificationGas),\n    verificationGasLimit: hexToBigInt(res.verificationGasLimit),\n    callGasLimit: hexToBigInt(res.callGasLimit) + MANAGED_ACCOUNT_GAS_BUFFER,\n  };\n}\n\n/**\n * @internal\n */\nexport async function getUserOpGasPrice(args: {\n  options: BundlerOptions;\n}): Promise<GasPriceResult> {\n  const res = await sendBundlerRequest({\n    ...args,\n    operation: \"thirdweb_getUserOperationGasPrice\",\n    params: [],\n  });\n\n  return {\n    maxPriorityFeePerGas: hexToBigInt(res.maxPriorityFeePerGas),\n    maxFeePerGas: hexToBigInt(res.maxFeePerGas),\n  };\n}\n\n/**\n * @internal\n */\nexport async function getUserOpReceipt(args: {\n  userOpHash: Hex;\n  options: BundlerOptions;\n}): Promise<TransactionReceipt | undefined> {\n  const res = await sendBundlerRequest({\n    ...args,\n    operation: \"eth_getUserOperationReceipt\",\n    params: [args.userOpHash],\n  });\n  if (!res) {\n    return undefined;\n  }\n  if (res.success === false) {\n    // parse revert reason\n    const logs = parseEventLogs({\n      events: [userOperationRevertReasonEvent()],\n      logs: res.logs,\n    });\n    const revertReason = logs[0]?.args?.revertReason;\n    if (!revertReason) {\n      throw new Error(`UserOp failed at txHash: ${res.transactionHash}`);\n    }\n    const revertMsg = decodeErrorResult({\n      data: revertReason,\n    });\n    throw new Error(\n      `UserOp failed with reason: '${revertMsg.args.join(\",\")}' at txHash: ${\n        res.transactionHash\n      }`,\n    );\n  }\n  return res.receipt;\n}\n\n/**\n * @internal\n */\nexport async function getZkPaymasterData(args: {\n  options: BundlerOptions;\n  transaction: TransactionSerializable;\n}): Promise<PmTransactionData> {\n  const res = await sendBundlerRequest({\n    options: args.options,\n    operation: \"zk_paymasterData\",\n    params: [args.transaction],\n  });\n\n  return {\n    paymaster: res.paymaster,\n    paymasterInput: res.paymasterInput,\n  };\n}\n\nexport async function broadcastZkTransaction(args: {\n  options: BundlerOptions;\n  transaction: TransactionSerializable;\n  signedTransaction: Hex;\n}): Promise<{ transactionHash: Hex }> {\n  const res = await sendBundlerRequest({\n    options: args.options,\n    operation: \"zk_broadcastTransaction\",\n    params: [\n      {\n        ...args.transaction,\n        signedTransaction: args.signedTransaction,\n      },\n    ],\n  });\n\n  return {\n    transactionHash: res.transactionHash,\n  };\n}\n\nasync function sendBundlerRequest(args: {\n  options: BundlerOptions;\n  operation:\n    | \"eth_estimateUserOperationGas\"\n    | \"eth_sendUserOperation\"\n    | \"eth_getUserOperationReceipt\"\n    | \"thirdweb_getUserOperationGasPrice\"\n    | \"zk_paymasterData\"\n    | \"zk_broadcastTransaction\";\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  params: any[];\n}) {\n  const { options, operation, params } = args;\n\n  if (DEBUG) {\n    console.debug(`>>> sending ${operation} with payload:`, params);\n  }\n\n  const bundlerUrl =\n    options.overrides?.bundlerUrl ?? getDefaultBundlerUrl(options.chain);\n  const fetchWithHeaders = getClientFetch(options.client);\n  const response = await fetchWithHeaders(bundlerUrl, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: stringify({\n      jsonrpc: \"2.0\",\n      id: 1,\n      method: operation,\n      params,\n    }),\n  });\n  const res = await response.json();\n\n  if (!response.ok || res.error) {\n    let error = res.error || response.statusText;\n    if (typeof error === \"object\") {\n      error = JSON.stringify(error);\n    }\n    const code = res.code || \"UNKNOWN\";\n\n    throw new Error(\n      `${operation} error: ${error}\nStatus: ${response.status}\nCode: ${code}`,\n    );\n  }\n\n  if (DEBUG) {\n    console.debug(`<<< ${operation} result:`, res);\n  }\n\n  return res.result;\n}\n","import type { AbiEvent } from \"abitype\";\nimport {\n  type Log,\n  type RpcLog,\n  parseEventLogs as viem_parseEventLogs,\n} from \"viem\";\nimport type { PreparedEvent } from \"../prepare-event.js\";\n\nexport type ParseEventLogsOptions<\n  abiEvents extends PreparedEvent<AbiEvent>[],\n  TStrict extends boolean,\n> = {\n  logs: (Log | RpcLog)[];\n  events: abiEvents;\n  strict?: TStrict;\n};\n\nexport type ParseEventLogsResult<\n  abiEvents extends PreparedEvent<AbiEvent>[],\n  TStrict extends boolean,\n  abiEvent extends AbiEvent = abiEvents[number][\"abiEvent\"],\n> = Array<Log<bigint, number, false, undefined, TStrict, abiEvent[]>>;\n\n/**\n * Parses logs and returns the corresponding events.\n * @param options - The options for parsing logs.\n * @returns The parsed events.\n * @example\n * ```ts\n * import { parseEventLogs } from \"thirdweb\";\n * const events = parseEventLogs({\n *  logs,\n *  events: [preparedEvent, preparedEvent2],\n * });\n * ```\n * @contract\n */\nexport function parseEventLogs<\n  const abiEvents extends PreparedEvent<AbiEvent>[],\n  const TStrict extends boolean = true,\n>(\n  options: ParseEventLogsOptions<abiEvents, TStrict>,\n): ParseEventLogsResult<abiEvents, TStrict> {\n  const { logs, events, strict } = options;\n  return viem_parseEventLogs({\n    logs,\n    abi: events.map((e) => e.abiEvent),\n    strict,\n  }) as unknown as ParseEventLogsResult<abiEvents, TStrict>;\n}\n","import { hexToBigInt } from \"../../../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../../../utils/fetch.js\";\nimport type {\n  PaymasterResult,\n  SmartAccountOptions,\n  UserOperation,\n} from \"../types.js\";\nimport {\n  DEBUG,\n  ENTRYPOINT_ADDRESS_v0_6,\n  getDefaultPaymasterUrl,\n} from \"./constants.js\";\nimport { hexlifyUserOp } from \"./utils.js\";\n\n/**\n * TODO Docs\n * @internal\n */\nexport async function getPaymasterAndData(args: {\n  userOp: UserOperation;\n  options: SmartAccountOptions;\n}): Promise<PaymasterResult> {\n  const { userOp, options } = args;\n\n  if (options.overrides?.paymaster) {\n    return options.overrides?.paymaster(userOp);\n  }\n\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"application/json\",\n  };\n\n  const client = options.client;\n  const paymasterUrl = getDefaultPaymasterUrl(options.chain);\n  const entrypoint =\n    options.overrides?.entrypointAddress ?? ENTRYPOINT_ADDRESS_v0_6;\n\n  // Ask the paymaster to sign the transaction and return a valid paymasterAndData value.\n  const fetchWithHeaders = getClientFetch(client);\n  const response = await fetchWithHeaders(paymasterUrl, {\n    method: \"POST\",\n    headers,\n    body: JSON.stringify({\n      jsonrpc: \"2.0\",\n      id: 1,\n      method: \"pm_sponsorUserOperation\",\n      params: [hexlifyUserOp(userOp), entrypoint],\n    }),\n  });\n  const res = await response.json();\n\n  if (!response.ok) {\n    const error = res.error || response.statusText;\n    const code = res.code || \"UNKNOWN\";\n\n    throw new Error(\n      `Paymaster error: ${error}\nStatus: ${response.status}\nCode: ${code}`,\n    );\n  }\n\n  if (DEBUG) {\n    console.debug(\"Paymaster result:\", res);\n  }\n\n  if (res.result) {\n    // some paymasters return a string, some return an object with more data\n    if (typeof res.result === \"string\") {\n      return {\n        paymasterAndData: res.result,\n      };\n    }\n    return {\n      paymasterAndData: res.result.paymasterAndData,\n      verificationGasLimit: res.result.verificationGasLimit\n        ? hexToBigInt(res.result.verificationGasLimit)\n        : undefined,\n      preVerificationGas: res.result.preVerificationGas\n        ? hexToBigInt(res.result.preVerificationGas)\n        : undefined,\n      callGasLimit: res.result.callGasLimit\n        ? hexToBigInt(res.result.callGasLimit)\n        : undefined,\n    };\n  }\n  const error =\n    res.error?.message || res.error || response.statusText || \"unknown error\";\n  throw new Error(`Paymaster error from ${paymasterUrl}: ${error}`);\n}\n","import { concat } from \"viem\";\nimport { getDefaultGasOverrides } from \"../../../gas/fee-data.js\";\nimport { encode } from \"../../../transaction/actions/encode.js\";\nimport type { PreparedTransaction } from \"../../../transaction/prepare-transaction.js\";\nimport { encodeAbiParameters } from \"../../../utils/abi/encodeAbiParameters.js\";\nimport { isContractDeployed } from \"../../../utils/bytecode/is-contract-deployed.js\";\nimport type { Hex } from \"../../../utils/encoding/hex.js\";\nimport { hexToBytes } from \"../../../utils/encoding/to-bytes.js\";\nimport { isThirdwebUrl } from \"../../../utils/fetch.js\";\nimport { keccak256 } from \"../../../utils/hashing/keccak256.js\";\nimport { resolvePromisedValue } from \"../../../utils/promise/resolve-promised-value.js\";\nimport type { SmartAccountOptions, UserOperation } from \"../types.js\";\nimport { estimateUserOpGas, getUserOpGasPrice } from \"./bundler.js\";\nimport { prepareCreateAccount } from \"./calls.js\";\nimport {\n  DUMMY_SIGNATURE,\n  ENTRYPOINT_ADDRESS_v0_6,\n  getDefaultBundlerUrl,\n} from \"./constants.js\";\nimport { getPaymasterAndData } from \"./paymaster.js\";\nimport { randomNonce } from \"./utils.js\";\n\n/**\n * Create an unsigned user operation\n * @internal\n */\n/**\n * Creates an unsigned user operation.\n * @internal\n */\nexport async function createUnsignedUserOp(args: {\n  executeTx: PreparedTransaction;\n  options: SmartAccountOptions;\n}): Promise<UserOperation> {\n  const { executeTx, options } = args;\n  const isDeployed = await isContractDeployed(options.accountContract);\n  const initCode = isDeployed ? \"0x\" : await getAccountInitCode(options);\n  const callData = await encode(executeTx);\n\n  let { maxFeePerGas, maxPriorityFeePerGas } = executeTx;\n  const bundlerUrl =\n    options.overrides?.bundlerUrl ?? getDefaultBundlerUrl(options.chain);\n  if (isThirdwebUrl(bundlerUrl)) {\n    // get gas prices from bundler\n    const bundlerGasPrice = await getUserOpGasPrice({\n      options,\n    });\n    maxFeePerGas = bundlerGasPrice.maxFeePerGas;\n    maxPriorityFeePerGas = bundlerGasPrice.maxPriorityFeePerGas;\n  } else {\n    // Check for explicity values\n    const [resolvedMaxFeePerGas, resolvedMaxPriorityFeePerGas] =\n      await Promise.all([\n        resolvePromisedValue(maxFeePerGas),\n        resolvePromisedValue(maxPriorityFeePerGas),\n      ]);\n\n    if (resolvedMaxFeePerGas && resolvedMaxPriorityFeePerGas) {\n      // Save a network call if the values are provided\n      maxFeePerGas = resolvedMaxFeePerGas;\n      maxPriorityFeePerGas = resolvedMaxPriorityFeePerGas;\n    } else {\n      // Fallback to RPC gas prices if no explicit values provided\n      const feeData = await getDefaultGasOverrides(\n        options.client,\n        options.chain,\n      );\n\n      // Still check for explicit values in case one is provided and not the other\n      maxPriorityFeePerGas =\n        resolvedMaxPriorityFeePerGas ?? feeData.maxPriorityFeePerGas ?? 0n;\n      maxFeePerGas = resolvedMaxFeePerGas ?? feeData.maxFeePerGas ?? 0n;\n    }\n  }\n\n  // const nonce = BigInt(transaction.nonce || randomNonce());\n  const nonce = randomNonce(); // FIXME getNonce should be overrideable by the wallet\n\n  const partialOp: UserOperation = {\n    sender: options.accountContract.address,\n    nonce,\n    initCode,\n    callData,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    callGasLimit: 0n,\n    verificationGasLimit: 0n,\n    preVerificationGas: 0n,\n    paymasterAndData: \"0x\",\n    signature: DUMMY_SIGNATURE,\n  };\n\n  if (options.sponsorGas) {\n    const paymasterResult = await getPaymasterAndData({\n      userOp: partialOp,\n      options,\n    });\n    const paymasterAndData = paymasterResult.paymasterAndData;\n    if (paymasterAndData && paymasterAndData !== \"0x\") {\n      partialOp.paymasterAndData = paymasterAndData as Hex;\n    }\n    // paymaster can have the gas limits in the response\n    if (\n      paymasterResult.callGasLimit &&\n      paymasterResult.verificationGasLimit &&\n      paymasterResult.preVerificationGas\n    ) {\n      partialOp.callGasLimit = paymasterResult.callGasLimit;\n      partialOp.verificationGasLimit = paymasterResult.verificationGasLimit;\n      partialOp.preVerificationGas = paymasterResult.preVerificationGas;\n    } else {\n      // otherwise fallback to bundler for gas limits\n      const estimates = await estimateUserOpGas({\n        userOp: partialOp,\n        options,\n      });\n      partialOp.callGasLimit = estimates.callGasLimit;\n      partialOp.verificationGasLimit = estimates.verificationGasLimit;\n      partialOp.preVerificationGas = estimates.preVerificationGas;\n      // need paymaster to re-sign after estimates\n      if (paymasterAndData && paymasterAndData !== \"0x\") {\n        const paymasterResult2 = await getPaymasterAndData({\n          userOp: partialOp,\n          options,\n        });\n        if (\n          paymasterResult2.paymasterAndData &&\n          paymasterResult2.paymasterAndData !== \"0x\"\n        ) {\n          partialOp.paymasterAndData = paymasterResult2.paymasterAndData as Hex;\n        }\n      }\n    }\n  } else {\n    // not gasless, so we just need to estimate gas limits\n    const estimates = await estimateUserOpGas({\n      userOp: partialOp,\n      options,\n    });\n    partialOp.callGasLimit = estimates.callGasLimit;\n    partialOp.verificationGasLimit = estimates.verificationGasLimit;\n    partialOp.preVerificationGas = estimates.preVerificationGas;\n  }\n  return {\n    ...partialOp,\n    signature: \"0x\",\n  };\n}\n\n/**\n * Sign the filled userOp.\n * @param userOp - The UserOperation to sign (with signature field ignored)\n * @internal\n */\nexport async function signUserOp(args: {\n  userOp: UserOperation;\n  options: SmartAccountOptions;\n}): Promise<UserOperation> {\n  const { userOp, options } = args;\n  const userOpHash = getUserOpHash({\n    userOp,\n    entryPoint: options.overrides?.entrypointAddress || ENTRYPOINT_ADDRESS_v0_6,\n    chainId: options.chain.id,\n  });\n  if (options.personalAccount.signMessage) {\n    const signature = await options.personalAccount.signMessage({\n      message: {\n        raw: hexToBytes(userOpHash),\n      },\n    });\n    return {\n      ...userOp,\n      signature,\n    };\n  }\n  throw new Error(\"signMessage not implemented in signingAccount\");\n}\n\nasync function getAccountInitCode(options: SmartAccountOptions): Promise<Hex> {\n  const { factoryContract } = options;\n  const deployTx = prepareCreateAccount({\n    factoryContract,\n    options,\n  });\n  return concat([factoryContract.address as Hex, await encode(deployTx)]);\n}\n\n/**\n * @internal\n */\nfunction getUserOpHash(args: {\n  userOp: UserOperation;\n  entryPoint: string;\n  chainId: number;\n}): Hex {\n  const { userOp, entryPoint, chainId } = args;\n  const hashedInitCode = keccak256(userOp.initCode);\n  const hashedCallData = keccak256(userOp.callData);\n  const hashedPaymasterAndData = keccak256(userOp.paymasterAndData);\n\n  const packedUserOp = encodeAbiParameters(\n    [\n      { type: \"address\" },\n      { type: \"uint256\" },\n      { type: \"bytes32\" },\n      { type: \"bytes32\" },\n      { type: \"uint256\" },\n      { type: \"uint256\" },\n      { type: \"uint256\" },\n      { type: \"uint256\" },\n      { type: \"uint256\" },\n      { type: \"bytes32\" },\n    ],\n    [\n      userOp.sender,\n      userOp.nonce,\n      hashedInitCode,\n      hashedCallData,\n      userOp.callGasLimit,\n      userOp.verificationGasLimit,\n      userOp.preVerificationGas,\n      userOp.maxFeePerGas,\n      userOp.maxPriorityFeePerGas,\n      hashedPaymasterAndData,\n    ],\n  );\n  const encoded = encodeAbiParameters(\n    [{ type: \"bytes32\" }, { type: \"address\" }, { type: \"uint256\" }],\n    [keccak256(packedUserOp), entryPoint, BigInt(chainId)],\n  );\n  return keccak256(encoded);\n}\n","import type { ThirdwebContract } from \"../../../contract/contract.js\";\nimport { prepareContractCall } from \"../../../transaction/prepare-contract-call.js\";\nimport type { PreparedTransaction } from \"../../../transaction/prepare-transaction.js\";\nimport { readContract } from \"../../../transaction/read-contract.js\";\nimport { stringToHex } from \"../../../utils/encoding/hex.js\";\nimport type { SendTransactionOption } from \"../../interfaces/wallet.js\";\nimport type { SmartAccountOptions, SmartWalletOptions } from \"../types.ts\";\n\n/**\n * @internal\n */\nexport async function predictAddress(\n  factoryContract: ThirdwebContract,\n  options: SmartWalletOptions & { personalAccountAddress?: string },\n): Promise<string> {\n  if (options.overrides?.predictAddress) {\n    return options.overrides.predictAddress(factoryContract);\n  }\n  if (options.overrides?.accountAddress) {\n    return options.overrides.accountAddress;\n  }\n  const adminAddress = options.personalAccountAddress;\n  if (!adminAddress) {\n    throw new Error(\n      \"Account address is required to predict the smart wallet address.\",\n    );\n  }\n  const extraData = stringToHex(options.overrides?.accountSalt ?? \"\");\n  return readContract({\n    contract: factoryContract,\n    method: \"function getAddress(address, bytes) returns (address)\",\n    params: [adminAddress, extraData],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareCreateAccount(args: {\n  factoryContract: ThirdwebContract;\n  options: SmartAccountOptions;\n}): PreparedTransaction {\n  const { factoryContract, options } = args;\n  if (options.overrides?.createAccount) {\n    return options.overrides.createAccount(factoryContract);\n  }\n  return prepareContractCall({\n    contract: factoryContract,\n    method: \"function createAccount(address, bytes) returns (address)\",\n    params: [\n      options.personalAccount.address,\n      stringToHex(options.overrides?.accountSalt ?? \"\"),\n    ],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareExecute(args: {\n  accountContract: ThirdwebContract;\n  options: SmartAccountOptions;\n  transaction: SendTransactionOption;\n}): PreparedTransaction {\n  const { accountContract, options, transaction } = args;\n  if (options.overrides?.execute) {\n    return options.overrides.execute(accountContract, transaction);\n  }\n  return prepareContractCall({\n    contract: accountContract,\n    method: \"function execute(address, uint256, bytes)\",\n    params: [\n      transaction.to || \"\",\n      transaction.value || 0n,\n      transaction.data || \"0x\",\n    ],\n  });\n}\n\n/**\n * @internal\n */\nexport function prepareBatchExecute(args: {\n  accountContract: ThirdwebContract;\n  options: SmartAccountOptions;\n  transactions: SendTransactionOption[];\n}): PreparedTransaction {\n  const { accountContract, options, transactions } = args;\n  if (options.overrides?.executeBatch) {\n    return options.overrides.executeBatch(accountContract, transactions);\n  }\n  return prepareContractCall({\n    contract: accountContract,\n    method: \"function executeBatch(address[], uint256[], bytes[])\",\n    params: [\n      transactions.map((tx) => tx.to || \"\"),\n      transactions.map((tx) => tx.value || 0n),\n      transactions.map((tx) => tx.data || \"0x\"),\n    ],\n  });\n}\n","import {\n  type SignableMessage,\n  type TypedData,\n  type TypedDataDefinition,\n  type TypedDataDomain,\n  hashTypedData,\n} from \"viem\";\nimport type { Chain } from \"../../chains/types.js\";\nimport { getCachedChain } from \"../../chains/utils.js\";\nimport { type ThirdwebContract, getContract } from \"../../contract/contract.js\";\nimport type { WaitForReceiptOptions } from \"../../transaction/actions/wait-for-tx-receipt.js\";\nimport {\n  populateEip712Transaction,\n  signEip712Transaction,\n} from \"../../transaction/actions/zksync/send-eip712-transaction.js\";\nimport type { PreparedTransaction } from \"../../transaction/prepare-transaction.js\";\nimport type { TransactionReceipt } from \"../../transaction/types.js\";\nimport type { Hex } from \"../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parseTypedData.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n  Wallet,\n} from \"../interfaces/wallet.js\";\nimport type {\n  CreateWalletArgs,\n  WalletConnectionOption,\n  WalletId,\n} from \"../wallet-types.js\";\nimport {\n  broadcastZkTransaction,\n  bundleUserOp,\n  getUserOpReceipt,\n  getZkPaymasterData,\n} from \"./lib/bundler.js\";\nimport {\n  predictAddress,\n  prepareBatchExecute,\n  prepareExecute,\n} from \"./lib/calls.js\";\nimport { DEFAULT_ACCOUNT_FACTORY } from \"./lib/constants.js\";\nimport { createUnsignedUserOp, signUserOp } from \"./lib/userop.js\";\nimport { isNativeAAChain } from \"./lib/utils.js\";\nimport type {\n  SmartAccountOptions,\n  SmartWalletConnectionOptions,\n  SmartWalletOptions,\n} from \"./types.js\";\n\n/**\n * Checks if the provided wallet is a smart wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is a smart wallet, false otherwise.\n */\nexport function isSmartWallet(\n  wallet: Wallet<WalletId>,\n): wallet is Wallet<\"smart\"> {\n  return wallet.id === \"smart\";\n}\n\n/**\n * We can get the personal account for given smart account but not the other way around - this map gives us the reverse lookup\n * @internal\n */\nexport const personalAccountToSmartAccountMap = new WeakMap<\n  Account,\n  Wallet<\"smart\">\n>();\n\nconst smartWalletToPersonalAccountMap = new WeakMap<Wallet<\"smart\">, Account>();\n\n/**\n * @internal\n */\nexport async function connectSmartWallet(\n  wallet: Wallet<\"smart\">,\n  connectionOptions: WalletConnectionOption<\"smart\">,\n  creationOptions: CreateWalletArgs<\"smart\">[1],\n): Promise<[Account, Chain]> {\n  const { personalAccount, client, chain: connectChain } = connectionOptions;\n\n  if (!personalAccount) {\n    throw new Error(\"Personal wallet does not have an account\");\n  }\n\n  const options = creationOptions;\n  const factoryAddress = options.factoryAddress ?? DEFAULT_ACCOUNT_FACTORY;\n  const chain = connectChain ?? options.chain;\n  const sponsorGas =\n    \"gasless\" in options ? options.gasless : options.sponsorGas;\n\n  if (isNativeAAChain(chain)) {\n    return [\n      createZkSyncAccount({\n        creationOptions,\n        connectionOptions,\n        chain,\n        sponsorGas,\n      }),\n      chain,\n    ];\n  }\n\n  const factoryContract = getContract({\n    client: client,\n    address: factoryAddress,\n    chain: chain,\n  });\n\n  // TODO: listen for chainChanged event on the personal wallet and emit the disconnect event on the smart wallet\n  const accountAddress = await predictAddress(factoryContract, {\n    personalAccountAddress: personalAccount.address,\n    ...options,\n  })\n    .then((address) => address)\n    .catch((err) => {\n      throw new Error(\n        `Failed to get account address with factory contract ${factoryContract.address} on chain ID ${chain.id}. Are you on the right chain?`,\n        { cause: err },\n      );\n    });\n\n  const accountContract = getContract({\n    client,\n    address: accountAddress,\n    chain,\n  });\n\n  const account = await createSmartAccount({\n    ...options,\n    chain,\n    sponsorGas,\n    personalAccount,\n    accountContract,\n    factoryContract,\n    client,\n  });\n\n  personalAccountToSmartAccountMap.set(personalAccount, wallet);\n  smartWalletToPersonalAccountMap.set(wallet, personalAccount);\n\n  return [account, chain] as const;\n}\n\n/**\n * @internal\n */\nexport async function disconnectSmartWallet(\n  wallet: Wallet<\"smart\">,\n): Promise<void> {\n  // look up the personalAccount for the smart wallet\n  const personalAccount = smartWalletToPersonalAccountMap.get(wallet);\n  if (personalAccount) {\n    // remove the mappings\n    personalAccountToSmartAccountMap.delete(personalAccount);\n    smartWalletToPersonalAccountMap.delete(wallet);\n  }\n}\n\nasync function createSmartAccount(\n  options: SmartAccountOptions,\n): Promise<Account> {\n  const { accountContract } = options;\n  const account = {\n    address: accountContract.address,\n    async sendTransaction(transaction: SendTransactionOption) {\n      const executeTx = prepareExecute({\n        accountContract,\n        options,\n        transaction,\n      });\n      return _sendUserOp({\n        executeTx,\n        options,\n      });\n    },\n    async sendBatchTransaction(transactions: SendTransactionOption[]) {\n      const executeTx = prepareBatchExecute({\n        accountContract,\n        options,\n        transactions,\n      });\n      return _sendUserOp({\n        executeTx,\n        options,\n      });\n    },\n    async signMessage({ message }: { message: SignableMessage }) {\n      const [\n        { isContractDeployed },\n        { readContract },\n        { encodeAbiParameters },\n        { hashMessage },\n        { checkContractWalletSignature },\n      ] = await Promise.all([\n        import(\"../../utils/bytecode/is-contract-deployed.js\"),\n        import(\"../../transaction/read-contract.js\"),\n        import(\"../../utils/abi/encodeAbiParameters.js\"),\n        import(\"../../utils/hashing/hashMessage.js\"),\n        import(\"../../extensions/erc1271/checkContractWalletSignature.js\"),\n      ]);\n      const isDeployed = await isContractDeployed(accountContract);\n      if (!isDeployed) {\n        console.log(\n          \"Account contract not deployed yet. Deploying account before signing message\",\n        );\n        await _deployAccount({\n          options,\n          account,\n          accountContract,\n        });\n      }\n\n      const originalMsgHash = hashMessage(message);\n      // check if the account contract supports EIP721 domain separator based signing\n      let factorySupports712 = false;\n      try {\n        // this will throw if the contract does not support it (old factories)\n        await readContract({\n          contract: accountContract,\n          method:\n            \"function getMessageHash(bytes32 _hash) public view returns (bytes32)\",\n          params: [originalMsgHash],\n        });\n        factorySupports712 = true;\n      } catch (e) {\n        // ignore\n      }\n\n      let sig: `0x${string}`;\n      if (factorySupports712) {\n        const wrappedMessageHash = encodeAbiParameters(\n          [{ type: \"bytes32\" }],\n          [originalMsgHash],\n        );\n        sig = await options.personalAccount.signTypedData({\n          domain: {\n            name: \"Account\",\n            version: \"1\",\n            chainId: options.chain.id,\n            verifyingContract: accountContract.address,\n          },\n          primaryType: \"AccountMessage\",\n          types: { AccountMessage: [{ name: \"message\", type: \"bytes\" }] },\n          message: { message: wrappedMessageHash },\n        });\n      } else {\n        sig = await options.personalAccount.signMessage({ message });\n      }\n\n      const isValid = await checkContractWalletSignature({\n        contract: accountContract,\n        message,\n        signature: sig,\n      });\n\n      if (isValid) {\n        return sig;\n      }\n      throw new Error(\n        \"Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.\",\n      );\n    },\n    async signTypedData<\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(_typedData: TypedDataDefinition<typedData, primaryType>) {\n      const typedData = parseTypedData(_typedData);\n      const [\n        { isContractDeployed },\n        { readContract },\n        { encodeAbiParameters },\n        { checkContractWalletSignedTypedData },\n      ] = await Promise.all([\n        import(\"../../utils/bytecode/is-contract-deployed.js\"),\n        import(\"../../transaction/read-contract.js\"),\n        import(\"../../utils/abi/encodeAbiParameters.js\"),\n        import(\n          \"../../extensions/erc1271/checkContractWalletSignedTypedData.js\"\n        ),\n      ]);\n      const isSelfVerifyingContract =\n        (\n          typedData.domain as TypedDataDomain\n        )?.verifyingContract?.toLowerCase() ===\n        accountContract.address?.toLowerCase();\n\n      if (isSelfVerifyingContract) {\n        // if the contract is self-verifying, we can just sign the message with the EOA (ie. adding a session key)\n        return options.personalAccount.signTypedData(typedData);\n      }\n\n      const isDeployed = await isContractDeployed(accountContract);\n      if (!isDeployed) {\n        console.log(\n          \"Account contract not deployed yet. Deploying account before signing message\",\n        );\n        await _deployAccount({\n          options,\n          account,\n          accountContract,\n        });\n      }\n\n      const originalMsgHash = hashTypedData(typedData);\n      // check if the account contract supports EIP721 domain separator based signing\n      let factorySupports712 = false;\n      try {\n        // this will throw if the contract does not support it (old factories)\n        await readContract({\n          contract: accountContract,\n          method:\n            \"function getMessageHash(bytes32 _hash) public view returns (bytes32)\",\n          params: [originalMsgHash],\n        });\n        factorySupports712 = true;\n      } catch (e) {\n        // ignore\n      }\n\n      let sig: `0x${string}`;\n      if (factorySupports712) {\n        const wrappedMessageHash = encodeAbiParameters(\n          [{ type: \"bytes32\" }],\n          [originalMsgHash],\n        );\n        sig = await options.personalAccount.signTypedData({\n          domain: {\n            name: \"Account\",\n            version: \"1\",\n            chainId: options.chain.id,\n            verifyingContract: accountContract.address,\n          },\n          primaryType: \"AccountMessage\",\n          types: { AccountMessage: [{ name: \"message\", type: \"bytes\" }] },\n          message: { message: wrappedMessageHash },\n        });\n      } else {\n        sig = await options.personalAccount.signTypedData(typedData);\n      }\n\n      const isValid = await checkContractWalletSignedTypedData({\n        contract: accountContract,\n        data: typedData,\n        signature: sig,\n      });\n\n      if (isValid) {\n        return sig;\n      }\n      throw new Error(\n        \"Unable to verify signature on smart account, please make sure the smart account is deployed and the signature is valid.\",\n      );\n    },\n  };\n  return account;\n}\n\nfunction createZkSyncAccount(args: {\n  creationOptions: SmartWalletOptions;\n  connectionOptions: SmartWalletConnectionOptions;\n  chain: Chain;\n  sponsorGas: boolean;\n}): Account {\n  const { creationOptions, connectionOptions, chain } = args;\n  const account = {\n    address: connectionOptions.personalAccount.address,\n    async sendTransaction(transaction: SendTransactionOption) {\n      // override passed tx, we have to refetch gas and fees always\n      const prepTx = {\n        data: transaction.data,\n        to: transaction.to ?? undefined,\n        value: transaction.value ?? 0n,\n        chain: getCachedChain(transaction.chainId),\n        client: connectionOptions.client,\n      };\n\n      let serializableTransaction = await populateEip712Transaction({\n        account,\n        transaction: prepTx,\n      });\n\n      if (args.sponsorGas) {\n        // get paymaster input\n        const pmData = await getZkPaymasterData({\n          options: {\n            client: connectionOptions.client,\n            overrides: creationOptions.overrides,\n            chain,\n          },\n          transaction: serializableTransaction,\n        });\n        serializableTransaction = {\n          ...serializableTransaction,\n          ...pmData,\n        };\n      }\n\n      // sign\n      const signedTransaction = await signEip712Transaction({\n        account,\n        chainId: chain.id,\n        eip712Transaction: serializableTransaction,\n      });\n\n      // broadcast via bundler\n      const txHash = await broadcastZkTransaction({\n        options: {\n          client: connectionOptions.client,\n          overrides: creationOptions.overrides,\n          chain,\n        },\n        transaction: serializableTransaction,\n        signedTransaction,\n      });\n      return {\n        transactionHash: txHash.transactionHash,\n        client: connectionOptions.client,\n        chain: chain,\n      };\n    },\n    async signMessage({ message }: { message: SignableMessage }) {\n      return connectionOptions.personalAccount.signMessage({ message });\n    },\n    async signTypedData<\n      const typedData extends TypedData | Record<string, unknown>,\n      primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n    >(_typedData: TypedDataDefinition<typedData, primaryType>) {\n      const typedData = parseTypedData(_typedData);\n      return connectionOptions.personalAccount.signTypedData(typedData);\n    },\n  };\n  return account;\n}\n\nasync function _deployAccount(args: {\n  options: SmartAccountOptions;\n  account: Account;\n  accountContract: ThirdwebContract;\n}) {\n  const { options, account, accountContract } = args;\n  const [{ sendTransaction }, { prepareTransaction }] = await Promise.all([\n    import(\"../../transaction/actions/send-transaction.js\"),\n    import(\"../../transaction/prepare-transaction.js\"),\n  ]);\n  const dummyTx = prepareTransaction({\n    client: options.client,\n    chain: options.chain,\n    to: accountContract.address,\n    value: 0n,\n    gas: 50000n, // force gas to avoid simulation error\n  });\n  const deployResult = await sendTransaction({\n    transaction: dummyTx,\n    account,\n  });\n  return deployResult;\n}\n\nasync function _sendUserOp(args: {\n  executeTx: PreparedTransaction;\n  options: SmartAccountOptions;\n}): Promise<WaitForReceiptOptions> {\n  const { executeTx, options } = args;\n  const unsignedUserOp = await createUnsignedUserOp({\n    executeTx,\n    options,\n  });\n  const signedUserOp = await signUserOp({\n    options,\n    userOp: unsignedUserOp,\n  });\n  const userOpHash = await bundleUserOp({\n    options,\n    userOp: signedUserOp,\n  });\n  // wait for tx receipt rather than return the userOp hash\n  const receipt = await waitForUserOpReceipt({\n    options,\n    userOpHash,\n  });\n\n  return {\n    client: options.client,\n    chain: options.chain,\n    transactionHash: receipt.transactionHash,\n  };\n}\n\nasync function waitForUserOpReceipt(args: {\n  options: SmartAccountOptions;\n  userOpHash: Hex;\n}): Promise<TransactionReceipt> {\n  const { options, userOpHash } = args;\n  const timeout = 120000; // 2mins\n  const interval = 1000;\n  const endtime = Date.now() + timeout;\n  while (Date.now() < endtime) {\n    const userOpReceipt = await getUserOpReceipt({ options, userOpHash });\n    if (userOpReceipt) {\n      return userOpReceipt;\n    }\n    await new Promise((resolve) => setTimeout(resolve, interval));\n  }\n  throw new Error(\"Timeout waiting for userOp to be mined\");\n}\n","import { BaseError } from '../../errors/base.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { ByteArray, Hex } from '../../types/misc.js'\nimport {\n  type CreateCursorErrorType,\n  type Cursor,\n  createCursor,\n} from '../cursor.js'\n\nimport { type HexToBytesErrorType, hexToBytes } from './toBytes.js'\nimport { type BytesToHexErrorType, bytesToHex } from './toHex.js'\n\nexport type RecursiveArray<T> = T | readonly RecursiveArray<T>[]\n\ntype To = 'hex' | 'bytes'\n\ntype Encodable = {\n  length: number\n  encode(cursor: Cursor): void\n}\n\nexport type ToRlpReturnType<to extends To> =\n  | (to extends 'bytes' ? ByteArray : never)\n  | (to extends 'hex' ? Hex : never)\n\nexport type ToRlpErrorType =\n  | CreateCursorErrorType\n  | BytesToHexErrorType\n  | HexToBytesErrorType\n  | ErrorType\n\nexport function toRlp<to extends To = 'hex'>(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  const encodable = getEncodable(bytes)\n  const cursor = createCursor(new Uint8Array(encodable.length))\n  encodable.encode(cursor)\n\n  if (to === 'hex') return bytesToHex(cursor.bytes) as ToRlpReturnType<to>\n  return cursor.bytes as ToRlpReturnType<to>\n}\n\nexport type BytesToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function bytesToRlp<to extends To = 'bytes'>(\n  bytes: RecursiveArray<ByteArray>,\n  to: to | To | undefined = 'bytes',\n): ToRlpReturnType<to> {\n  return toRlp(bytes, to)\n}\n\nexport type HexToRlpErrorType = ToRlpErrorType | ErrorType\n\nexport function hexToRlp<to extends To = 'hex'>(\n  hex: RecursiveArray<Hex>,\n  to: to | To | undefined = 'hex',\n): ToRlpReturnType<to> {\n  return toRlp(hex, to)\n}\n\nfunction getEncodable(\n  bytes: RecursiveArray<ByteArray> | RecursiveArray<Hex>,\n): Encodable {\n  if (Array.isArray(bytes))\n    return getEncodableList(bytes.map((x) => getEncodable(x)))\n  return getEncodableBytes(bytes as any)\n}\n\nfunction getEncodableList(list: Encodable[]): Encodable {\n  const bodyLength = list.reduce((acc, x) => acc + x.length, 0)\n\n  const sizeOfBodyLength = getSizeOfLength(bodyLength)\n  const length = (() => {\n    if (bodyLength <= 55) return 1 + bodyLength\n    return 1 + sizeOfBodyLength + bodyLength\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bodyLength <= 55) {\n        cursor.pushByte(0xc0 + bodyLength)\n      } else {\n        cursor.pushByte(0xc0 + 55 + sizeOfBodyLength)\n        if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength)\n        else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength)\n        else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength)\n        else cursor.pushUint32(bodyLength)\n      }\n      for (const { encode } of list) {\n        encode(cursor)\n      }\n    },\n  }\n}\n\nfunction getEncodableBytes(bytesOrHex: ByteArray | Hex): Encodable {\n  const bytes =\n    typeof bytesOrHex === 'string' ? hexToBytes(bytesOrHex) : bytesOrHex\n\n  const sizeOfBytesLength = getSizeOfLength(bytes.length)\n  const length = (() => {\n    if (bytes.length === 1 && bytes[0] < 0x80) return 1\n    if (bytes.length <= 55) return 1 + bytes.length\n    return 1 + sizeOfBytesLength + bytes.length\n  })()\n\n  return {\n    length,\n    encode(cursor: Cursor) {\n      if (bytes.length === 1 && bytes[0] < 0x80) {\n        cursor.pushBytes(bytes)\n      } else if (bytes.length <= 55) {\n        cursor.pushByte(0x80 + bytes.length)\n        cursor.pushBytes(bytes)\n      } else {\n        cursor.pushByte(0x80 + 55 + sizeOfBytesLength)\n        if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length)\n        else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length)\n        else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length)\n        else cursor.pushUint32(bytes.length)\n        cursor.pushBytes(bytes)\n      }\n    },\n  }\n}\n\nfunction getSizeOfLength(length: number) {\n  if (length < 2 ** 8) return 1\n  if (length < 2 ** 16) return 2\n  if (length < 2 ** 24) return 3\n  if (length < 2 ** 32) return 4\n  throw new BaseError('Length is too large.')\n}\n","// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts\n\nimport type { AbiParameter, TypedData, TypedDataDomain } from 'abitype'\n\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { TypedDataDefinition } from '../../types/typedData.js'\nimport {\n  type EncodeAbiParametersErrorType,\n  encodeAbiParameters,\n} from '../abi/encodeAbiParameters.js'\nimport { concat } from '../data/concat.js'\nimport { type ToHexErrorType, toHex } from '../encoding/toHex.js'\nimport { type Keccak256ErrorType, keccak256 } from '../hash/keccak256.js'\nimport {\n  type GetTypesForEIP712DomainErrorType,\n  type ValidateTypedDataErrorType,\n  getTypesForEIP712Domain,\n  validateTypedData,\n} from '../typedData.js'\n\ntype MessageTypeProperty = {\n  name: string\n  type: string\n}\n\nexport type HashTypedDataParameters<\n  typedData extends TypedData | Record<string, unknown> = TypedData,\n  primaryType extends keyof typedData | 'EIP712Domain' = keyof typedData,\n> = TypedDataDefinition<typedData, primaryType>\n\nexport type HashTypedDataReturnType = Hex\n\nexport type HashTypedDataErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | HashStructErrorType\n  | ValidateTypedDataErrorType\n  | ErrorType\n\nexport function hashTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(\n  parameters: HashTypedDataParameters<typedData, primaryType>,\n): HashTypedDataReturnType {\n  const {\n    domain = {},\n    message,\n    primaryType,\n  } = parameters as HashTypedDataParameters\n  const types = {\n    EIP712Domain: getTypesForEIP712Domain({ domain }),\n    ...parameters.types,\n  }\n\n  // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n  // as we can't statically check this with TypeScript.\n  validateTypedData({\n    domain,\n    message,\n    primaryType,\n    types,\n  })\n\n  const parts: Hex[] = ['0x1901']\n  if (domain)\n    parts.push(\n      hashDomain({\n        domain,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  if (primaryType !== 'EIP712Domain')\n    parts.push(\n      hashStruct({\n        data: message,\n        primaryType,\n        types: types as Record<string, MessageTypeProperty[]>,\n      }),\n    )\n\n  return keccak256(concat(parts))\n}\n\nexport type HashDomainErrorType = HashStructErrorType | ErrorType\n\nexport function hashDomain({\n  domain,\n  types,\n}: {\n  domain: TypedDataDomain\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  return hashStruct({\n    data: domain,\n    primaryType: 'EIP712Domain',\n    types,\n  })\n}\n\ntype HashStructErrorType = EncodeDataErrorType | Keccak256ErrorType | ErrorType\n\nfunction hashStruct({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  const encoded = encodeData({\n    data,\n    primaryType,\n    types,\n  })\n  return keccak256(encoded)\n}\n\ntype EncodeDataErrorType =\n  | EncodeAbiParametersErrorType\n  | EncodeFieldErrorType\n  | HashTypeErrorType\n  | ErrorType\n\nfunction encodeData({\n  data,\n  primaryType,\n  types,\n}: {\n  data: Record<string, unknown>\n  primaryType: string\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  const encodedTypes: AbiParameter[] = [{ type: 'bytes32' }]\n  const encodedValues: unknown[] = [hashType({ primaryType, types })]\n\n  for (const field of types[primaryType]) {\n    const [type, value] = encodeField({\n      types,\n      name: field.name,\n      type: field.type,\n      value: data[field.name],\n    })\n    encodedTypes.push(type)\n    encodedValues.push(value)\n  }\n\n  return encodeAbiParameters(encodedTypes, encodedValues)\n}\n\ntype HashTypeErrorType =\n  | ToHexErrorType\n  | EncodeTypeErrorType\n  | Keccak256ErrorType\n  | ErrorType\n\nfunction hashType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  const encodedHashType = toHex(encodeType({ primaryType, types }))\n  return keccak256(encodedHashType)\n}\n\ntype EncodeTypeErrorType = FindTypeDependenciesErrorType\n\nfunction encodeType({\n  primaryType,\n  types,\n}: {\n  primaryType: string\n  types: Record<string, MessageTypeProperty[]>\n}) {\n  let result = ''\n  const unsortedDeps = findTypeDependencies({ primaryType, types })\n  unsortedDeps.delete(primaryType)\n\n  const deps = [primaryType, ...Array.from(unsortedDeps).sort()]\n  for (const type of deps) {\n    result += `${type}(${types[type]\n      .map(({ name, type: t }) => `${t} ${name}`)\n      .join(',')})`\n  }\n\n  return result\n}\n\ntype FindTypeDependenciesErrorType = ErrorType\n\nfunction findTypeDependencies(\n  {\n    primaryType: primaryType_,\n    types,\n  }: {\n    primaryType: string\n    types: Record<string, MessageTypeProperty[]>\n  },\n  results: Set<string> = new Set(),\n): Set<string> {\n  const match = primaryType_.match(/^\\w*/u)\n  const primaryType = match?.[0]!\n  if (results.has(primaryType) || types[primaryType] === undefined) {\n    return results\n  }\n\n  results.add(primaryType)\n\n  for (const field of types[primaryType]) {\n    findTypeDependencies({ primaryType: field.type, types }, results)\n  }\n  return results\n}\n\ntype EncodeFieldErrorType =\n  | Keccak256ErrorType\n  | EncodeAbiParametersErrorType\n  | ToHexErrorType\n  | ErrorType\n\nfunction encodeField({\n  types,\n  name,\n  type,\n  value,\n}: {\n  types: Record<string, MessageTypeProperty[]>\n  name: string\n  type: string\n  value: any\n}): [type: AbiParameter, value: any] {\n  if (types[type] !== undefined) {\n    return [\n      { type: 'bytes32' },\n      keccak256(encodeData({ data: value, primaryType: type, types })),\n    ]\n  }\n\n  if (type === 'bytes') {\n    const prepend = value.length % 2 ? '0' : ''\n    value = `0x${prepend + value.slice(2)}`\n    return [{ type: 'bytes32' }, keccak256(value)]\n  }\n\n  if (type === 'string') return [{ type: 'bytes32' }, keccak256(toHex(value))]\n\n  if (type.lastIndexOf(']') === type.length - 1) {\n    const parsedType = type.slice(0, type.lastIndexOf('['))\n    const typeValuePairs = (value as [AbiParameter, any][]).map((item) =>\n      encodeField({\n        name,\n        type: parsedType,\n        types,\n        value: item,\n      }),\n    )\n    return [\n      { type: 'bytes32' },\n      keccak256(\n        encodeAbiParameters(\n          typeValuePairs.map(([t]) => t),\n          typeValuePairs.map(([, v]) => v),\n        ),\n      ),\n    ]\n  }\n\n  return [{ type }, value]\n}\n","export const arrayRegex = /^(.*)\\[([0-9]*)\\]$/\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n","import type { TypedData, TypedDataDomain, TypedDataParameter } from 'abitype'\n\nimport { BytesSizeMismatchError } from '../errors/abi.js'\nimport { InvalidAddressError } from '../errors/address.js'\nimport type { Hex } from '../types/misc.js'\nimport type { TypedDataDefinition } from '../types/typedData.js'\n\nimport type { ErrorType } from '../errors/utils.js'\nimport { type IsAddressErrorType, isAddress } from './address/isAddress.js'\nimport { type SizeErrorType, size } from './data/size.js'\nimport { type NumberToHexErrorType, numberToHex } from './encoding/toHex.js'\nimport { bytesRegex, integerRegex } from './regex.js'\nimport {\n  type HashDomainErrorType,\n  hashDomain,\n} from './signature/hashTypedData.js'\n\nexport type ValidateTypedDataErrorType =\n  | HashDomainErrorType\n  | IsAddressErrorType\n  | NumberToHexErrorType\n  | SizeErrorType\n  | ErrorType\n\nexport function validateTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | 'EIP712Domain',\n>(parameters: TypedDataDefinition<typedData, primaryType>) {\n  const { domain, message, primaryType, types } =\n    parameters as unknown as TypedDataDefinition\n\n  const validateData = (\n    struct: readonly TypedDataParameter[],\n    data: Record<string, unknown>,\n  ) => {\n    for (const param of struct) {\n      const { name, type } = param\n      const value = data[name]\n\n      const integerMatch = type.match(integerRegex)\n      if (\n        integerMatch &&\n        (typeof value === 'number' || typeof value === 'bigint')\n      ) {\n        const [_type, base, size_] = integerMatch\n        // If number cannot be cast to a sized hex value, it is out of range\n        // and will throw.\n        numberToHex(value, {\n          signed: base === 'int',\n          size: Number.parseInt(size_) / 8,\n        })\n      }\n\n      if (type === 'address' && typeof value === 'string' && !isAddress(value))\n        throw new InvalidAddressError({ address: value })\n\n      const bytesMatch = type.match(bytesRegex)\n      if (bytesMatch) {\n        const [_type, size_] = bytesMatch\n        if (size_ && size(value as Hex) !== Number.parseInt(size_))\n          throw new BytesSizeMismatchError({\n            expectedSize: Number.parseInt(size_),\n            givenSize: size(value as Hex),\n          })\n      }\n\n      const struct = types[type]\n      if (struct) validateData(struct, value as Record<string, unknown>)\n    }\n  }\n\n  // Validate domain types.\n  if (types.EIP712Domain && domain) validateData(types.EIP712Domain, domain)\n\n  if (primaryType !== 'EIP712Domain') {\n    // Validate message types.\n    const type = types[primaryType]\n    validateData(type, message)\n  }\n}\n\nexport type GetTypesForEIP712DomainErrorType = ErrorType\n\nexport function getTypesForEIP712Domain({\n  domain,\n}: { domain?: TypedDataDomain | undefined }): TypedDataParameter[] {\n  return [\n    typeof domain?.name === 'string' && { name: 'name', type: 'string' },\n    domain?.version && { name: 'version', type: 'string' },\n    typeof domain?.chainId === 'number' && {\n      name: 'chainId',\n      type: 'uint256',\n    },\n    domain?.verifyingContract && {\n      name: 'verifyingContract',\n      type: 'address',\n    },\n    domain?.salt && { name: 'salt', type: 'bytes32' },\n  ].filter(Boolean) as TypedDataParameter[]\n}\n\nexport type DomainSeparatorErrorType =\n  | GetTypesForEIP712DomainErrorType\n  | HashDomainErrorType\n  | ErrorType\n\nexport function domainSeparator({ domain }: { domain: TypedDataDomain }): Hex {\n  return hashDomain({\n    domain,\n    types: {\n      EIP712Domain: getTypesForEIP712Domain({ domain }),\n    },\n  })\n}\n"],"names":["parseTypedData","typedData","domain","undefined","chainId","isHex","hexToNumber","toBigInt","value","includes","Number","isInteger","Error","concat","Uint8Array","BigInt","uint8ArrayToHex","gasPerPubdataDefault","getEip712Domain","transaction","message","gas","nonce","to","from","maxFeePerGas","maxPriorityFeePerGas","paymaster","paymasterInput","gasPerPubdata","data","txType","gasLimit","gasPerPubdataByteLimit","factoryDeps","transactionToMessage","name","version","types","Transaction","type","primaryType","async","signEip712Transaction","options","account","eip712Transaction","eip712Domain","customSignature","signTypedData","serializedTransaction","toHex","values","toRlp","reduce","acc","x","replace","serializeTransactionEIP712","populateEip712Transaction","Promise","all","encode","resolvePromisedValue","eip712","then","rpc","getRpcClient","result","method","params","address","numberToHex","gas_limit","max_fee_per_gas","max_priority_fee_per_gas","gas_per_pubdata_limit","toSerializableTransaction","toEventSelector","toSignatureHash","docsPath","decodeTopic","_ref","param","match","decodeAbiParameters","parseEventLogs","abi","eventName","logs","strict","map","log","event","parameters","strict_","topics","signature","argTopics","AbiEventSignatureEmptyTopicsError","abiItem","find","formatAbiItem","AbiEventSignatureNotFoundError","inputs","isUnnamed","some","args","indexedInputs","filter","indexed","i","length","topic","DecodeLogTopicsMismatch","nonIndexedInputs","decodedData","err","AbiDecodingDataSizeTooSmallError","PositionOutOfBoundsError","DecodeLogDataMismatch","size","Object","decodeEventLog","_err$abiItem$inputs","Boolean","FilterTypeNotSupportedError","BaseError","constructor","super","defineProperty","isArgOfType","arg","abiParameter","argType","abiParameterType","isAddress","components","every","component","index","test","Array","isArray","getAmbiguousTypes","sourceParameters","targetParameters","parameterIndex","sourceParameter","targetParameter","encodeEventTopics","item","isSelector","abiItems","toFunctionSelector","matchedAbiItem","ambiguousTypes","AbiItemAmbiguityError","getAbiItem","AbiEventNotFoundError","definition","_abiItem$inputs","_indexedInputs$map","args_","_indexedInputs$map2","_","j","encodeArg","keccak256","toBytes","encodeAbiParameters","userOperationRevertReasonEvent","resolvedSignature","parseAbiItem","abiEvent","hash","toEventHash","filters","prepareEvent","arguments","zkSyncSepolia","defineChain","id","nativeCurrency","decimals","symbol","blockExplorers","url","apiUrl","zkSync","generateRandomUint192","rand1","Math","floor","random","rand2","rand3","rand4","rand5","rand6","randomNonce","hexlifyUserOp","userOp","fromEntries","entries","key","val","estimateUserOpGas","_args$options$overrid3","_args$options$overrid4","res","sendBundlerRequest","operation","overrides","entrypointAddress","ENTRYPOINT_ADDRESS_v0_6","preVerificationGas","hexToBigInt","verificationGas","verificationGasLimit","callGasLimit","MANAGED_ACCOUNT_GAS_BUFFER","getUserOpReceipt","userOpHash","success","_logs$","revertReason","events","viem_parseEventLogs","e","transactionHash","revertMsg","decodeErrorResult","join","receipt","_options$overrides$bu","_options$overrides","DEBUG","console","debug","bundlerUrl","getDefaultBundlerUrl","chain","fetchWithHeaders","getClientFetch","client","response","headers","body","stringify","jsonrpc","json","ok","error","statusText","JSON","code","status","getPaymasterAndData","_options$overrides$en","_options$overrides3","_res$error","_options$overrides2","paymasterUrl","getDefaultPaymasterUrl","entrypoint","paymasterAndData","createUnsignedUserOp","executeTx","initCode","isContractDeployed","accountContract","factoryContract","deployTx","_options$overrides4","_options$overrides$ac2","_options$overrides5","createAccount","prepareContractCall","contract","personalAccount","stringToHex","accountSalt","prepareCreateAccount","getAccountInitCode","callData","isThirdwebUrl","bundlerGasPrice","getUserOpGasPrice","resolvedMaxFeePerGas","resolvedMaxPriorityFeePerGas","_ref2","feeData","getDefaultGasOverrides","partialOp","sender","DUMMY_SIGNATURE","sponsorGas","paymasterResult","estimates","paymasterResult2","signUserOp","entryPoint","hashedInitCode","hashedCallData","hashedPaymasterAndData","packedUserOp","encoded","getUserOpHash","signMessage","raw","hexToBytes","isSmartWallet","wallet","personalAccountToSmartAccountMap","WeakMap","smartWalletToPersonalAccountMap","connectSmartWallet","connectionOptions","creationOptions","_options$factoryAddre","connectChain","factoryAddress","DEFAULT_ACCOUNT_FACTORY","gasless","isNativeAAChain","createZkSyncAccount","getContract","accountAddress","_options$overrides$ac","predictAddress","adminAddress","personalAccountAddress","extraData","readContract","catch","cause","sendTransaction","_options$overrides6","execute","prepareExecute","_sendUserOp","sendBatchTransaction","transactions","_options$overrides7","executeBatch","tx","prepareBatchExecute","hashMessage","checkContractWalletSignature","_deployAccount","originalMsgHash","sig","factorySupports712","wrappedMessageHash","verifyingContract","AccountMessage","_typedData","_typedData$domain","_accountContract$addr","checkContractWalletSignedTypedData","toLowerCase","hashTypedData","createSmartAccount","set","disconnectSmartWallet","get","delete","_transaction$to","_transaction$value","prepTx","getCachedChain","serializableTransaction","pmData","getZkPaymasterData","signedTransaction","txHash","broadcastZkTransaction","prepareTransaction","dummyTx","unsignedUserOp","signedUserOp","_args$options$overrid","_args$options$overrid2","bundleUserOp","timeout","interval","endtime","Date","now","userOpReceipt","resolve","setTimeout","waitForUserOpReceipt","bytes","encodable","getEncodable","cursor","createCursor","bytesToHex","list","bodyLength","sizeOfBodyLength","getSizeOfLength","pushByte","pushUint8","pushUint16","pushUint24","pushUint32","getEncodableList","bytesOrHex","sizeOfBytesLength","pushBytes","getEncodableBytes","EIP712Domain","getTypesForEIP712Domain","validateTypedData","parts","push","hashStruct","hashDomain","encodeData","_ref3","encodedTypes","encodedValues","hashType","field","encodeField","_ref4","encodedHashType","_ref5","unsortedDeps","findTypeDependencies","deps","sort","_ref6","t","encodeType","_ref7","primaryType_","results","Set","has","add","_ref8","prepend","slice","lastIndexOf","parsedType","typeValuePairs","_ref9","_ref10","v","bytesRegex","integerRegex","validateData","struct","integerMatch","_type","base","size_","signed","parseInt","InvalidAddressError","bytesMatch","BytesSizeMismatchError","expectedSize","givenSize","salt"],"sourceRoot":""}