(self.webpackChunkbru_finance=self.webpackChunkbru_finance||[]).push([[15406],{6492:(e,t,r)=>{"use strict";r.d(t,{E:()=>l,R:()=>i,S:()=>o,a:()=>c});var a=r(2776),n=r(97665),s=r(70592);const i=(()=>n.z.union([n.z.date().transform((e=>a.gH.from(Math.floor(e.getTime()/1e3)))),n.z.number().transform((e=>a.gH.from(e)))]))(),o=(()=>i.default(new Date(0)))(),l=(()=>i.default(new Date(Date.now()+31536e7)))();function c(e,t){if(!e)throw new s.x(t);return e}},90755:(e,t,r)=>{"use strict";r.d(t,{C:()=>c});var a=r(54705),n=r(3404),s=r(70592),i=r(36859),o=r(3494),l=r(33409);class c{constructor(e,t){(0,a.A)(this,"featureName",s.d4.name),(0,a.A)(this,"setAll",(0,o.f)((async(e,t)=>{const r=t||await this.contractWrapper.getSignerAddress(),a=new l.C(this.contractWrapper),i=Object.keys(e);(0,n.A)(i.length,"you must provide at least one role to set"),(0,n.A)(i.every((e=>this.roles.includes(e))),"this contract does not support the given role");const c=await this.getAll(),u=[],f=i.sort((e=>"admin"===e?1:-1));for(let n=0;n<f.length;n++){var h,p;const t=f[n],[i,o]=await Promise.all([Promise.all((null===(h=e[t])||void 0===h?void 0:h.map((e=>(0,s.aL)(e))))||[]),Promise.all((null===(p=c[t])||void 0===p?void 0:p.map((e=>(0,s.aL)(e))))||[])]),l=i.filter((e=>!o.includes(e))),m=o.filter((e=>!i.includes(e)));if(m.length>1){const e=m.indexOf(r);e>-1&&(m.splice(e,1),m.push(r))}if(l.length&&l.forEach((e=>{u.push(a.encode("grantRole",[(0,s.H)(t),e]))})),m.length){(await Promise.all(m.map((e=>this.getRevokeRoleFunctionName(e))))).forEach(((e,r)=>u.push(a.encode(e,[(0,s.H)(t),m[r]]))))}}return o.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[u]})}))),(0,a.A)(this,"grant",(0,o.f)((async(e,t)=>{(0,n.A)(this.roles.includes(e),'this contract does not support the "'.concat(e,'" role'));const r=await(0,s.aL)(t);return o.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:"grantRole",args:[(0,s.H)(e),r]})}))),(0,a.A)(this,"revoke",(0,o.f)((async(e,t)=>{(0,n.A)(this.roles.includes(e),'this contract does not support the "'.concat(e,'" role'));const r=await(0,s.aL)(t),a=await this.getRevokeRoleFunctionName(r);return o.T.fromContractWrapper({contractWrapper:this.contractWrapper,method:a,args:[(0,s.H)(e),r]})}))),this.contractWrapper=e,this.roles=t}async getAll(){(0,n.A)(this.roles.length,"this contract has no support for roles");const e={},t=Object.entries(this.roles);return(await Promise.all(t.map((e=>{let[,t]=e;return this.get(t)})))).forEach(((r,a)=>e[t[a][1]]=r)),e}async get(e){(0,n.A)(this.roles.includes(e),'this contract does not support the "'.concat(e,'" role'));const t=this.contractWrapper;if((0,i.h)("getRoleMemberCount",t)&&(0,i.h)("getRoleMember",t)){const r=(0,s.H)(e),a=(await t.read("getRoleMemberCount",[r])).toNumber();return await Promise.all(Array.from(Array(a).keys()).map((e=>t.read("getRoleMember",[r,e]))))}throw new Error("Contract does not support enumerating roles. Please implement IPermissionsEnumerable to unlock this functionality.")}async verify(e,t){await Promise.all(e.map((async e=>{const[r,a]=await Promise.all([this.get(e),(0,s.aL)(t)]);if(!r.map((e=>e.toLowerCase())).includes(a.toLowerCase()))throw new s.o(a,e)})))}async getRevokeRoleFunctionName(e){const[t,r]=await Promise.all([(0,s.aL)(e),this.contractWrapper.getSignerAddress()]);return r.toLowerCase()===t.toLowerCase()?"renounceRole":"revokeRole"}}},16487:(e,t,r)=>{"use strict";r.d(t,{B:()=>l,C:()=>c,N:()=>u,a:()=>f,s:()=>h});var a=r(70592),n=r(97665),s=r(33409);const i=(()=>n.z.object({}).catchall(n.z.union([a.cx,n.z.unknown()])))(),o=(()=>n.z.union([n.z.array(n.z.array(i)).transform((e=>e.flat())),n.z.array(i),i]).optional().nullable())(),l=(()=>n.z.object({name:n.z.union([n.z.string(),n.z.number()]).optional().nullable(),description:n.z.string().nullable().optional().nullable(),image:a.cy.nullable().optional(),animation_url:a.cy.optional().nullable()}))(),c=(()=>l.extend({external_url:a.cy.nullable().optional(),background_color:a.cz.optional().nullable(),properties:o,attributes:o}).catchall(n.z.union([a.cx,n.z.unknown()])))(),u=(()=>n.z.union([c,n.z.string()]))(),f=(()=>c.extend({id:n.z.string(),uri:n.z.string(),image:n.z.string().nullable().optional(),external_url:n.z.string().nullable().optional(),animation_url:n.z.string().nullable().optional()}))();async function h(e,t,n,i){if(!(0,s.i)(n)){const s=(await Promise.resolve().then(r.t.bind(r,96337,19))).default,o=e.getSigner(),l=e.getProvider(),c=new a.cs(o||l,n,s,e.options,e.storage),u=await e.getSignerAddress(),f=e.address;return(await c.read("allowance",[u,f])).lt(t)&&await c.sendTransaction("approve",[f,t]),i}i.value=t}},33820:(e,t,r)=>{"use strict";r.d(t,{A:()=>W,B:()=>ne,C:()=>re,D:()=>U,E:()=>q,F:()=>E,H:()=>G,I:()=>N,J:()=>O,K:()=>te,L:()=>ae,M:()=>me,S:()=>se,a:()=>j,f:()=>F,n:()=>ie,r:()=>ue,s:()=>fe,t:()=>he,u:()=>pe,v:()=>de,w:()=>ye,x:()=>ge,y:()=>ee,z:()=>D});var a=r(64301),n=r(73594),s=r(84794),i=r(81237),o=r(19547),l=r(2776),c=r(89106),u=r(2614),f=r(70592),h=r(33409),p=r(4265),m=r(54705),d=r(26382),y=r(90789),g=r.n(y),b=r(43336);class w{print(){w.print(this)}bufferIndexOf(e,t){if(arguments.length>2&&void 0!==arguments[2]&&arguments[2])return this.binarySearch(e,t,d.Buffer.compare);return this.linearSearch(e,t,((e,t)=>e.equals(t)))}static binarySearch(e,t,r){let a=0,n=e.length-1;for(;a<=n;){const s=Math.floor((a+n)/2),i=r(e[s],t);if(0===i){for(let a=s-1;a>=0;a--)if(0!==r(e[a],t))return a+1;return 0}i<0?a=s+1:n=s-1}return-1}binarySearch(e,t,r){return w.binarySearch(e,t,r)}static linearSearch(e,t,r){for(let a=0;a<e.length;a++)if(r(e[a],t))return a;return-1}linearSearch(e,t,r){return w.linearSearch(e,t,r)}static bufferify(e){if(!d.Buffer.isBuffer(e)){if("object"===typeof e&&e.words)return d.Buffer.from(e.toString(x),"hex");if(w.isHexString(e))return d.Buffer.from(e.replace(/^0x/,""),"hex");if("string"===typeof e)return d.Buffer.from(e);if("bigint"===typeof e)return d.Buffer.from(e.toString(16),"hex");if(e instanceof Uint8Array)return d.Buffer.from(e.buffer);if("number"===typeof e){let t=e.toString();return t.length%2&&(t="0".concat(t)),d.Buffer.from(t,"hex")}if(ArrayBuffer.isView(e))return d.Buffer.from(e.buffer,e.byteOffset,e.byteLength)}return e}bigNumberify(e){return w.bigNumberify(e)}static bigNumberify(e){if("bigint"===typeof e)return e;if("string"===typeof e)return e.startsWith("0x")&&w.isHexString(e)?BigInt("0x"+e.replace("0x","").toString()):BigInt(e);if(d.Buffer.isBuffer(e))return BigInt("0x"+e.toString("hex"));if(e instanceof Uint8Array)return function(e){const t=Array.from(e).map((e=>e.toString(16).padStart(2,"0"))).join("");return BigInt("0x".concat(t))}(e);if("number"===typeof e)return BigInt(e);throw new Error("cannot bigNumberify")}static isHexString(e){return"string"===typeof e&&/^(0x)?[0-9A-Fa-f]*$/.test(e)}static print(e){console.log(e.toString())}bufferToHex(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];return w.bufferToHex(e,t)}static bufferToHex(e){return"".concat(!(arguments.length>1&&void 0!==arguments[1])||arguments[1]?"0x":"").concat((e||d.Buffer.alloc(0)).toString("hex"))}bufferify(e){return w.bufferify(e)}bufferifyFn(e){return t=>{const r=e(t);if(d.Buffer.isBuffer(r))return r;if(this.isHexString(r))return d.Buffer.from(r.replace("0x",""),"hex");if("string"===typeof r)return d.Buffer.from(r);if("bigint"===typeof r)return d.Buffer.from(t.toString(16),"hex");if(ArrayBuffer.isView(r))return d.Buffer.from(r.buffer,r.byteOffset,r.byteLength);const a=function(e){const t=new Uint8Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=parseInt(e.substring(r,r+2),16);return t.buffer}(t.toString("hex")),n=function(e){const t=new Uint8Array(e);return Array.from(t).map((e=>e.toString(16).padStart(2,"0"))).join("")}(e(a));return d.Buffer.from(n,"hex")}}isHexString(e){return w.isHexString(e)}log2(e){return 1===e?0:1+this.log2(e/2|0)}zip(e,t){return e.map(((e,r)=>[e,t[r]]))}static hexZeroPad(e,t){return"0x"+e.replace("0x","").padStart(t,"0")}}var v=w;function x(e){const t=e.words,r=new ArrayBuffer(4*t.length),a=new Uint8Array(r);for(let n=0;n<t.length;n++)a[4*n]=t[n]>>24&255,a[4*n+1]=t[n]>>16&255,a[4*n+2]=t[n]>>8&255,a[4*n+3]=255&t[n];return r}class S extends v{constructor(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(super(),(0,m.A)(this,"duplicateOdd",!1),(0,m.A)(this,"concatenator",d.Buffer.concat),(0,m.A)(this,"hashLeaves",!1),(0,m.A)(this,"isBitcoinTree",!1),(0,m.A)(this,"leaves",[]),(0,m.A)(this,"layers",[]),(0,m.A)(this,"sortLeaves",!1),(0,m.A)(this,"sortPairs",!1),(0,m.A)(this,"sort",!1),(0,m.A)(this,"fillDefaultHash",null),(0,m.A)(this,"complete",!1),r.complete){if(r.isBitcoinTree)throw new Error('option "complete" is incompatible with "isBitcoinTree"');if(r.duplicateOdd)throw new Error('option "complete" is incompatible with "duplicateOdd"')}if(this.isBitcoinTree=!!r.isBitcoinTree,this.hashLeaves=!!r.hashLeaves,this.sortLeaves=!!r.sortLeaves,this.sortPairs=!!r.sortPairs,this.complete=!!r.complete,r.fillDefaultHash)if("function"===typeof r.fillDefaultHash)this.fillDefaultHash=r.fillDefaultHash;else{if(!d.Buffer.isBuffer(r.fillDefaultHash)&&"string"!==typeof r.fillDefaultHash)throw new Error('method "fillDefaultHash" must be a function, Buffer, or string');this.fillDefaultHash=(e,t)=>r.fillDefaultHash}this.sort=!!r.sort,this.sort&&(this.sortLeaves=!0,this.sortPairs=!0),this.duplicateOdd=!!r.duplicateOdd,r.concatenator&&(this.concatenator=r.concatenator),this.hashFn=this.bufferifyFn(t),this.processLeaves(e)}getOptions(){var e,t;return{complete:this.complete,isBitcoinTree:this.isBitcoinTree,hashLeaves:this.hashLeaves,sortLeaves:this.sortLeaves,sortPairs:this.sortPairs,sort:this.sort,fillDefaultHash:null!==(e=null===(t=this.fillDefaultHash)||void 0===t?void 0:t.toString())&&void 0!==e?e:null,duplicateOdd:this.duplicateOdd}}processLeaves(e){if(this.hashLeaves&&(e=e.map(this.hashFn)),this.leaves=e.map(this.bufferify),this.sortLeaves&&(this.leaves=this.leaves.sort(d.Buffer.compare)),this.fillDefaultHash)for(let t=this.leaves.length;t<Math.pow(2,Math.ceil(Math.log2(this.leaves.length)));t++)this.leaves.push(this.bufferify(this.fillDefaultHash(t,this.hashFn)));this.createHashes(this.leaves)}createHashes(e){for(this.layers=[e];e.length>1;){const t=this.layers.length;this.layers.push([]);const r=this.complete&&1===t&&!Number.isInteger(Math.log2(e.length))?2*e.length-2**Math.ceil(Math.log2(e.length)):e.length;for(let a=0;a<e.length;a+=2){if(a>=r){this.layers[t].push(...e.slice(r));break}if(a+1===e.length&&e.length%2===1){const r=e[e.length-1];let n=r;if(this.isBitcoinTree){n=this.hashFn(this.concatenator([g()(r),g()(r)])),n=g()(this.hashFn(n)),this.layers[t].push(n);continue}if(!this.duplicateOdd){this.layers[t].push(e[a]);continue}}const n=e[a],s=a+1===e.length?n:e[a+1];let i=null;i=this.isBitcoinTree?[g()(n),g()(s)]:[n,s],this.sortPairs&&i.sort(d.Buffer.compare);let o=this.hashFn(this.concatenator(i));this.isBitcoinTree&&(o=g()(this.hashFn(o))),this.layers[t].push(o)}e=this.layers[t]}}addLeaf(e){arguments.length>1&&void 0!==arguments[1]&&arguments[1]&&(e=this.hashFn(e)),this.processLeaves(this.leaves.concat(e))}addLeaves(e){arguments.length>1&&void 0!==arguments[1]&&arguments[1]&&(e=e.map(this.hashFn)),this.processLeaves(this.leaves.concat(e))}getLeaves(e){return Array.isArray(e)?(this.hashLeaves&&(e=e.map(this.hashFn),this.sortLeaves&&(e=e.sort(d.Buffer.compare))),this.leaves.filter((t=>-1!==this.bufferIndexOf(e,t,this.sortLeaves)))):this.leaves}getLeaf(e){return e<0||e>this.leaves.length-1?d.Buffer.from([]):this.leaves[e]}getLeafIndex(e){e=this.bufferify(e);const t=this.getLeaves();for(let r=0;r<t.length;r++){if(t[r].equals(e))return r}return-1}getLeafCount(){return this.leaves.length}getHexLeaves(){return this.leaves.map((e=>this.bufferToHex(e)))}static marshalLeaves(e){return JSON.stringify(e.map((e=>S.bufferToHex(e))),null,2)}static unmarshalLeaves(e){let t=null;if("string"===typeof e)t=JSON.parse(e);else{if(!(e instanceof Object))throw new Error("Expected type of string or object");t=e}if(!t)return[];if(!Array.isArray(t))throw new Error("Expected JSON string to be array");return t.map(S.bufferify)}getLayers(){return this.layers}getHexLayers(){return this.layers.reduce(((e,t)=>(Array.isArray(t)?e.push(t.map((e=>this.bufferToHex(e)))):e.push(t),e)),[])}getLayersFlat(){const e=this.layers.reduce(((e,t)=>(Array.isArray(t)?e.unshift(...t):e.unshift(t),e)),[]);return e.unshift(d.Buffer.from([0])),e}getHexLayersFlat(){return this.getLayersFlat().map((e=>this.bufferToHex(e)))}getLayerCount(){return this.getLayers().length}getRoot(){return 0===this.layers.length?d.Buffer.from([]):this.layers[this.layers.length-1][0]||d.Buffer.from([])}getHexRoot(){return this.bufferToHex(this.getRoot())}getProof(e,t){if("undefined"===typeof e)throw new Error("leaf is required");e=this.bufferify(e);const r=[];if(!Number.isInteger(t)){t=-1;for(let r=0;r<this.leaves.length;r++)0===d.Buffer.compare(e,this.leaves[r])&&(t=r)}if(t<=-1)return[];for(let a=0;a<this.layers.length;a++){const e=this.layers[a],n=t%2,s=n?t-1:this.isBitcoinTree&&t===e.length-1&&a<this.layers.length-1?t:t+1;s<e.length&&r.push({position:n?"left":"right",data:e[s]}),t=t/2|0}return r}getHexProof(e,t){return this.getProof(e,t).map((e=>this.bufferToHex(e.data)))}getProofs(){const e=[];return this.getProofsDFS(this.layers.length-1,0,[],e),e}getProofsDFS(e,t,r,a){const n=t%2;if(-1===e)return void(n||a.push([...r].reverse()));if(t>=this.layers[e].length)return;const s=this.layers[e],i=n?t-1:t+1;let o=!1;i<s.length&&(o=!0,r.push({position:n?"left":"right",data:s[i]}));const l=2*t,c=2*t+1;this.getProofsDFS(e-1,l,r,a),this.getProofsDFS(e-1,c,r,a),o&&r.splice(r.length-1,1)}getHexProofs(){return this.getProofs().map((e=>this.bufferToHex(e.data)))}getPositionalHexProof(e,t){return this.getProof(e,t).map((e=>["left"===e.position?0:1,this.bufferToHex(e.data)]))}getProofIndices(e,t){const r=2**t;let a=new Set;for(const l of e){let e=r+l;for(;e>1;)a.add(1^e),e=e/2|0}const n=e.map((e=>r+e)),s=Array.from(a).sort(((e,t)=>e-t)).reverse();a=n.concat(s);const i=new Set,o=[];for(let l of a)if(!i.has(l))for(o.push(l);l>1&&(i.add(l),i.has(1^l));)l=l/2|0;return o.filter((t=>!e.includes(t-r)))}getProofIndicesForUnevenTree(e,t){const r=Math.ceil(Math.log2(t)),a=[];for(let i=0;i<r;i++){t%2!==0&&a.push({index:i,leavesCount:t}),t=Math.ceil(t/2)}const n=[];let s=e;for(let i=0;i<r;i++){let e=s.map((e=>e%2===0?e+1:e-1)).filter((e=>!s.includes(e)));const t=a.find((e=>{let{index:t}=e;return t===i}));t&&s.includes(t.leavesCount-1)&&(e=e.slice(0,-1)),n.push(e),s=[...new Set(s.map((e=>e%2===0?e/2:e%2===0?(e+1)/2:(e-1)/2)))]}return n}getMultiProof(e,t){this.complete||console.warn("Warning: For correct multiProofs it's strongly recommended to set complete: true"),t||(t=e,e=this.getLayersFlat());if(this.isUnevenTree()&&t.every(Number.isInteger))return this.getMultiProofForUnevenTree(t);if(!t.every(Number.isInteger)){let e=t;this.sortPairs&&(e=e.sort(d.Buffer.compare));let r=e.map((e=>this.bufferIndexOf(this.leaves,e,this.sortLeaves))).sort(((e,t)=>e===t?0:e>t?1:-1));if(!r.every((e=>-1!==e)))throw new Error("Element does not exist in Merkle tree");const a=[],n=[];let s=[];for(let t=0;t<this.layers.length;t++){const e=this.layers[t];for(let t=0;t<r.length;t++){const i=r[t],o=this.getPairNode(e,i);a.push(e[i]),o&&n.push(o),s.push(i/2|0)}r=s.filter(((e,t,r)=>r.indexOf(e)===t)),s=[]}return n.filter((e=>!a.includes(e)))}return this.getProofIndices(t,Math.log2(e.length/2|0)).map((t=>e[t]))}getMultiProofForUnevenTree(e,t){t||(t=e,e=this.getLayers());let r=[],a=t;for(const n of e){const e=[];for(const r of a){if(r%2===0){const t=r+1;if(!a.includes(t)&&n[t]){e.push(n[t]);continue}}const t=r-1;a.includes(t)||!n[t]||e.push(n[t])}r=r.concat(e);const t=new Set;for(const r of a)r%2!==0?r%2!==0?t.add((r-1)/2):t.add((r+1)/2):t.add(r/2);a=Array.from(t)}return r}getHexMultiProof(e,t){return this.getMultiProof(e,t).map((e=>this.bufferToHex(e)))}getProofFlags(e,t){if(!Array.isArray(e)||e.length<=0)throw new Error("Invalid Inputs!");let r;if(r=e.every(Number.isInteger)?[...e].sort(((e,t)=>e===t?0:e>t?1:-1)):e.map((e=>this.bufferIndexOf(this.leaves,e,this.sortLeaves))).sort(((e,t)=>e===t?0:e>t?1:-1)),!r.every((e=>-1!==e)))throw new Error("Element does not exist in Merkle tree");const a=t.map((e=>this.bufferify(e))),n=[],s=[];for(let i=0;i<this.layers.length;i++){const e=this.layers[i];r=r.reduce(((t,r)=>{if(!n.includes(e[r])){const t=this.getPairNode(e,r),i=a.includes(e[r])||a.includes(t);t&&s.push(!i),n.push(e[r]),n.push(t)}return t.push(r/2|0),t}),[])}return s}verify(e,t,r){let a=this.bufferify(t);if(r=this.bufferify(r),!Array.isArray(e)||!t||!r)return!1;for(let n=0;n<e.length;n++){const t=e[n];let r=null,s=null;if("string"===typeof t)r=this.bufferify(t),s=!0;else if(Array.isArray(t))s=0===t[0],r=this.bufferify(t[1]);else if(d.Buffer.isBuffer(t))r=t,s=!0;else{if(!(t instanceof Object))throw new Error("Expected node to be of type string or object");r=this.bufferify(t.data),s="left"===t.position}const i=[];this.isBitcoinTree?(i.push(g()(a)),i[s?"unshift":"push"](g()(r)),a=this.hashFn(this.concatenator(i)),a=g()(this.hashFn(a))):this.sortPairs?-1===d.Buffer.compare(a,r)?(i.push(a,r),a=this.hashFn(this.concatenator(i))):(i.push(r,a),a=this.hashFn(this.concatenator(i))):(i.push(a),i[s?"unshift":"push"](r),a=this.hashFn(this.concatenator(i)))}return 0===d.Buffer.compare(a,r)}verifyMultiProof(e,t,r,a,n){if(this.isUnevenTree())return this.verifyMultiProofForUnevenTree(e,t,r,a,n);const s=Math.ceil(Math.log2(a));e=this.bufferify(e),r=r.map((e=>this.bufferify(e))),n=n.map((e=>this.bufferify(e)));const i={};for(const[c,u]of this.zip(t,r))i[2**s+c]=u;for(const[c,u]of this.zip(this.getProofIndices(t,s),n))i[c]=u;let o=Object.keys(i).map((e=>Number(e))).sort(((e,t)=>e-t));o=o.slice(0,o.length-1);let l=0;for(;l<o.length;){const e=o[l];if(e>=2&&{}.hasOwnProperty.call(i,1^e)){let t=[i[e-e%2],i[e-e%2+1]];this.sortPairs&&(t=t.sort(d.Buffer.compare));const r=t[1]?this.hashFn(this.concatenator(t)):t[0];i[e/2|0]=r,o.push(e/2|0)}l+=1}return!t.length||{}.hasOwnProperty.call(i,1)&&i[1].equals(e)}verifyMultiProofWithFlags(e,t,r,a){e=this.bufferify(e),t=t.map(this.bufferify),r=r.map(this.bufferify);const n=t.length,s=a.length,i=[];let o=0,l=0,c=0;for(let u=0;u<s;u++){const e=[a[u]?o<n?t[o++]:i[l++]:r[c++],o<n?t[o++]:i[l++]].sort(d.Buffer.compare);i[u]=this.hashFn(this.concatenator(e))}return 0===d.Buffer.compare(i[s-1],e)}verifyMultiProofForUnevenTree(e,t,r,a,n){e=this.bufferify(e),r=r.map((e=>this.bufferify(e))),n=n.map((e=>this.bufferify(e)));const s=this.calculateRootForUnevenTree(t,r,a,n);return e.equals(s)}getDepth(){return this.getLayers().length-1}getLayersAsObject(){const e=this.getLayers().map((e=>e.map((e=>this.bufferToHex(e,!1))))),t=[];for(let r=0;r<e.length;r++){const a=[];for(let n=0;n<e[r].length;n++){const s={[e[r][n]]:null};if(t.length){s[e[r][n]]={};const a=t.shift(),i=Object.keys(a)[0];if(s[e[r][n]][i]=a[i],t.length){const a=t.shift(),i=Object.keys(a)[0];s[e[r][n]][i]=a[i]}}a.push(s)}t.push(...a)}return t[0]}resetTree(){this.leaves=[],this.layers=[]}getPairNode(e,t){const r=t%2===0?t+1:t-1;return r<e.length?e[r]:null}toTreeString(){const e=this.getLayersAsObject();return(0,b.asTree)(e,!0,!1)}toString(){return this.toTreeString()}isUnevenTree(e){const t=(null===e||void 0===e?void 0:e.length)||this.getDepth();return!this.isPowOf2(t)}isPowOf2(e){return e&&!(e&e-1)}calculateRootForUnevenTree(e,t,r,a){const n=this.zip(e,t).sort(((e,t)=>{let[r]=e,[a]=t;return r-a})),s=n.map((e=>{let[t]=e;return t})),i=this.getProofIndicesForUnevenTree(s,r);let o=0;const l=[];for(let u=0;u<i.length;u++){const e=i[u],t=o;o+=e.length,l[u]=this.zip(e,a.slice(t,o))}const c=[n];for(let u=0;u<l.length;u++){const e=l[u].concat(c[u]).sort(((e,t)=>{let[r]=e,[a]=t;return r-a})).map((e=>{let[,t]=e;return t})),t=c[u].map((e=>{let[t]=e;return t})),r=[...new Set(t.map((e=>e%2===0?e/2:e%2===0?(e+1)/2:(e-1)/2)))],a=[];for(let n=0;n<r.length;n++){const t=r[n],s=e[2*n],i=e[2*n+1],o=i?this.hashFn(this.concatenator([s,i])):s;a.push([t,o])}c.push(a)}return c[c.length-1][0][1]}}var P=r(6492),T=r(97665),A=r(16487);const k={randomUUID:"undefined"!==typeof crypto&&crypto.randomUUID&&crypto.randomUUID.bind(crypto)};let C;const B=new Uint8Array(16);function L(){if(!C&&(C="undefined"!==typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!C))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return C(B)}const H=[];for(let be=0;be<256;++be)H.push((be+256).toString(16).slice(1));function I(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return H[e[t+0]]+H[e[t+1]]+H[e[t+2]]+H[e[t+3]]+"-"+H[e[t+4]]+H[e[t+5]]+"-"+H[e[t+6]]+H[e[t+7]]+"-"+H[e[t+8]]+H[e[t+9]]+"-"+H[e[t+10]]+H[e[t+11]]+H[e[t+12]]+H[e[t+13]]+H[e[t+14]]+H[e[t+15]]}const R=function(e,t,r){if(k.randomUUID&&!t&&!e)return k.randomUUID();const a=(e=e||{}).random||(e.rng||L)();if(a[6]=15&a[6]|64,a[8]=63&a[8]|128,t){r=r||0;for(let e=0;e<16;++e)t[r+e]=a[e];return t}return I(a)};function N(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot,pricePerToken:e.pricePerToken,currency:e.currency,quantityLimitPerTransaction:e.maxClaimablePerWallet,waitTimeInSecondsBetweenClaims:e.waitTimeInSecondsBetweenClaims||0}}function O(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot,pricePerToken:e.pricePerToken,currency:e.currency,quantityLimitPerWallet:e.maxClaimablePerWallet,metadata:e.metadata||""}}function U(e,t){return"unlimited"===e?a.Is:n.parseUnits(e,t)}async function z(e){const t=25e3,r=Array.from({length:Math.ceil(e.length/t)},((r,a)=>e.slice(a*t,a*t+t))),a=[],n=await Promise.all(r.map((e=>f.bM.parseAsync(e))));for(const s of n)a.push(...s);return a}let E=function(e){return e[e.V1=1]="V1",e[e.V2=2]="V2",e}({});class M{constructor(e,t,r,a,n){this.storage=e,this.shardNybbles=a,this.baseUri=t,this.originalEntriesUri=r,this.tokenDecimals=n,this.shards={},this.trees={}}static async fromUri(e,t){try{const r=await t.downloadJSON(e);if(r.isShardedMerkleTree)return M.fromShardedMerkleTreeInfo(r,t)}catch(r){return}}static async fromShardedMerkleTreeInfo(e,t){return new M(t,e.baseUri,e.originalEntriesUri,e.shardNybbles,e.tokenDecimals)}static hashEntry(e,t,r,a){switch(a){case E.V1:return s.keccak256(["address","uint256"],[e.address,U(e.maxClaimable,t)]);case E.V2:return s.keccak256(["address","uint256","uint256","address"],[e.address,U(e.maxClaimable,t),U(e.price||"unlimited",r),e.currencyAddress||i.L])}}static async fetchAndCacheDecimals(e,t,r){if(!r)return 18;let a=e[r];if(void 0===a){a=(await(0,h.f)(t,r)).decimals,e[r]=a}return a}static async buildAndUpload(e,t,r,a,n){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:2;const i=await z(e),l={};for(const o of i){const e=o.address.slice(2,2+s).toLowerCase();void 0===l[e]&&(l[e]=[]),l[e].push(o)}const c={},u=await Promise.all(Object.entries(l).map((async e=>{let[a,s]=e;return[a,new S(await Promise.all(s.map((async e=>{const a=await M.fetchAndCacheDecimals(c,r,e.currencyAddress);return M.hashEntry(e,t,a,n)}))),o.keccak256,{sort:!0}).getHexRoot()]}))),f=Object.fromEntries(u),h=new S(Object.values(f),o.keccak256,{sort:!0}),p=[];for(const[o,b]of Object.entries(l)){const e={proofs:h.getProof(f[o]).map((e=>"0x"+e.data.toString("hex"))),entries:b};p.push({data:JSON.stringify(e),name:"".concat(o,".json")})}const m=await a.uploadBatch(p),d=m[0].slice(0,m[0].lastIndexOf("/")),y=await a.upload(i),g={merkleRoot:h.getHexRoot(),baseUri:d,originalEntriesUri:y,shardNybbles:s,tokenDecimals:t,isShardedMerkleTree:!0};return{shardedMerkleInfo:g,uri:await a.upload(g)}}async getProof(e,t,r){const a=e.slice(2,2+this.shardNybbles).toLowerCase();let n=this.shards[a];const s={};if(void 0===n)try{const e=this.baseUri.endsWith("/")?this.baseUri:"".concat(this.baseUri,"/");n=this.shards[a]=await this.storage.downloadJSON("".concat(e).concat(a,".json"));const i=await Promise.all(n.entries.map((async e=>{const a=await M.fetchAndCacheDecimals(s,t,e.currencyAddress);return M.hashEntry(e,this.tokenDecimals,a,r)})));this.trees[a]=new S(i,o.keccak256,{sort:!0})}catch(h){return null}const i=n.entries.find((t=>t.address.toLowerCase()===e.toLowerCase()));if(!i)return null;const l=await M.fetchAndCacheDecimals(s,t,i.currencyAddress),c=M.hashEntry(i,this.tokenDecimals,l,r),u=this.trees[a].getProof(c).map((e=>"0x"+e.data.toString("hex")));return f.bN.parseAsync({...i,proof:u.concat(n.proofs)})}async getAllEntries(){try{return await this.storage.downloadJSON(this.originalEntriesUri)}catch(e){return console.warn("Could not fetch original snapshot entries",e),[]}}}async function F(e,t,r,a,n,s){if(!r)return null;const i=r[t];if(i){const r=await n.downloadJSON(i);if(r.isShardedMerkleTree&&r.merkleRoot===t){const t=await M.fromShardedMerkleTreeInfo(r,n);return await t.getProof(e,a,s)}const o=await f.bO.parseAsync(r);if(t===o.merkleRoot)return o.claims.find((t=>t.address.toLowerCase()===e.toLowerCase()))||null}return null}function D(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot.toString(),pricePerToken:e.pricePerToken,currency:e.currency,maxClaimablePerWallet:e.quantityLimitPerTransaction,waitTimeInSecondsBetweenClaims:e.waitTimeInSecondsBetweenClaims}}function W(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot.toString(),pricePerToken:e.pricePerToken,currency:e.currency,maxClaimablePerWallet:e.quantityLimitPerWallet,waitTimeInSecondsBetweenClaims:0,metadata:e.metadata}}async function j(e,t,a,s,i){const o=e.getSigner(),c=e.getProvider(),u=(await Promise.resolve().then(r.t.bind(r,96337,19))).default,h=new f.cs(o||c,t,u,e.options,e.storage),p=await e.getSignerAddress(),m=e.address,d=await h.read("allowance",[p,m]),y=l.gH.from(a).mul(l.gH.from(s)).div(n.parseUnits("1",i));d.lt(y)&&await h.sendTransaction("approve",[m,d.add(y)])}async function q(e,t,r,s,o,u,f,m,d){let y=U(r.maxClaimablePerWallet,o),g=[c.hexZeroPad([0],32)],b=r.price,w=r.currencyAddress;try{if(!r.merkleRootHash.toString().startsWith(i.L)){const t=await F(e,r.merkleRootHash.toString(),await s(),u.getProvider(),f,d);if(t)g=t.proof,y="unlimited"===t.maxClaimable?a.Is:n.parseUnits(t.maxClaimable,o),b=void 0===t.price||"unlimited"===t.price?a.Is:await(0,p.n)(u.getProvider(),t.price,t.currencyAddress||i.L),w=t.currencyAddress||i.L;else if(d===E.V1)throw new Error("No claim found for this address")}}catch(P){if("No claim found for this address"===(null===P||void 0===P?void 0:P.message))throw P;console.warn("failed to check claim condition merkle root hash, continuing anyways",P)}const v=await u.getCallOverrides()||{},x=b.toString()!==a.Is.toString()?b:r.price,S=w!==i.L?w:r.currencyAddress;return x.gt(0)&&((0,h.i)(S)?v.value=l.gH.from(x).mul(t).div(n.parseUnits("1",o)):m&&await j(u,S,x,t,o)),{overrides:v,proofs:g,maxClaimable:y,price:x,currencyAddress:S,priceInProof:b,currencyAddressInProof:w}}const V=(()=>T.z.object({name:T.z.string(),symbol:T.z.string(),decimals:T.z.number()}))(),J=(()=>V.extend({value:f.b5,displayValue:T.z.string()}))(),_=(()=>T.z.object({name:T.z.string().optional()}).catchall(T.z.unknown()))(),Z=(()=>T.z.object({startTime:P.S,currencyAddress:T.z.string().default(f.aV),price:f.cw.default(0),maxClaimableSupply:f.cA,maxClaimablePerWallet:f.cA,waitInSeconds:f.b6.default(0),merkleRootHash:f.cB.default(c.hexZeroPad([0],32)),snapshot:T.z.optional(f.bM).nullable(),metadata:_.optional()}))(),Y=(()=>T.z.array(Z))(),K=(()=>Z.extend({availableSupply:f.cA,currentMintSupply:f.cA,currencyMetadata:J.default({value:l.gH.from("0"),displayValue:"0",symbol:"",decimals:18,name:""}),price:f.b5,waitInSeconds:f.b5,startTime:f.b5.transform((e=>new Date(1e3*e.toNumber()))),snapshot:f.bM.optional().nullable()}))();async function $(e,t,r,a,n){const s=[],i=await Promise.all(e.map((async e=>{if(e.snapshot&&e.snapshot.length>0){const i=await async function(e,t,r,a,n){const s=await z(e),i=s.map((e=>e.address));if(new Set(i).size<i.length)throw new f.s;const o=await M.buildAndUpload(s,t,r,a,n);return{merkleRoot:o.shardedMerkleInfo.merkleRoot,snapshotUri:o.uri}}(e.snapshot,t,r,a,n);s.push(i),e.merkleRootHash=i.merkleRoot}else e.merkleRootHash=c.hexZeroPad([0],32);return e})));return{inputsWithSnapshots:i,snapshotInfos:s}}async function G(e,t,r,a,n){const{inputsWithSnapshots:s,snapshotInfos:o}=await $(e,t,r,a,n),c=await Y.parseAsync(s),u=(await Promise.all(c.map((e=>async function(e,t,r,a){const n=e.currencyAddress===i.L?f.aV:e.currencyAddress,s=U(e.maxClaimableSupply,t),o=U(e.maxClaimablePerWallet,t);let l;return e.metadata&&(l="string"===typeof e.metadata?e.metadata:await a.upload(e.metadata)),{startTimestamp:e.startTime,maxClaimableSupply:s,supplyClaimed:0,maxClaimablePerWallet:o,pricePerToken:await(0,p.n)(r,e.price,n),currency:n,merkleRoot:e.merkleRootHash.toString(),waitTimeInSecondsBetweenClaims:e.waitInSeconds||0,metadata:l}}(e,t,r,a))))).sort(((e,t)=>function(e,t){const r=l.gH.from(e),a=l.gH.from(t);return r.eq(a)?0:r.gt(a)?1:-1}(e.startTimestamp,t.startTimestamp)));return{snapshotInfos:o,sortedConditions:u}}async function Q(e,t,r){if(!t)return null;const a=t[e];if(a){const t=await r.downloadJSON(a);if(t.isShardedMerkleTree&&t.merkleRoot===e){const e=await M.fromUri(a,r);return(null===e||void 0===e?void 0:e.getAllEntries())||null}{const r=await f.bO.parseAsync(t);if(e===r.merkleRoot)return r.claims.map((e=>({address:e.address,maxClaimable:e.maxClaimable,price:e.price,currencyAddress:e.currencyAddress})))}}return null}function X(e,t){return e.toString()===a.Is.toString()?"unlimited":n.formatUnits(e,t)}async function ee(e,t,r,a,n,s){var i;const o=await(0,h.a)(r,e.currency,e.pricePerToken),c=X(e.maxClaimableSupply,t),u=X(e.maxClaimablePerWallet,t),f=X(l.gH.from(e.maxClaimableSupply).sub(e.supplyClaimed),t),p=X(e.supplyClaimed,t);let m;return e.metadata&&(m=await n.downloadJSON(e.metadata)),K.parseAsync({startTime:e.startTimestamp,maxClaimableSupply:c,maxClaimablePerWallet:u,currentMintSupply:p,availableSupply:f,waitInSeconds:null===(i=e.waitTimeInSecondsBetweenClaims)||void 0===i?void 0:i.toString(),price:l.gH.from(e.pricePerToken),currency:e.currency,currencyAddress:e.currency,currencyMetadata:o,merkleRootHash:e.merkleRoot,snapshot:s?await Q(e.merkleRoot,a,n):void 0,metadata:m})}async function te(e,t,r){if(e>=r.length)throw Error("Index out of bounds - got index: ".concat(e," with ").concat(r.length," conditions"));const a=r[e].currencyMetadata.decimals,s=r[e].price,i=n.formatUnits(s,a),o=await Z.parseAsync({...r[e],price:i,...t}),l=await K.parseAsync({...o,price:s});return r.map(((t,r)=>{let s;s=r===e?l:t;const i=n.formatUnits(s.price,a);return{...s,price:i}}))}let re=function(e){return e.NotEnoughSupply="There is not enough supply to claim.",e.AddressNotAllowed="This address is not on the allowlist.",e.WaitBeforeNextClaimTransaction="Not enough time since last claim transaction. Please wait.",e.ClaimPhaseNotStarted="Claim phase has not started yet.",e.AlreadyClaimed="You have already claimed the token.",e.WrongPriceOrCurrency="Incorrect price or currency.",e.OverMaxClaimablePerWallet="Cannot claim more than maximum allowed quantity.",e.NotEnoughTokens="There are not enough tokens in the wallet to pay for the claim.",e.NoActiveClaimPhase="There is no active claim phase at the moment. Please check back in later.",e.NoClaimConditionSet="There is no claim condition set.",e.NoWallet="No wallet connected.",e.Unknown="No claim conditions found.",e}({});function ae(e){if(void 0===e){const e=Buffer.alloc(16);return R({},e),c.hexlify(u.YW(e.toString("hex")))}return c.hexlify(e)}const ne=(()=>T.z.object({to:f.b9.refine((e=>e.toLowerCase()!==i.L),{message:"Cannot create payload to mint to zero address"}),price:f.cw.default(0),currencyAddress:f.b8.default(f.aV),mintStartTime:P.S,mintEndTime:P.E,uid:T.z.string().optional().transform((e=>ae(e))),primarySaleRecipient:f.b9.default(i.L)}))(),se=(()=>ne.extend({quantity:f.cw}))(),ie=(()=>se.extend({mintStartTime:f.b5,mintEndTime:f.b5}))(),oe=(()=>ne.extend({metadata:A.N,royaltyRecipient:T.z.string().default(i.L),royaltyBps:f.cC.default(0)}))(),le=(()=>oe.extend({metadata:A.N.default(""),uri:T.z.string(),royaltyBps:f.b5,mintStartTime:f.b5,mintEndTime:f.b5}))(),ce=(()=>oe.extend({metadata:A.N.default(""),quantity:f.b6}))(),ue=(()=>ce.extend({tokenId:f.b6}))(),fe=(()=>le.extend({tokenId:f.b5,quantity:f.b5}))(),he=(()=>oe.extend({metadata:A.N.default(""),quantity:f.b5.default(1)}))(),pe=(()=>le.extend({quantity:f.b5.default(1)}))(),me=[{name:"to",type:"address"},{name:"primarySaleRecipient",type:"address"},{name:"quantity",type:"uint256"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],de=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],ye=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"tokenId",type:"uint256"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],ge=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}]},90789:e=>{e.exports=function(e){for(var t=new Buffer(e.length),r=0,a=e.length-1;r<=a;++r,--a)t[r]=e[a],t[a]=e[r];return t}},43336:function(e){e.exports=function(){function e(e,t){var r=t?"\u2514":"\u251c";return r+=e?"\u2500 ":"\u2500\u2500\u2510"}function t(e,t){var r=[];for(var a in e)e.hasOwnProperty(a)&&(t&&"function"===typeof e[a]||r.push(a));return r}function r(a,n,s,i,o,l,c){var u,f,h="",p=0,m=i.slice(0);if(m.push([n,s])&&i.length>0&&(i.forEach((function(e,t){t>0&&(h+=(e[1]?" ":"\u2502")+"  "),f||e[0]!==n||(f=!0)})),h+=e(a,s)+a,o&&("object"!==typeof n||n instanceof Date)&&(h+=": "+n),f&&(h+=" (circular ref.)"),c(h)),!f&&"object"===typeof n){var d=t(n,l);d.forEach((function(e){u=++p===d.length,r(e,n[e],u,m,o,l,c)}))}}var a={asLines:function(e,t,a,n){r(".",e,!1,[],t,"function"!==typeof a&&a,n||a)},asTree:function(e,t,a){var n="";return r(".",e,!1,[],t,a,(function(e){n+=e+"\n"})),n}};return a}()}}]);
//# sourceMappingURL=15406.1e0bde41.chunk.js.map