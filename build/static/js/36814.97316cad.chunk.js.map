{"version":3,"file":"static/js/36814.97316cad.chunk.js","mappings":"wTAyBOA,eAAeC,EACpBC,GAGA,OAaF,SAAgCA,GAE9B,GAAyB,OAArBA,EAAQC,SACV,OAAO,EAGT,MAAMC,EAAaC,MAAMC,QAAQJ,EAAQK,QACrCL,EAAQK,OAAO,IACfC,EAAAA,EAAAA,GAAmBN,EAAQK,QAG/B,OAAOL,EAAQC,SAASM,QAAQL,EAAWM,MAAM,KAAO,CAC1D,CAzBSC,CAAuB,CAAER,eADTS,EAAAA,EAAAA,GAAYV,EAAQW,UACDN,OAAQL,EAAQK,QAC5D,CCdO,MAAMO,EAAc,aACrBC,EAAY,CAChB,CACEC,KAAM,UACNC,KAAM,YAGJC,EAAa,CACjB,CACEF,KAAM,YAgBHhB,eAAemB,EAAmBN,GACvC,OAAOZ,EAAa,CAClBY,WACAN,OAAQ,CAACO,EAAaC,EAAWG,IAErC,CAeM,SAAUE,EAAoBlB,GAClC,OAAOmB,EAAAA,EAAAA,qBAAoBN,EAAW,CAACb,EAAQoB,SACjD,CAeM,SAAUC,EAAcrB,GAG5B,OAAQY,EACNM,EAAoBlB,GAASQ,MAAM,EACvC,CAaM,SAAUc,EAAoBC,GAClC,OAAOC,EAAAA,EAAAA,GAAoBR,EAAYO,GAAQ,EACjD,CAkBOzB,eAAe2B,EAAQzB,GAC5B,OAAO0B,EAAAA,EAAAA,cAAa,CAClBf,SAAUX,EAAQW,SAClBN,OAAQ,CAACO,EAAaC,EAAWG,GACjCW,OAAQ,CAAC3B,EAAQoB,UAErB,C","sources":["../node_modules/thirdweb/src/utils/bytecode/detectExtension.ts","../node_modules/thirdweb/src/extensions/erc721/__generated__/IERC721A/read/ownerOf.ts"],"sourcesContent":["import type { AbiFunction } from \"abitype\";\nimport { toFunctionSelector } from \"viem\";\nimport { getBytecode } from \"../../contract/actions/get-bytecode.js\";\nimport type { ThirdwebContract } from \"../../contract/contract.js\";\nimport type { PreparedMethod } from \"../abi/prepare-method.js\";\n\ntype DetectExtensionOptions = {\n  contract: ThirdwebContract;\n  method: string | AbiFunction | PreparedMethod<AbiFunction>;\n};\n\n/**\n * Detects if the specified method is present in the contract bytecode.\n * @param options - The options for detecting the extension.\n * @returns A promise that resolves to a boolean indicating if the extension is detected.\n * @example\n * ```ts\n * import { detectMethod } from \"thirdweb/utils/extensions/detect.js\";\n * const hasDecimals = await detectMethod({\n *  contract,\n *  method: \"function decimals() view returns (uint8)\",\n * });\n * ```\n * @contract\n */\nexport async function detectMethod(\n  options: DetectExtensionOptions,\n): Promise<boolean> {\n  const bytecode = await getBytecode(options.contract);\n  return detectMethodInBytecode({ bytecode, method: options.method });\n}\n\ntype DetectExtensionInBytecodeOptions = {\n  bytecode: string;\n  method: string | AbiFunction | PreparedMethod<AbiFunction>;\n};\n/**\n * Detects if a specific method is present in the bytecode of a contract.\n * @param options - The options for detecting the method in the bytecode.\n * @returns A boolean indicating whether the method is present in the bytecode.\n * @internal\n */\nfunction detectMethodInBytecode(options: DetectExtensionInBytecodeOptions) {\n  // if we can't get the bytecode we know the contract is not deployed\n  if (options.bytecode === \"0x\") {\n    return false;\n  }\n  // we strip the leading `0x` from the function selector\n  const fnSelector = Array.isArray(options.method)\n    ? options.method[0]\n    : toFunctionSelector(options.method);\n\n  // indexOf is slightly faster than includes\n  return options.bytecode.indexOf(fnSelector.slice(2)) > -1;\n}\n","import type { AbiParameterToPrimitiveType } from \"abitype\";\nimport { readContract } from \"../../../../../transaction/read-contract.js\";\nimport type { BaseTransactionOptions } from \"../../../../../transaction/types.js\";\nimport { encodeAbiParameters } from \"../../../../../utils/abi/encodeAbiParameters.js\";\nimport { decodeAbiParameters } from \"viem\";\nimport type { Hex } from \"../../../../../utils/encoding/hex.js\";\nimport type { ThirdwebContract } from \"../../../../../contract/contract.js\";\nimport { detectMethod } from \"../../../../../utils/bytecode/detectExtension.js\";\n\n/**\n * Represents the parameters for the \"ownerOf\" function.\n */\nexport type OwnerOfParams = {\n  tokenId: AbiParameterToPrimitiveType<{ type: \"uint256\"; name: \"tokenId\" }>;\n};\n\nexport const FN_SELECTOR = \"0x6352211e\" as const;\nconst FN_INPUTS = [\n  {\n    type: \"uint256\",\n    name: \"tokenId\",\n  },\n] as const;\nconst FN_OUTPUTS = [\n  {\n    type: \"address\",\n  },\n] as const;\n\n/**\n * Checks if the `ownerOf` method is supported by the given contract.\n * @param contract The ThirdwebContract.\n * @returns A promise that resolves to a boolean indicating if the `ownerOf` method is supported.\n * @extension ERC721\n * @example\n * ```ts\n * import { isOwnerOfSupported } from \"thirdweb/extensions/erc721\";\n *\n * const supported = await isOwnerOfSupported(contract);\n * ```\n */\nexport async function isOwnerOfSupported(contract: ThirdwebContract<any>) {\n  return detectMethod({\n    contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n  });\n}\n\n/**\n * Encodes the parameters for the \"ownerOf\" function.\n * @param options - The options for the ownerOf function.\n * @returns The encoded ABI parameters.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeOwnerOfParams } \"thirdweb/extensions/erc721\";\n * const result = encodeOwnerOfParams({\n *  tokenId: ...,\n * });\n * ```\n */\nexport function encodeOwnerOfParams(options: OwnerOfParams) {\n  return encodeAbiParameters(FN_INPUTS, [options.tokenId]);\n}\n\n/**\n * Encodes the \"ownerOf\" function into a Hex string with its parameters.\n * @param options - The options for the ownerOf function.\n * @returns The encoded hexadecimal string.\n * @extension ERC721\n * @example\n * ```ts\n * import { encodeOwnerOf } \"thirdweb/extensions/erc721\";\n * const result = encodeOwnerOf({\n *  tokenId: ...,\n * });\n * ```\n */\nexport function encodeOwnerOf(options: OwnerOfParams) {\n  // we do a \"manual\" concat here to avoid the overhead of the \"concatHex\" function\n  // we can do this because we know the specific formats of the values\n  return (FN_SELECTOR +\n    encodeOwnerOfParams(options).slice(2)) as `${typeof FN_SELECTOR}${string}`;\n}\n\n/**\n * Decodes the result of the ownerOf function call.\n * @param result - The hexadecimal result to decode.\n * @returns The decoded result as per the FN_OUTPUTS definition.\n * @extension ERC721\n * @example\n * ```ts\n * import { decodeOwnerOfResult } from \"thirdweb/extensions/erc721\";\n * const result = decodeOwnerOfResult(\"...\");\n * ```\n */\nexport function decodeOwnerOfResult(result: Hex) {\n  return decodeAbiParameters(FN_OUTPUTS, result)[0];\n}\n\n/**\n * Calls the \"ownerOf\" function on the contract.\n * @param options - The options for the ownerOf function.\n * @returns The parsed result of the function call.\n * @extension ERC721\n * @example\n * ```ts\n * import { ownerOf } from \"thirdweb/extensions/erc721\";\n *\n * const result = await ownerOf({\n *  contract,\n *  tokenId: ...,\n * });\n *\n * ```\n */\nexport async function ownerOf(options: BaseTransactionOptions<OwnerOfParams>) {\n  return readContract({\n    contract: options.contract,\n    method: [FN_SELECTOR, FN_INPUTS, FN_OUTPUTS] as const,\n    params: [options.tokenId],\n  });\n}\n"],"names":["async","detectMethod","options","bytecode","fnSelector","Array","isArray","method","toFunctionSelector","indexOf","slice","detectMethodInBytecode","getBytecode","contract","FN_SELECTOR","FN_INPUTS","type","name","FN_OUTPUTS","isOwnerOfSupported","encodeOwnerOfParams","encodeAbiParameters","tokenId","encodeOwnerOf","decodeOwnerOfResult","result","decodeAbiParameters","ownerOf","readContract","params"],"sourceRoot":""}