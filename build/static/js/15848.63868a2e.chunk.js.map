{"version":3,"file":"static/js/15848.63868a2e.chunk.js","mappings":"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","sources":["../node_modules/@thirdweb-dev/sdk/dist/cleanCurrencyAddress-ded19cfe.browser.esm.js","../node_modules/@thirdweb-dev/sdk/dist/contract-platform-fee-e756e68f.browser.esm.js","../node_modules/@thirdweb-dev/sdk/dist/marketplace-e3129e2f.browser.esm.js","../node_modules/@thirdweb-dev/sdk/dist/marketplacev3-offers-ce1f096b.browser.esm.js"],"sourcesContent":["import { aV as NATIVE_TOKEN_ADDRESS } from './index-33cd3415.browser.esm.js';\nimport { i as isNativeToken } from './fetchCurrencyValue-32d08b05.browser.esm.js';\n\n/**\n * @internal\n */\nfunction cleanCurrencyAddress(currencyAddress) {\n  if (isNativeToken(currencyAddress)) {\n    return NATIVE_TOKEN_ADDRESS;\n  }\n  return currencyAddress;\n}\n\nexport { cleanCurrencyAddress as c };\n","import { f as buildTransactionFunction, T as Transaction } from './transactions-72f9603c.browser.esm.js';\nimport { du as FEATURE_PLATFORM_FEE, bH as CommonPlatformFeeSchema } from './index-33cd3415.browser.esm.js';\n\n/**\n * Handle platform fees and recipients\n * @remarks Configure platform fees for a contract, which can be applied on certain paid transactions\n * @example\n * ```javascript\n * const contract = await sdk.getContract(\"{{contract_address}}\");\n * const feeInfo = await contract.platformFees.get();\n * await contract.platformFees.set({\n *   platform_fee_basis_points: 100, // 1% fee\n *   platform_fee_recipient: \"0x...\" // the fee recipient\n * })\n * ```\n * @public\n */\nclass ContractPlatformFee {\n  featureName = FEATURE_PLATFORM_FEE.name;\n  constructor(contractWrapper) {\n    this.contractWrapper = contractWrapper;\n  }\n\n  /**\n   * Get the platform fee recipient and basis points\n   *\n   * @example\n   * ```javascript\n   * const feeInfo = await contract.platformFees.get();\n   * console.log(feeInfo.platform_fee_recipient);\n   * console.log(feeInfo.platform_fee_basis_points);\n   * ```\n   * @twfeature PlatformFee\n   */\n  async get() {\n    const [platformFeeRecipient, platformFeeBps] = await this.contractWrapper.read(\"getPlatformFeeInfo\", []);\n    return CommonPlatformFeeSchema.parseAsync({\n      platform_fee_recipient: platformFeeRecipient,\n      platform_fee_basis_points: platformFeeBps\n    });\n  }\n\n  /**\n   * Set the platform fee recipient and basis points\n   *\n   * @example\n   * ```javascript\n   * await contract.platformFees.set({\n   *   platform_fee_basis_points: 100, // 1% fee\n   *   platform_fee_recipient: \"0x...\" // the fee recipient\n   * })\n   * ```\n   *\n   * @param platformFeeInfo - the platform fee information\n   * @twfeature PlatformFee\n   */\n  set = /* @__PURE__ */buildTransactionFunction(async platformFeeInfo => {\n    const parsed = await CommonPlatformFeeSchema.parseAsync(platformFeeInfo);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"setPlatformFeeInfo\",\n      args: [parsed.platform_fee_recipient, parsed.platform_fee_basis_points]\n    });\n  });\n}\n\nexport { ContractPlatformFee as C };\n","import { Contract, BigNumber } from 'ethers';\nimport invariant from 'tiny-invariant';\nimport { I as InterfaceId_IERC721, a as InterfaceId_IERC1155, D as DEFAULT_QUERY_ALL_COUNT } from './QueryParams-32a56510.browser.esm.js';\nimport { cs as ContractWrapper, dE as MAX_BPS } from './index-33cd3415.browser.esm.js';\nimport { a as fetchCurrencyValue } from './fetchCurrencyValue-32d08b05.browser.esm.js';\n\n/**\n * This method checks if the given token is approved for the transferrerContractAddress contract.\n * This is particularly useful for contracts that need to transfer NFTs on the users' behalf\n *\n * @internal\n * @param provider - The connected provider\n * @param transferrerContractAddress - The address of the marketplace contract\n * @param assetContract - The address of the asset contract.\n * @param tokenId - The token id of the token.\n * @param owner - The address of the account that owns the token.\n * @returns  True if the transferrerContractAddress is approved on the token, false otherwise.\n */\nasync function isTokenApprovedForTransfer(provider, transferrerContractAddress, assetContract, tokenId, owner) {\n  try {\n    const ERC165Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC165.json')).default;\n    const erc165 = new Contract(assetContract, ERC165Abi, provider);\n    const [isERC721, isERC1155] = await Promise.all([erc165.supportsInterface(InterfaceId_IERC721), erc165.supportsInterface(InterfaceId_IERC1155)]);\n    if (isERC721) {\n      const ERC721Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC721.json')).default;\n      const asset = new Contract(assetContract, ERC721Abi, provider);\n      const approved = await asset.isApprovedForAll(owner, transferrerContractAddress);\n      if (approved) {\n        return true;\n      }\n\n      // Handle reverts in case of non-existent tokens\n      let approvedAddress;\n      try {\n        approvedAddress = await asset.getApproved(tokenId);\n      } catch (e) {}\n      return approvedAddress?.toLowerCase() === transferrerContractAddress.toLowerCase();\n    } else if (isERC1155) {\n      const ERC1155Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC1155.json')).default;\n      const asset = new Contract(assetContract, ERC1155Abi, provider);\n      return await asset.isApprovedForAll(owner, transferrerContractAddress);\n    } else {\n      console.error(\"Contract does not implement ERC 1155 or ERC 721.\");\n      return false;\n    }\n  } catch (err) {\n    console.error(\"Failed to check if token is approved\", err);\n    return false;\n  }\n}\n\n/**\n * Checks if the marketplace is approved to make transfers on the assetContract\n * If not, it tries to set the approval.\n * @param contractWrapper - The contract wrapper to use\n * @param marketplaceAddress - The address of the marketplace contract\n * @param assetContract - The address of the asset contract.\n * @param tokenId - The token id of the token.\n * @param from - The address of the account that owns the token.\n */\nasync function handleTokenApproval(contractWrapper, marketplaceAddress, assetContract, tokenId, from) {\n  const ERC165Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC165.json')).default;\n  const erc165 = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, ERC165Abi, contractWrapper.options, contractWrapper.storage);\n  const [isERC721, isERC1155] = await Promise.all([erc165.read(\"supportsInterface\", [InterfaceId_IERC721]), erc165.read(\"supportsInterface\", [InterfaceId_IERC1155])]);\n  // check for token approval\n  if (isERC721) {\n    const ERC721Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC721.json')).default;\n    const asset = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, ERC721Abi, contractWrapper.options, contractWrapper.storage);\n    const approved = await asset.read(\"isApprovedForAll\", [from, marketplaceAddress]);\n    if (!approved) {\n      const isTokenApproved = (await asset.read(\"getApproved\", [tokenId])).toLowerCase() === marketplaceAddress.toLowerCase();\n      if (!isTokenApproved) {\n        await asset.sendTransaction(\"setApprovalForAll\", [marketplaceAddress, true]);\n      }\n    }\n  } else if (isERC1155) {\n    const ERC1155Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC1155.json')).default;\n    const asset = new ContractWrapper(contractWrapper.getSignerOrProvider(), assetContract, ERC1155Abi, contractWrapper.options, contractWrapper.storage);\n    const approved = await asset.read(\"isApprovedForAll\", [from, marketplaceAddress]);\n    if (!approved) {\n      await asset.sendTransaction(\"setApprovalForAll\", [marketplaceAddress, true]);\n    }\n  } else {\n    throw Error(\"Contract must implement ERC 1155 or ERC 721.\");\n  }\n}\n\n/**\n * Used to verify fields in new listing.\n * @internal\n */\n// TODO this should be done in zod\nfunction validateNewListingParam(param) {\n  invariant(param.assetContractAddress !== undefined && param.assetContractAddress !== null, \"Asset contract address is required\");\n  invariant(param.buyoutPricePerToken !== undefined && param.buyoutPricePerToken !== null, \"Buyout price is required\");\n  invariant(param.listingDurationInSeconds !== undefined && param.listingDurationInSeconds !== null, \"Listing duration is required\");\n  invariant(param.startTimestamp !== undefined && param.startTimestamp !== null, \"Start time is required\");\n  invariant(param.tokenId !== undefined && param.tokenId !== null, \"Token ID is required\");\n  invariant(param.quantity !== undefined && param.quantity !== null, \"Quantity is required\");\n  switch (param.type) {\n    case \"NewAuctionListing\":\n      {\n        invariant(param.reservePricePerToken !== undefined && param.reservePricePerToken !== null, \"Reserve price is required\");\n      }\n  }\n}\n\n/**\n * Maps a contract offer to the strict interface\n *\n * @internal\n * @param offer - The offer to map\n * @returns  An `Offer` object\n */\nasync function mapOffer(provider, listingId, offer) {\n  return {\n    quantity: offer.quantityDesired,\n    pricePerToken: offer.pricePerToken,\n    currencyContractAddress: offer.currency,\n    buyerAddress: offer.offeror,\n    quantityDesired: offer.quantityWanted,\n    currencyValue: await fetchCurrencyValue(provider, offer.currency, offer.quantityWanted.mul(offer.pricePerToken)),\n    listingId\n  };\n}\nfunction isWinningBid(winningPrice, newBidPrice, bidBuffer) {\n  bidBuffer = BigNumber.from(bidBuffer);\n  winningPrice = BigNumber.from(winningPrice);\n  newBidPrice = BigNumber.from(newBidPrice);\n  if (winningPrice.eq(BigNumber.from(0))) {\n    return false;\n  }\n  const buffer = newBidPrice.sub(winningPrice).mul(MAX_BPS).div(winningPrice);\n  return buffer.gte(bidBuffer);\n}\nasync function getAllInBatches(start, end, fn) {\n  const batches = [];\n  while (end - start > DEFAULT_QUERY_ALL_COUNT) {\n    batches.push(fn(start, start + DEFAULT_QUERY_ALL_COUNT - 1));\n    start += DEFAULT_QUERY_ALL_COUNT;\n  }\n  batches.push(fn(start, end - 1));\n  return await Promise.all(batches);\n}\n\nexport { isWinningBid as a, getAllInBatches as g, handleTokenApproval as h, isTokenApprovedForTransfer as i, mapOffer as m, validateNewListingParam as v };\n","import { BigNumber, Contract, constants, utils } from 'ethers';\nimport invariant from 'tiny-invariant';\nimport { c as cleanCurrencyAddress } from './cleanCurrencyAddress-ded19cfe.browser.esm.js';\nimport { C as ContractEncoder, a as fetchCurrencyValue, f as fetchCurrencyMetadata, i as isNativeToken } from './fetchCurrencyValue-32d08b05.browser.esm.js';\nimport { n as normalizePriceValue } from './normalizePriceValue-9851c0eb.browser.esm.js';\nimport { s as setErc20Allowance } from './setErc20Allowance-7f76f677.browser.esm.js';\nimport { b9 as AddressOrEnsSchema, b6 as BigNumberishSchema, aV as NATIVE_TOKEN_ADDRESS, cw as AmountSchema, dA as FEATURE_DIRECT_LISTINGS, aL as resolveAddress, dB as FEATURE_ENGLISH_AUCTIONS, w as AuctionHasNotEndedError, dC as FEATURE_OFFERS, aW as NATIVE_TOKENS, cs as ContractWrapper } from './index-33cd3415.browser.esm.js';\nimport { g as getAllInBatches, i as isTokenApprovedForTransfer, h as handleTokenApproval } from './marketplace-e3129e2f.browser.esm.js';\nimport { c as fetchTokenMetadataForContract, I as InterfaceId_IERC721, a as InterfaceId_IERC1155 } from './QueryParams-32a56510.browser.esm.js';\nimport { f as buildTransactionFunction, T as Transaction } from './transactions-72f9603c.browser.esm.js';\nimport { R as RawDateSchema, E as EndDateSchema } from './assertEnabled-d1700f0b.browser.esm.js';\nimport { z } from 'zod';\nimport { a as ContractEvents, G as GasCostEstimator } from './contract-appuri-5c40af52.browser.esm.js';\nimport { C as ContractInterceptor } from './contract-interceptor-d7b164a7.browser.esm.js';\n\n/**\n * @internal\n */\nconst DirectListingInputParamsSchema = /* @__PURE__ */(() => z.object({\n  /**\n   * The address of the asset being listed.\n   */\n  assetContractAddress: AddressOrEnsSchema,\n  /**\n   * The ID of the token to list.\n   */\n  tokenId: BigNumberishSchema,\n  /**\n   * The quantity of tokens to include in the listing.\n   *\n   * For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).\n   */\n  quantity: BigNumberishSchema.default(1),\n  /**\n   * The address of the currency to accept for the listing.\n   */\n  currencyContractAddress: AddressOrEnsSchema.default(NATIVE_TOKEN_ADDRESS),\n  /**\n   * The price to pay per unit of NFTs listed.\n   */\n  pricePerToken: AmountSchema,\n  /**\n   * The start time of the listing.\n   */\n  startTimestamp: RawDateSchema.default(new Date()),\n  /**\n   * The end time of the listing.\n   */\n  endTimestamp: EndDateSchema,\n  /**\n   * Whether the listing is reserved to be bought from a specific set of buyers.\n   */\n  isReservedListing: z.boolean().default(false)\n}))();\n\n/**\n * @public\n */\n\nlet Status = /*#__PURE__*/function (Status) {\n  Status[Status[\"UNSET\"] = 0] = \"UNSET\";\n  Status[Status[\"Created\"] = 1] = \"Created\";\n  Status[Status[\"Completed\"] = 2] = \"Completed\";\n  Status[Status[\"Cancelled\"] = 3] = \"Cancelled\";\n  Status[Status[\"Active\"] = 4] = \"Active\";\n  Status[Status[\"Expired\"] = 5] = \"Expired\";\n  return Status;\n}({});\n\n/**\n * Handles direct listings\n * @public\n */\nclass MarketplaceV3DirectListings {\n  featureName = FEATURE_DIRECT_LISTINGS.name;\n\n  // utilities\n\n  constructor(contractWrapper, storage) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.events = new ContractEvents(this.contractWrapper);\n    this.encoder = new ContractEncoder(this.contractWrapper);\n    this.interceptor = new ContractInterceptor(this.contractWrapper);\n    this.estimator = new GasCostEstimator(this.contractWrapper);\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /** ******************************\n   * READ FUNCTIONS\n   *******************************/\n\n  /**\n   * Get the total number of direct listings\n   *\n   * @returns Returns the total number of direct listings created.\n   * @public\n   *\n   * @example\n   * ```javascript\n   * const totalListings = await contract.directListings.getTotalCount();\n   * ```\n   * @twfeature DirectListings\n   */\n  async getTotalCount() {\n    return await this.contractWrapper.read(\"totalListings\", []);\n  }\n\n  /**\n   * Get all direct listings\n   *\n   * @example\n   * ```javascript\n   * const listings = await contract.directListings.getAll();\n   * ```\n   *\n   * @param filter - optional filter parameters\n   * @returns The Direct listing object array\n   * @twfeature DirectListings\n   */\n  async getAll(filter) {\n    const totalListings = await this.getTotalCount();\n    const start = BigNumber.from(filter?.start || 0).toNumber();\n    const end = totalListings.toNumber();\n    if (end === 0) {\n      throw new Error(`No listings exist on the contract.`);\n    }\n    let rawListings = [];\n    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read(\"getAllListings\", [startId, endId]));\n    rawListings = batches.flat();\n    const filteredListings = await this.applyFilter(rawListings, filter);\n    return await Promise.all(filteredListings.map(listing => this.mapListing(listing)));\n  }\n\n  /**\n   * Get all valid direct listings\n   *\n   * @remarks A valid listing is where the listing is active, and the creator still owns & has approved Marketplace to transfer the listed NFTs.\n   *\n   * @example\n   * ```javascript\n   * const listings = await contract.directListings.getAllValid();\n   * ```\n   *\n   * @param filter - optional filter parameters\n   * @returns The Direct listing object array\n   * @twfeature DirectListings\n   */\n  async getAllValid(filter) {\n    const totalListings = await this.getTotalCount();\n    const start = BigNumber.from(filter?.start || 0).toNumber();\n    const end = totalListings.toNumber();\n    if (end === 0) {\n      throw new Error(`No listings exist on the contract.`);\n    }\n    let rawListings = [];\n    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read(\"getAllValidListings\", [startId, endId]));\n    rawListings = batches.flat();\n    const filteredListings = await this.applyFilter(rawListings, filter);\n    return await Promise.all(filteredListings.map(listing => this.mapListing(listing)));\n  }\n\n  /**\n   * Get a single direct listing\n   *\n   * @example\n   * ```javascript\n   * const listingId = 0;\n   * const listing = await contract.directListings.getListing(listingId);\n   * ```\n   *\n   * @param listingId - the listing id\n   * @returns The Direct listing object\n   *\n   * @example\n   * ```javascript\n   * const listingId = 0;\n   * const listing = await contract.directListings.getListing(listingId);\n   * ```\n   * @twfeature DirectListings\n   */\n  async getListing(listingId) {\n    const listing = await this.contractWrapper.read(\"getListing\", [listingId]);\n    return await this.mapListing(listing);\n  }\n\n  /**\n   * Check if a buyer is approved for a specific direct listing\n   *\n   * @example\n   * ```javascript\n   * const listingId = 0;\n   * const isBuyerApproved = await contract.directListings.isBuyerApprovedForListing(listingId, \"{{wallet_address}}\");\n   * ```\n   *\n   * @param listingId - the listing id\n   * @param buyer - buyer address\n   * @twfeature DirectListings\n   */\n  async isBuyerApprovedForListing(listingId, buyer) {\n    const listing = await this.validateListing(BigNumber.from(listingId));\n    if (!listing.isReservedListing) {\n      throw new Error(`Listing ${listingId} is not a reserved listing.`);\n    }\n    return await this.contractWrapper.read(\"isBuyerApprovedForListing\", [listingId, await resolveAddress(buyer)]);\n  }\n\n  /**\n   * Check if a currency is approved for a specific direct listing\n   *\n   * @example\n   * ```javascript\n   * const listingId = 0;\n   * const currencyContractAddress = '0x1234';\n   * const isApproved = await contract.directListings.isCurrencyApprovedForListing(listingId, currencyContractAddress);\n   * ```\n   *\n   * @param listingId - the listing id\n   * @param currency - currency address\n   * @twfeature DirectListings\n   */\n  async isCurrencyApprovedForListing(listingId, currency) {\n    await this.validateListing(BigNumber.from(listingId));\n    return await this.contractWrapper.read(\"isCurrencyApprovedForListing\", [listingId, await resolveAddress(currency)]);\n  }\n\n  /**\n   * Check price per token for an approved currency\n   *\n   * @example\n   * ```javascript\n   * const listingId = 0;\n   * const currencyContractAddress = '0x1234';\n   * const price = await contract.directListings.currencyPriceForListing(listingId, currencyContractAddress);\n   * ```\n   *\n   * @param listingId - the listing id\n   * @param currencyContractAddress - currency contract address\n   * @twfeature DirectListings\n   */\n  async currencyPriceForListing(listingId, currencyContractAddress) {\n    const listing = await this.validateListing(BigNumber.from(listingId));\n    const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);\n    if (resolvedCurrencyAddress === listing.currencyContractAddress) {\n      return listing.pricePerToken;\n    }\n    const isApprovedCurrency = await this.isCurrencyApprovedForListing(listingId, resolvedCurrencyAddress);\n    if (!isApprovedCurrency) {\n      throw new Error(`Currency ${resolvedCurrencyAddress} is not approved for Listing ${listingId}.`);\n    }\n    return await this.contractWrapper.read(\"currencyPriceForListing\", [listingId, resolvedCurrencyAddress]);\n  }\n\n  /** ******************************\n   * WRITE FUNCTIONS\n   *******************************/\n\n  /**\n   * Create new direct listing\n   *\n   * @remarks Create a new listing on the marketplace where people can buy an asset directly.\n   *\n   * @example\n   * ```javascript\n   * // Data of the listing you want to create\n   * const listing = {\n   *   // address of the contract the asset you want to list is on\n   *   assetContractAddress: \"0x...\",\n   *   // token ID of the asset you want to list\n   *   tokenId: \"0\",\n   *   // how many of the asset you want to list\n   *   quantity: 1,\n   *   // address of the currency contract that will be used to pay for the listing\n   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,\n   *   // The price to pay per unit of NFTs listed.\n   *   pricePerToken: 1.5,\n   *   // when should the listing open up for offers\n   *   startTimestamp: new Date(Date.now()),\n   *   // how long the listing will be open for\n   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),\n   *   // Whether the listing is reserved for a specific set of buyers.\n   *   isReservedListing: false\n   * }\n   *\n   * const tx = await contract.directListings.createListing(listing);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const id = tx.id; // the id of the newly created listing\n   * ```\n   * @twfeature DirectListings\n   */\n  createListing = /* @__PURE__ */buildTransactionFunction(async listing => {\n    const parsedListing = await DirectListingInputParamsSchema.parseAsync(listing);\n    await handleTokenApproval(this.contractWrapper, this.getAddress(), parsedListing.assetContractAddress, parsedListing.tokenId, await this.contractWrapper.getSignerAddress());\n    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), parsedListing.pricePerToken, parsedListing.currencyContractAddress);\n    const block = await this.contractWrapper.getProvider().getBlock(\"latest\");\n    const blockTime = block.timestamp;\n    if (parsedListing.startTimestamp.lt(blockTime)) {\n      parsedListing.startTimestamp = BigNumber.from(blockTime);\n    }\n    const tx = Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"createListing\",\n      args: [{\n        assetContract: parsedListing.assetContractAddress,\n        tokenId: parsedListing.tokenId,\n        quantity: parsedListing.quantity,\n        currency: cleanCurrencyAddress(parsedListing.currencyContractAddress),\n        pricePerToken: normalizedPricePerToken,\n        startTimestamp: parsedListing.startTimestamp,\n        endTimestamp: parsedListing.endTimestamp,\n        reserved: parsedListing.isReservedListing\n      }],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"NewListing\", receipt?.logs);\n        return {\n          id: event[0].args.listingId,\n          receipt\n        };\n      }\n    });\n    tx.setGasLimitMultiple(1.2);\n    return tx;\n  });\n\n  /**\n   * Create a batch of new listings\n   *\n   * @remarks Create a batch of new listings on the marketplace\n   *\n   * @example\n   * ```javascript\n   * const listings = [...];\n   * const tx = await contract.directListings.createListingsBatch(listings);\n   * ```\n   */\n  createListingsBatch = /* @__PURE__ */buildTransactionFunction(async listings => {\n    const data = (await Promise.all(listings.map(listing => this.createListing.prepare(listing)))).map(tx => tx.encode());\n    const tx = Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"multicall\",\n      args: [data],\n      parse: receipt => {\n        const events = this.contractWrapper.parseLogs(\"NewListing\", receipt?.logs);\n        return events.map(event => {\n          return {\n            id: event.args.listingId,\n            receipt\n          };\n        });\n      }\n    });\n    tx.setGasLimitMultiple(1.2);\n    return tx;\n  });\n\n  /**\n   * Update a direct listing\n   *\n   * @param listing - the new listing information\n   *\n   * @example\n   * ```javascript\n   * // Data of the listing you want to update\n   *\n   * const listingId = 0; // ID of the listing you want to update\n   *\n   * const listing = {\n   *   // address of the contract the asset you want to list is on\n   *   assetContractAddress: \"0x...\", // should be same as original listing\n   *   // token ID of the asset you want to list\n   *   tokenId: \"0\", // should be same as original listing\n   *   // how many of the asset you want to list\n   *   quantity: 1,\n   *   // address of the currency contract that will be used to pay for the listing\n   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,\n   *   // The price to pay per unit of NFTs listed.\n   *   pricePerToken: 1.5,\n   *   // when should the listing open up for offers\n   *   startTimestamp: new Date(Date.now()), // can't change this if listing already active\n   *   // how long the listing will be open for\n   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),\n   *   // Whether the listing is reserved for a specific set of buyers.\n   *   isReservedListing: false\n   * }\n   *\n   * const tx = await contract.directListings.updateListing(listingId, listing);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const id = tx.id; // the id of the newly created listing\n   * ```\n   * @twfeature DirectListings\n   */\n  updateListing = /* @__PURE__ */buildTransactionFunction(async (listingId, listing) => {\n    const parsedListing = await DirectListingInputParamsSchema.parseAsync(listing);\n    await handleTokenApproval(this.contractWrapper, this.getAddress(), parsedListing.assetContractAddress, parsedListing.tokenId, await this.contractWrapper.getSignerAddress());\n    const normalizedPricePerToken = await normalizePriceValue(this.contractWrapper.getProvider(), parsedListing.pricePerToken, parsedListing.currencyContractAddress);\n    const tx = Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"updateListing\",\n      args: [listingId, {\n        assetContract: parsedListing.assetContractAddress,\n        tokenId: parsedListing.tokenId,\n        quantity: parsedListing.quantity,\n        currency: cleanCurrencyAddress(parsedListing.currencyContractAddress),\n        pricePerToken: normalizedPricePerToken,\n        startTimestamp: parsedListing.startTimestamp,\n        endTimestamp: parsedListing.endTimestamp,\n        reserved: parsedListing.isReservedListing\n      }],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"UpdatedListing\", receipt?.logs);\n        return {\n          id: event[0].args.listingId,\n          receipt\n        };\n      }\n    });\n    tx.setGasLimitMultiple(1.2);\n    return tx;\n  });\n\n  /**\n   * Cancel Direct Listing\n   *\n   * @remarks Cancel a direct listing on the marketplace\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the direct listing you want to cancel\n   * const listingId = 0;\n   *\n   * await contract.directListings.cancelListing(listingId);\n   * ```\n   * @twfeature DirectListings\n   */\n  cancelListing = /* @__PURE__ */buildTransactionFunction(async listingId => {\n    const tx = Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"cancelListing\",\n      args: [listingId]\n    });\n    tx.setGasLimitMultiple(1.2);\n    return tx;\n  });\n\n  /**\n   * Buy direct listing for a specific wallet\n   *\n   * @remarks Buy from a specific direct listing from the marketplace.\n   *\n   * @example\n   * ```javascript\n   * // The ID of the listing you want to buy from\n   * const listingId = 0;\n   * // Quantity of the asset you want to buy\n   * const quantityDesired = 1;\n   *\n   * await contract.directListings.buyFromListing(listingId, quantityDesired, \"{{wallet_address}}\");\n   * ```\n   *\n   * @param listingId - The listing id to buy\n   * @param quantityDesired - the quantity to buy\n   * @param receiver - optional receiver of the bought listing if different from the connected wallet\n   * @twfeature DirectListings\n   */\n  buyFromListing = /* @__PURE__ */buildTransactionFunction(async (listingId, quantityDesired, receiver) => {\n    if (receiver) {\n      receiver = await resolveAddress(receiver);\n    }\n    const listing = await this.validateListing(BigNumber.from(listingId));\n    const {\n      valid,\n      error\n    } = await this.isStillValidListing(listing, quantityDesired);\n    if (!valid) {\n      throw new Error(`Listing ${listingId} is no longer valid. ${error}`);\n    }\n    const buyFor = receiver ? receiver : await this.contractWrapper.getSignerAddress();\n    const quantity = BigNumber.from(quantityDesired);\n    const value = BigNumber.from(listing.pricePerToken).mul(quantity);\n    const overrides = (await this.contractWrapper.getCallOverrides()) || {};\n    await setErc20Allowance(this.contractWrapper, value, listing.currencyContractAddress, overrides);\n    const tx = Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"buyFromListing\",\n      args: [listingId, buyFor, quantity, listing.currencyContractAddress, value],\n      overrides\n    });\n    tx.setGasLimitMultiple(1.2);\n    return tx;\n  });\n\n  /**\n   * Approve buyer for a reserved direct listing\n   *\n   * @remarks Approve a buyer to buy from a reserved listing.\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the direct listing you want to approve buyer for\n   * const listingId = \"0\";\n   *\n   * await contract.directListings.approveBuyerForReservedListing(listingId, \"{{wallet_address}}\");\n   * ```\n   *\n   * @param listingId - The listing id to buy\n   * @param buyer - Address of buyer being approved\n   * @twfeature DirectListings\n   */\n  approveBuyerForReservedListing = /* @__PURE__ */buildTransactionFunction(async (listingId, buyer) => {\n    const isApproved = await this.isBuyerApprovedForListing(listingId, buyer);\n    if (!isApproved) {\n      const tx = Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"approveBuyerForListing\",\n        args: [listingId, buyer, true]\n      });\n      tx.setGasLimitMultiple(1.2);\n      return tx;\n    } else {\n      throw new Error(`Buyer ${buyer} already approved for listing ${listingId}.`);\n    }\n  });\n\n  /**\n   * Revoke approval of a buyer for a reserved direct listing\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the direct listing you want to approve buyer for\n   * const listingId = \"0\";\n   *\n   * await contract.directListings.revokeBuyerApprovalForReservedListing(listingId, \"{{wallet_address}}\");\n   * ```\n   *\n   * @param listingId - The listing id to buy\n   * @param buyer - Address of buyer being approved\n   */\n  revokeBuyerApprovalForReservedListing = /* @__PURE__ */buildTransactionFunction(async (listingId, buyer) => {\n    const isApproved = await this.isBuyerApprovedForListing(listingId, buyer);\n    if (isApproved) {\n      const tx = Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"approveBuyerForListing\",\n        args: [listingId, buyer, false]\n      });\n      tx.setGasLimitMultiple(1.2);\n      return tx;\n    } else {\n      throw new Error(`Buyer ${buyer} not approved for listing ${listingId}.`);\n    }\n  });\n\n  /**\n   * Approve a currency for a direct listing\n   *\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the direct listing you want to approve currency for\n   * const listingId = \"0\";\n   *\n   * await contract.directListings.approveCurrencyForListing(listingId, currencyContractAddress, pricePerTokenInCurrency);\n   * ```\n   *\n   * @param listingId - The listing id to buy\n   * @param currencyContractAddress - Address of currency being approved\n   * @param pricePerTokenInCurrency - Price per token in the currency\n   * @twfeature DirectListings\n   */\n  approveCurrencyForListing = /* @__PURE__ */buildTransactionFunction(async (listingId, currencyContractAddress, pricePerTokenInCurrency) => {\n    const listing = await this.validateListing(BigNumber.from(listingId));\n    const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);\n    if (resolvedCurrencyAddress === listing.currencyContractAddress) {\n      invariant(pricePerTokenInCurrency === listing.pricePerToken, \"Approving listing currency with a different price.\");\n    }\n    const currencyPrice = await this.contractWrapper.read(\"currencyPriceForListing\", [listingId, resolvedCurrencyAddress]);\n    invariant(pricePerTokenInCurrency === currencyPrice, \"Currency already approved with this price.\");\n    const tx = Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"approveCurrencyForListing\",\n      args: [listingId, resolvedCurrencyAddress, pricePerTokenInCurrency]\n    });\n    tx.setGasLimitMultiple(1.2);\n    return tx;\n  });\n\n  /**\n   * Revoke approval of a currency for a direct listing\n   *\n   *\n   * @example\n   * ```javascript\n   * // The listing ID of the direct listing you want to revoke currency for\n   * const listingId = \"0\";\n   *\n   * await contract.directListings.revokeCurrencyApprovalForListing(listingId, currencyContractAddress);\n   * ```\n   *\n   * @param listingId - The listing id to buy\n   * @param currencyContractAddress - Address of currency\n   * @twfeature DirectListings\n   */\n  revokeCurrencyApprovalForListing = /* @__PURE__ */buildTransactionFunction(async (listingId, currencyContractAddress) => {\n    const listing = await this.validateListing(BigNumber.from(listingId));\n    const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);\n    if (resolvedCurrencyAddress === listing.currencyContractAddress) {\n      throw new Error(`Can't revoke approval for main listing currency.`);\n    }\n    const currencyPrice = await this.contractWrapper.read(\"currencyPriceForListing\", [listingId, resolvedCurrencyAddress]);\n    invariant(!currencyPrice.isZero(), \"Currency not approved.\");\n    const tx = Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"approveCurrencyForListing\",\n      args: [listingId, resolvedCurrencyAddress, BigNumber.from(0)]\n    });\n    tx.setGasLimitMultiple(1.2);\n    return tx;\n  });\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * Throws error if listing could not be found\n   *\n   * @param listingId - Listing to check for\n   */\n  async validateListing(listingId) {\n    try {\n      return await this.getListing(listingId);\n    } catch (err) {\n      console.error(`Error getting the listing with id ${listingId}`);\n      throw err;\n    }\n  }\n\n  /**\n   * Helper method maps the auction listing to the direct listing interface.\n   *\n   * @internal\n   * @param listing - The listing to map, as returned from the contract.\n   * @returns  The mapped interface.\n   */\n  async mapListing(listing) {\n    let status = Status.UNSET;\n    const block = await this.contractWrapper.getProvider().getBlock(\"latest\");\n    const blockTime = block.timestamp;\n    switch (listing.status) {\n      case 1:\n        status = BigNumber.from(listing.startTimestamp).gt(blockTime) ? Status.Created : BigNumber.from(listing.endTimestamp).lt(blockTime) ? Status.Expired : Status.Active;\n        break;\n      case 2:\n        status = Status.Completed;\n        break;\n      case 3:\n        status = Status.Cancelled;\n        break;\n    }\n    return {\n      assetContractAddress: listing.assetContract,\n      currencyContractAddress: listing.currency,\n      pricePerToken: listing.pricePerToken.toString(),\n      currencyValuePerToken: await fetchCurrencyValue(this.contractWrapper.getProvider(), listing.currency, listing.pricePerToken),\n      id: listing.listingId.toString(),\n      tokenId: listing.tokenId.toString(),\n      quantity: listing.quantity.toString(),\n      startTimeInSeconds: BigNumber.from(listing.startTimestamp).toNumber(),\n      asset: await fetchTokenMetadataForContract(listing.assetContract, this.contractWrapper.getProvider(), listing.tokenId, this.storage),\n      endTimeInSeconds: BigNumber.from(listing.endTimestamp).toNumber(),\n      creatorAddress: listing.listingCreator,\n      isReservedListing: listing.reserved,\n      status: status\n    };\n  }\n\n  /**\n   * Use this method to check if a direct listing is still valid.\n   *\n   * Ways a direct listing can become invalid:\n   * 1. The asset holder transferred the asset to another wallet\n   * 2. The asset holder burned the asset\n   * 3. The asset holder removed the approval on the marketplace\n   *\n   * @internal\n   * @param listing - The listing to check.\n   * @returns  True if the listing is valid, false otherwise.\n   */\n  async isStillValidListing(listing, quantity) {\n    const approved = await isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), listing.assetContractAddress, listing.tokenId, listing.creatorAddress);\n    if (!approved) {\n      return {\n        valid: false,\n        error: `Token '${listing.tokenId}' from contract '${listing.assetContractAddress}' is not approved for transfer`\n      };\n    }\n    const provider = this.contractWrapper.getProvider();\n    const ERC165Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC165.json')).default;\n    const erc165 = new Contract(listing.assetContractAddress, ERC165Abi, provider);\n    const isERC721 = await erc165.supportsInterface(InterfaceId_IERC721);\n    const isERC1155 = await erc165.supportsInterface(InterfaceId_IERC1155);\n    if (isERC721) {\n      const ERC721Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC721.json')).default;\n      const asset = new Contract(listing.assetContractAddress, ERC721Abi, provider);\n\n      // Handle reverts in case of non-existent tokens\n      let owner;\n      try {\n        owner = await asset.ownerOf(listing.tokenId);\n      } catch (e) {}\n      const valid = owner?.toLowerCase() === listing.creatorAddress.toLowerCase();\n      return {\n        valid,\n        error: valid ? undefined : `Seller is not the owner of Token '${listing.tokenId}' from contract '${listing.assetContractAddress} anymore'`\n      };\n    } else if (isERC1155) {\n      const ERC1155Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC1155.json')).default;\n      const asset = new Contract(listing.assetContractAddress, ERC1155Abi, provider);\n      const balance = await asset.balanceOf(listing.creatorAddress, listing.tokenId);\n      const valid = balance.gte(quantity || listing.quantity);\n      return {\n        valid,\n        error: valid ? undefined : `Seller does not have enough balance of Token '${listing.tokenId}' from contract '${listing.assetContractAddress} to fulfill the listing`\n      };\n    } else {\n      return {\n        valid: false,\n        error: \"Contract does not implement ERC 1155 or ERC 721.\"\n      };\n    }\n  }\n  async applyFilter(listings, filter) {\n    let rawListings = [...listings];\n    if (filter) {\n      if (filter.seller) {\n        const resolvedSeller = await resolveAddress(filter.seller);\n        rawListings = rawListings.filter(seller => seller.listingCreator.toString().toLowerCase() === resolvedSeller?.toString().toLowerCase());\n      }\n      if (filter.tokenContract) {\n        const resolvedToken = await resolveAddress(filter.tokenContract);\n        rawListings = rawListings.filter(tokenContract => tokenContract.assetContract.toString().toLowerCase() === resolvedToken?.toString().toLowerCase());\n      }\n      if (filter.tokenId !== undefined) {\n        rawListings = rawListings.filter(tokenContract => tokenContract.tokenId.toString() === filter?.tokenId?.toString());\n      }\n    }\n    return filter?.count && filter.count < rawListings.length ? rawListings.slice(0, filter.count) : rawListings;\n  }\n}\n\n/**\n * @internal\n */\nconst EnglishAuctionInputParamsSchema = /* @__PURE__ */(() => z.object({\n  /**\n   * The address of the asset being auctioned.\n   */\n  assetContractAddress: AddressOrEnsSchema,\n  /**\n   * The ID of the token to auction.\n   */\n  tokenId: BigNumberishSchema,\n  /**\n   * The quantity of tokens to include in the listing.\n   *\n   * For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).\n   */\n  quantity: BigNumberishSchema.default(1),\n  /**\n   * The address of the currency to accept for the listing.\n   */\n  currencyContractAddress: AddressOrEnsSchema.default(NATIVE_TOKEN_ADDRESS),\n  /**\n   * The minimum price that a bid must be in order to be accepted.\n   */\n  minimumBidAmount: AmountSchema,\n  /**\n   * The buyout price of the auction.\n   */\n  buyoutBidAmount: AmountSchema,\n  /**\n   * This is a buffer e.g. x seconds.\n   *\n   * If a new winning bid is made less than x seconds before expirationTimestamp, the\n   * expirationTimestamp is increased by x seconds.\n   */\n  timeBufferInSeconds: BigNumberishSchema.default(900),\n  // 15 minutes by default\n\n  /**\n   * This is a buffer in basis points e.g. x%.\n   *\n   * To be considered as a new winning bid, a bid must be at least x% greater than\n   * the current winning bid.\n   */\n  bidBufferBps: BigNumberishSchema.default(500),\n  // 5% by default\n\n  /**\n   * The start time of the auction.\n   */\n  startTimestamp: RawDateSchema.default(new Date()),\n  /**\n   * The end time of the auction.\n   */\n  endTimestamp: EndDateSchema\n}))();\n\n/**\n * @public\n */\n\n/**\n * Handles auctions\n * @public\n */\nclass MarketplaceV3EnglishAuctions {\n  featureName = FEATURE_ENGLISH_AUCTIONS.name;\n\n  // utilities\n\n  constructor(contractWrapper, storage) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.events = new ContractEvents(this.contractWrapper);\n    this.encoder = new ContractEncoder(this.contractWrapper);\n    this.interceptor = new ContractInterceptor(this.contractWrapper);\n    this.estimator = new GasCostEstimator(this.contractWrapper);\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /** ******************************\n   * READ FUNCTIONS\n   *******************************/\n\n  /**\n   * Get the total number of english auctions\n   *\n   * @returns Returns the total number of auctions created.\n   * @public\n   *\n   * @example\n   * ```javascript\n   * const totalAuctions = await contract.englishAuctions.getTotalCount();\n   * ```\n   * @twfeature EnglishAuctions\n   */\n  async getTotalCount() {\n    return await this.contractWrapper.read(\"totalAuctions\", []);\n  }\n\n  /**\n   * Get all english auctions\n   *\n   * @example\n   * ```javascript\n   * const auctions = await contract.englishAuctions.getAll();\n   * ```\n   *\n   * @param filter - optional filter parameters\n   * @returns The Auction object array\n   * @twfeature EnglishAuctions\n   */\n  async getAll(filter) {\n    const totalAuctions = await this.getTotalCount();\n    const start = BigNumber.from(filter?.start || 0).toNumber();\n    const end = totalAuctions.toNumber();\n    if (end === 0) {\n      throw new Error(`No auctions exist on the contract.`);\n    }\n    let rawAuctions = [];\n    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read(\"getAllAuctions\", [startId, endId]));\n    rawAuctions = batches.flat();\n    const filteredAuctions = await this.applyFilter(rawAuctions, filter);\n    return await Promise.all(filteredAuctions.map(auction => this.mapAuction(auction)));\n  }\n\n  /**\n   * Get all valid english auctions\n   *\n   * @example\n   * ```javascript\n   * const auctions = await contract.englishAuctions.getAllValid();\n   * ```\n   *\n   * @param filter - optional filter parameters\n   * @returns The Auction object array\n   * @twfeature EnglishAuctions\n   */\n  async getAllValid(filter) {\n    const totalAuctions = await this.getTotalCount();\n    const start = BigNumber.from(filter?.start || 0).toNumber();\n    const end = totalAuctions.toNumber();\n    if (end === 0) {\n      throw new Error(`No auctions exist on the contract.`);\n    }\n    let rawAuctions = [];\n    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read(\"getAllValidAuctions\", [startId, endId]));\n    rawAuctions = batches.flat();\n    const filteredAuctions = await this.applyFilter(rawAuctions, filter);\n    return await Promise.all(filteredAuctions.map(auction => this.mapAuction(auction)));\n  }\n\n  /**\n   * Get a single english auction\n   *\n   * @example\n   * ```javascript\n   * const auctionId = 0;\n   * const auction = await contract.englishAuctions.getAuction(auctionId);\n   * ```\n   *\n   * @param auctionId - the auction Id\n   * @returns The Auction object\n   * @twfeature EnglishAuctions\n   */\n  async getAuction(auctionId) {\n    const auction = await this.contractWrapper.read(\"getAuction\", [auctionId]);\n    return await this.mapAuction(auction);\n  }\n\n  /**\n   * Get winning bid of an english auction\n   *\n   * @remarks Get the current highest bid of an active auction.\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction\n   * const auctionId = 0;\n   * const winningBid = await contract.englishAuctions.getWinningBid(auctionId);\n   * ```\n   * @param auctionId - the auction Id\n   * @twfeature EnglishAuctions\n   */\n  async getWinningBid(auctionId) {\n    await this.validateAuction(BigNumber.from(auctionId));\n    const bid = await this.contractWrapper.read(\"getWinningBid\", [auctionId]);\n    if (bid._bidder === constants.AddressZero) {\n      return undefined;\n    }\n    return await this.mapBid(auctionId.toString(), bid._bidder, bid._currency, bid._bidAmount.toString());\n  }\n\n  /**\n   * Check if a bid is or will be a winning bid\n   *\n   * @example\n   * ```javascript\n   * const auctionId = 0;\n   * const bidAmount = 100;\n   * const isWinningBid = await contract.englishAuctions.isWinningBid(auctionId, bidAmount);\n   * ```\n   *\n   * @param auctionId - Auction Id\n   * @param bidAmount - Amount to bid\n   * @returns true if the bid is or will be a winning bid\n   * @twfeature EnglishAuctions\n   */\n  async isWinningBid(auctionId, bidAmount) {\n    return await this.contractWrapper.read(\"isNewWinningBid\", [auctionId, bidAmount]);\n  }\n\n  /**\n   * Get the winner for a specific english auction\n   *\n   * @remarks Get the winner of the auction after an auction ends.\n   *\n   * @example\n   * ```javascript\n   * // The auction ID of a closed english auction\n   * const auctionId = 0;\n   * const auctionWinner = await contract.englishAuctions.getWinner(auctionId);\n   * ```\n   * @param auctionId - the auction Id\n   * @returns The address of the auction winner\n   * @twfeature EnglishAuctions\n   */\n  async getWinner(auctionId) {\n    const auction = await this.validateAuction(BigNumber.from(auctionId));\n    const bid = await this.contractWrapper.read(\"getWinningBid\", [auctionId]);\n    const now = BigNumber.from(Math.floor(Date.now() / 1000));\n    const endTime = BigNumber.from(auction.endTimeInSeconds);\n\n    // if we have a winner in the map and the current time is past the endtime of the auction return the address of the winner\n    if (now.gt(endTime) && bid._bidder !== constants.AddressZero) {\n      return bid._bidder;\n    }\n    // otherwise fall back to query filter things\n\n    // TODO this should be via indexer or direct contract call\n    const contractEvent = new ContractEvents(this.contractWrapper);\n    const closedAuctions = await contractEvent.getEvents(\"AuctionClosed\");\n    const closed = closedAuctions.find(a => a.data.auctionId.eq(BigNumber.from(auctionId)));\n    if (!closed) {\n      throw new Error(`Could not find auction with ID ${auctionId} in closed auctions`);\n    }\n    return closed.data.winningBidder;\n  }\n\n  /** ******************************\n   * WRITE FUNCTIONS\n   *******************************/\n\n  /**\n   * Create an english auction\n   *\n   * @remarks Create a new auction where people can bid on an asset.\n   *\n   * @example\n   * ```javascript\n   * // Data of the auction you want to create\n   * const auction = {\n   *   // address of the contract of the asset you want to auction\n   *   assetContractAddress: \"0x...\",\n   *   // token ID of the asset you want to auction\n   *   tokenId: \"0\",\n   *   // how many of the asset you want to auction\n   *   quantity: 1,\n   *   // address of the currency contract that will be used to pay for the auctioned tokens\n   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,\n   *   // the minimum bid that will be accepted for the token\n   *   minimumBidAmount: \"1.5\",\n   *   // how much people would have to bid to instantly buy the asset\n   *   buyoutBidAmount: \"10\",\n   *   // If a bid is made less than these many seconds before expiration, the expiration time is increased by this.\n   *   timeBufferInSeconds: \"900\", // 15 minutes by default\n   *   // A bid must be at least this much bps greater than the current winning bid\n   *   bidBufferBps: \"500\", // 5% by default\n   *   // when should the auction open up for bidding\n   *   startTimestamp: new Date(Date.now()),\n   *   // end time of auction\n   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),\n   * }\n   *\n   * const tx = await contract.englishAuctions.createAuction(auction);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const id = tx.id; // the id of the newly created auction\n   * ```\n   * @param auction - the auction data\n   * @returns The transaction hash and the auction id\n   * @twfeature EnglishAuctions\n   */\n  createAuction = /* @__PURE__ */buildTransactionFunction(async auction => {\n    const parsedAuction = EnglishAuctionInputParamsSchema.parse(auction);\n    await handleTokenApproval(this.contractWrapper, this.getAddress(), parsedAuction.assetContractAddress, parsedAuction.tokenId, await this.contractWrapper.getSignerAddress());\n    const normalizedBuyoutAmount = await normalizePriceValue(this.contractWrapper.getProvider(), parsedAuction.buyoutBidAmount, parsedAuction.currencyContractAddress);\n    const normalizedMinBidAmount = await normalizePriceValue(this.contractWrapper.getProvider(), parsedAuction.minimumBidAmount, parsedAuction.currencyContractAddress);\n    const block = await this.contractWrapper.getProvider().getBlock(\"latest\");\n    const blockTime = block.timestamp;\n    if (parsedAuction.startTimestamp.lt(blockTime)) {\n      parsedAuction.startTimestamp = BigNumber.from(blockTime);\n    }\n    const tx = Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"createAuction\",\n      args: [{\n        assetContract: parsedAuction.assetContractAddress,\n        tokenId: parsedAuction.tokenId,\n        quantity: parsedAuction.quantity,\n        currency: cleanCurrencyAddress(parsedAuction.currencyContractAddress),\n        minimumBidAmount: normalizedMinBidAmount,\n        buyoutBidAmount: normalizedBuyoutAmount,\n        timeBufferInSeconds: parsedAuction.timeBufferInSeconds,\n        bidBufferBps: parsedAuction.bidBufferBps,\n        startTimestamp: parsedAuction.startTimestamp,\n        endTimestamp: parsedAuction.endTimestamp\n      }],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"NewAuction\", receipt.logs)[0];\n        return {\n          id: event.args.auctionId,\n          receipt\n        };\n      }\n    });\n    tx.setGasLimitMultiple(1.2);\n    return tx;\n  });\n\n  /**\n   * Create a batch of new auctions\n   *\n   * @remarks Create a batch of new auctions on the marketplace\n   *\n   * @example\n   * ```javascript\n   * const auctions = [...];\n   * const tx = await contract.englishAuctions.createAuctionsBatch(auctions);\n   * ```\n   */\n  createAuctionsBatch = /* @__PURE__ */buildTransactionFunction(async listings => {\n    const data = (await Promise.all(listings.map(listing => this.createAuction.prepare(listing)))).map(tx => tx.encode());\n    const tx = Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"multicall\",\n      args: [data],\n      parse: receipt => {\n        const events = this.contractWrapper.parseLogs(\"NewAuction\", receipt?.logs);\n        return events.map(event => {\n          return {\n            id: event.args.auctionId,\n            receipt\n          };\n        });\n      }\n    });\n    tx.setGasLimitMultiple(1.2);\n    return tx;\n  });\n\n  /**\n   * Buyout an english auction\n   *\n   * @remarks Buy a specific auction from the marketplace.\n   *\n   * @example\n   * ```javascript\n   * // The auction ID you want to buy\n   * const auctionId = 0;\n   *\n   * await contract.englishAuctions.buyoutAuction(auctionId);\n   * ```\n   * @param auctionId - the auction id\n   * @returns The transaction result\n   * @twfeature EnglishAuctions\n   */\n  buyoutAuction = /* @__PURE__ */buildTransactionFunction(async auctionId => {\n    const auction = await this.validateAuction(BigNumber.from(auctionId));\n    const currencyMetadata = await fetchCurrencyMetadata(this.contractWrapper.getProvider(), auction.currencyContractAddress);\n    return this.makeBid.prepare(auctionId, utils.formatUnits(auction.buyoutBidAmount, currencyMetadata.decimals));\n  });\n\n  /**\n   * Bid on an english auction\n   *\n   * @remarks Make a bid on an auction\n   *\n   * @example\n   * ```javascript\n   * // The auction ID of the asset you want to bid on\n   * const auctionId = 0;\n   * // The total amount you are willing to bid for auctioned tokens\n   * const bidAmount = 1;\n   *\n   * await contract.englishAuctions.makeBid(auctionId, bidAmount);\n   * ```\n   * @param auctionId - the auction id\n   * @param bidAmount - the amount you are willing to bid\n   * @returns The transaction result\n   * @twfeature EnglishAuctions\n   */\n  makeBid = /* @__PURE__ */buildTransactionFunction(async (auctionId, bidAmount) => {\n    const auction = await this.validateAuction(BigNumber.from(auctionId));\n    const normalizedBidAmount = await normalizePriceValue(this.contractWrapper.getProvider(), bidAmount, auction.currencyContractAddress);\n    if (normalizedBidAmount.eq(BigNumber.from(0))) {\n      throw new Error(\"Cannot make a bid with 0 value\");\n    }\n    if (BigNumber.from(auction.buyoutBidAmount).gt(0) && normalizedBidAmount.gt(auction.buyoutBidAmount)) {\n      throw new Error(\"Bid amount must be less than or equal to buyoutBidAmount\");\n    }\n    const winningBid = await this.getWinningBid(auctionId);\n    if (winningBid) {\n      const isWinnner = await this.isWinningBid(auctionId, normalizedBidAmount);\n      invariant(isWinnner, \"Bid price is too low based on the current winning bid and the bid buffer\");\n    } else {\n      const tokenPrice = normalizedBidAmount;\n      const minimumBidAmount = BigNumber.from(auction.minimumBidAmount);\n      invariant(tokenPrice.gte(minimumBidAmount), \"Bid price is too low based on minimum bid amount\");\n    }\n    const overrides = (await this.contractWrapper.getCallOverrides()) || {};\n    await setErc20Allowance(this.contractWrapper, normalizedBidAmount, auction.currencyContractAddress, overrides);\n    const tx = Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"bidInAuction\",\n      overrides,\n      args: [auctionId, normalizedBidAmount]\n    });\n    tx.setGasLimitMultiple(1.2);\n    return tx;\n  });\n\n  /**\n   * Cancel an english auction\n   *\n   * @remarks Cancel an auction on the marketplace\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction you want to cancel\n   * const auctionId = \"0\";\n   *\n   * await contract.englishAuctions.cancelAuction(auctionId);\n   * ```\n   * @param auctionId - the auction id\n   * @returns The transaction result\n   * @twfeature EnglishAuctions\n   */\n  cancelAuction = /* @__PURE__ */buildTransactionFunction(async auctionId => {\n    const winningBid = await this.getWinningBid(auctionId);\n    if (winningBid) {\n      throw new Error(`Bids already made.`);\n    }\n    const tx = Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"cancelAuction\",\n      args: [auctionId]\n    });\n    tx.setGasLimitMultiple(1.2);\n    return tx;\n  });\n\n  /**\n   * Close the english auction for the bidder\n   *\n   * @remarks Closes the Auction and executes the sale for the buyer.\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction you want to close\n   * const auction = \"0\";\n   * await contract.englishAuctions.closeAuctionForBidder(auctionId);\n   * ```\n   *\n   * @param auctionId - the auction id to close\n   * @param closeFor - optionally pass the winning bid offeror address to close the auction on their behalf\n   * @returns The transaction result\n   * @twfeature EnglishAuctions\n   */\n  closeAuctionForBidder = /* @__PURE__ */buildTransactionFunction(async (auctionId, closeFor) => {\n    if (!closeFor) {\n      closeFor = await this.contractWrapper.getSignerAddress();\n    }\n    const auction = await this.validateAuction(BigNumber.from(auctionId));\n    try {\n      const tx = Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"collectAuctionTokens\",\n        args: [BigNumber.from(auctionId)]\n      });\n      tx.setGasLimitMultiple(1.2);\n      return tx;\n    } catch (err) {\n      if (err.message.includes(\"Marketplace: auction still active.\")) {\n        throw new AuctionHasNotEndedError(auctionId.toString(), auction.endTimeInSeconds.toString());\n      } else {\n        throw err;\n      }\n    }\n  });\n\n  /**\n   * Close the english auction for the seller\n   *\n   * @remarks Closes the Auction and executes the sale for the seller.\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction you want to close\n   * const auctionId = \"0\";\n   * await contract.englishAuctions.closeAuctionForSeller(auctionId);\n   * ```\n   *\n   * @param auctionId - the auction id to close\n   * @returns The transaction result\n   * @twfeature EnglishAuctions\n   */\n  closeAuctionForSeller = /* @__PURE__ */buildTransactionFunction(async auctionId => {\n    const auction = await this.validateAuction(BigNumber.from(auctionId));\n    try {\n      const tx = Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"collectAuctionPayout\",\n        args: [BigNumber.from(auctionId)]\n      });\n      tx.setGasLimitMultiple(1.2);\n      return tx;\n    } catch (err) {\n      if (err.message.includes(\"Marketplace: auction still active.\")) {\n        throw new AuctionHasNotEndedError(auctionId.toString(), auction.endTimeInSeconds.toString());\n      } else {\n        throw err;\n      }\n    }\n  });\n\n  /**\n   * Close the english auction for both the seller and the bidder\n   *\n   * @remarks Closes the Auction and executes the sale for both parties.\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction you want to close\n   * const auction = \"0\";\n   * await contract.englishAuctions.executeSale(auctionId);\n   * ```\n   *\n   * @param auctionId - the auction to close\n   * @returns The transaction result\n   * @twfeature EnglishAuctions\n   */\n  executeSale = /* @__PURE__ */buildTransactionFunction(async auctionId => {\n    const auction = await this.validateAuction(BigNumber.from(auctionId));\n    try {\n      const winningBid = await this.getWinningBid(auctionId);\n      invariant(winningBid, \"No winning bid found\");\n      const closeForSeller = this.encoder.encode(\"collectAuctionPayout\", [auctionId]);\n      const closeForBuyer = this.encoder.encode(\"collectAuctionTokens\", [auctionId]);\n      const tx = Transaction.fromContractWrapper({\n        contractWrapper: this.contractWrapper,\n        method: \"multicall\",\n        args: [[closeForSeller, closeForBuyer]]\n      });\n      tx.setGasLimitMultiple(1.2);\n      return tx;\n    } catch (err) {\n      if (err.message.includes(\"Marketplace: auction still active.\")) {\n        throw new AuctionHasNotEndedError(auctionId.toString(), auction.endTimeInSeconds.toString());\n      } else {\n        throw err;\n      }\n    }\n  });\n\n  /**\n   * Get the buffer for an english auction\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction you want to get the buffer for\n   * const auctionId = \"0\";\n   * const buffer = await contract.englishAuctions.getBidBufferBps(auctionId);\n   * ```\n   *\n   * @param auctionId - id of the auction\n   * @returns The buffer in basis points\n   * @twfeature EnglishAuctions\n   */\n  async getBidBufferBps(auctionId) {\n    return (await this.getAuction(auctionId)).bidBufferBps;\n  }\n\n  /**\n   * Get the minimum next bid for an english auction\n   *\n   * @example\n   * ```javascript\n   * // The ID of the auction you want to get the minimum next bid for\n   * const auctionId = \"0\";\n   * const minimumNextBid = await contract.englishAuctions.getMinimumNextBid(auctionId);\n   * ```\n   *\n   * @returns The minimum bid a user can place to outbid the previous highest bid\n   * @param auctionId - id of the auction\n   * @twfeature EnglishAuctions\n   */\n  async getMinimumNextBid(auctionId) {\n    // we can fetch all of these at the same time using promise.all\n    const [currentBidBufferBps, winningBid, auction] = await Promise.all([this.getBidBufferBps(auctionId), this.getWinningBid(auctionId), this.validateAuction(BigNumber.from(auctionId))]);\n    const currentBidOrReservePrice = winningBid ?\n    // if there is a winning bid use the value of it\n    BigNumber.from(winningBid.bidAmount) :\n    // if there is no winning bid use the reserve price\n    BigNumber.from(auction.minimumBidAmount);\n    const minimumNextBid = currentBidOrReservePrice.add(\n    // the addition of the current bid and the buffer\n    // (have to divide by 10000 to get the fraction of the buffer (since it's in basis points))\n    currentBidOrReservePrice.mul(currentBidBufferBps).div(10000));\n\n    // it's more useful to return a currency value here\n    return fetchCurrencyValue(this.contractWrapper.getProvider(), auction.currencyContractAddress, minimumNextBid);\n  }\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * Throws error if auction could not be found\n   *\n   * @param auctionId - Auction to check for\n   */\n  async validateAuction(auctionId) {\n    try {\n      return await this.getAuction(auctionId);\n    } catch (err) {\n      console.error(`Error getting the auction with id ${auctionId}`);\n      throw err;\n    }\n  }\n\n  /**\n   * Helper method maps the auction to the auction interface.\n   *\n   * @internal\n   * @param auction - The auction to map, as returned from the contract.\n   * @returns  The mapped interface.\n   */\n  async mapAuction(auction) {\n    let status = Status.UNSET;\n    const block = await this.contractWrapper.getProvider().getBlock(\"latest\");\n    const blockTime = block.timestamp;\n    switch (auction.status) {\n      case 1:\n        status = BigNumber.from(auction.startTimestamp).gt(blockTime) ? Status.Created : BigNumber.from(auction.endTimestamp).lt(blockTime) ? Status.Expired : Status.Active;\n        break;\n      case 2:\n        status = Status.Completed;\n        break;\n      case 3:\n        status = Status.Cancelled;\n        break;\n    }\n    return {\n      id: auction.auctionId.toString(),\n      creatorAddress: auction.auctionCreator,\n      assetContractAddress: auction.assetContract,\n      tokenId: auction.tokenId.toString(),\n      quantity: auction.quantity.toString(),\n      currencyContractAddress: auction.currency,\n      minimumBidAmount: auction.minimumBidAmount.toString(),\n      minimumBidCurrencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), auction.currency, auction.minimumBidAmount),\n      buyoutBidAmount: auction.buyoutBidAmount.toString(),\n      buyoutCurrencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), auction.currency, auction.buyoutBidAmount),\n      timeBufferInSeconds: BigNumber.from(auction.timeBufferInSeconds).toNumber(),\n      bidBufferBps: BigNumber.from(auction.bidBufferBps).toNumber(),\n      startTimeInSeconds: BigNumber.from(auction.startTimestamp).toNumber(),\n      endTimeInSeconds: BigNumber.from(auction.endTimestamp).toNumber(),\n      asset: await fetchTokenMetadataForContract(auction.assetContract, this.contractWrapper.getProvider(), auction.tokenId, this.storage),\n      status: status\n    };\n  }\n\n  /**\n   * Maps an auction-bid to the strict interface\n   *\n   * @internal\n   * @param bid - The bid to map, as returned from the contract.\n   * @returns  A `Bid` object\n   */\n  async mapBid(auctionId, bidderAddress, currencyContractAddress, bidAmount) {\n    const resolvedBidderAddress = await resolveAddress(bidderAddress);\n    const resolvedCurrencyAddress = await resolveAddress(currencyContractAddress);\n    return {\n      auctionId,\n      bidderAddress: resolvedBidderAddress,\n      currencyContractAddress: resolvedCurrencyAddress,\n      bidAmount,\n      bidAmountCurrencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), resolvedCurrencyAddress, bidAmount)\n    };\n  }\n  async applyFilter(auctions, filter) {\n    let rawAuctions = [...auctions];\n    if (filter) {\n      if (filter.seller) {\n        const resolvedSeller = await resolveAddress(filter.seller);\n        rawAuctions = rawAuctions.filter(seller => seller.auctionCreator.toString().toLowerCase() === resolvedSeller?.toString().toLowerCase());\n      }\n      if (filter.tokenContract) {\n        const resolvedToken = await resolveAddress(filter.tokenContract);\n        rawAuctions = rawAuctions.filter(tokenContract => tokenContract.assetContract.toString().toLowerCase() === resolvedToken?.toString().toLowerCase());\n      }\n      if (filter.tokenId !== undefined) {\n        rawAuctions = rawAuctions.filter(tokenContract => tokenContract.tokenId.toString() === filter?.tokenId?.toString());\n      }\n    }\n    return filter?.count && filter.count < rawAuctions.length ? rawAuctions.slice(0, filter.count) : rawAuctions;\n  }\n}\n\n/**\n * @internal\n */\nconst OfferInputParamsSchema = /* @__PURE__ */(() => z.object({\n  /**\n   * The address of the asset being sought.\n   */\n  assetContractAddress: AddressOrEnsSchema,\n  /**\n   * The ID of the token.\n   */\n  tokenId: BigNumberishSchema,\n  /**\n   * The quantity of tokens to buy.\n   *\n   * For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).\n   */\n  quantity: BigNumberishSchema.default(1),\n  /**\n   * The address of the currency offered for the NFTs.\n   */\n  currencyContractAddress: AddressOrEnsSchema.default(NATIVE_TOKEN_ADDRESS),\n  /**\n   * The total offer amount for the NFTs.\n   */\n  totalPrice: AmountSchema,\n  /**\n   * The end time of the offer.\n   */\n  endTimestamp: EndDateSchema\n}))();\n\n/**\n * @public\n */\n\n/**\n * Handles marketplace offers\n * @public\n */\nclass MarketplaceV3Offers {\n  featureName = FEATURE_OFFERS.name;\n\n  // utilities\n\n  constructor(contractWrapper, storage) {\n    this.contractWrapper = contractWrapper;\n    this.storage = storage;\n    this.events = new ContractEvents(this.contractWrapper);\n    this.encoder = new ContractEncoder(this.contractWrapper);\n    this.interceptor = new ContractInterceptor(this.contractWrapper);\n    this.estimator = new GasCostEstimator(this.contractWrapper);\n  }\n  getAddress() {\n    return this.contractWrapper.address;\n  }\n\n  /** ******************************\n   * READ FUNCTIONS\n   *******************************/\n\n  /**\n   * Get the total number of offers\n   *\n   * @returns Returns the total number of offers created.\n   * @public\n   *\n   * @example\n   * ```javascript\n   * const totalOffers = await contract.offers.getTotalCount();\n   * ```\n   * @twfeature Offers\n   */\n  async getTotalCount() {\n    return await this.contractWrapper.read(\"totalOffers\", []);\n  }\n\n  /**\n   * Get all offers\n   *\n   * @example\n   * ```javascript\n   * const offers = await contract.offers.getAll();\n   * ```\n   *\n   * @param filter - optional filter parameters\n   * @returns The Offer object array\n   * @twfeature Offers\n   */\n  async getAll(filter) {\n    const totalOffers = await this.getTotalCount();\n    const start = BigNumber.from(filter?.start || 0).toNumber();\n    const end = totalOffers.toNumber();\n    if (end === 0) {\n      throw new Error(`No offers exist on the contract.`);\n    }\n    let rawOffers = [];\n    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read(\"getAllOffers\", [startId, endId]));\n    rawOffers = batches.flat();\n    const filteredOffers = await this.applyFilter(rawOffers, filter);\n    return await Promise.all(filteredOffers.map(offer => this.mapOffer(offer)));\n  }\n\n  /**\n   * Get all valid offers\n   *\n   * @example\n   * ```javascript\n   * const offers = await contract.offers.getAllValid();\n   * ```\n   *\n   * @param filter - optional filter parameters\n   * @returns The Offer object array\n   * @twfeature Offers\n   */\n  async getAllValid(filter) {\n    const totalOffers = await this.getTotalCount();\n    const start = BigNumber.from(filter?.start || 0).toNumber();\n    const end = totalOffers.toNumber();\n    if (end === 0) {\n      throw new Error(`No offers exist on the contract.`);\n    }\n    let rawOffers = [];\n    const batches = await getAllInBatches(start, end, (startId, endId) => this.contractWrapper.read(\"getAllValidOffers\", [startId, endId]));\n    rawOffers = batches.flat();\n    const filteredOffers = await this.applyFilter(rawOffers, filter);\n    return await Promise.all(filteredOffers.map(offer => this.mapOffer(offer)));\n  }\n\n  /**\n   * Get a single offer\n   *\n   * @example\n   * ```javascript\n   * const offerId = 0;\n   * const offer = await contract.offers.getOffer(offerId);\n   * ```\n   *\n   * @param offerId - the listing id\n   * @returns The Direct listing object\n   * @twfeature Offers\n   */\n  async getOffer(offerId) {\n    const offer = await this.contractWrapper.read(\"getOffer\", [offerId]);\n    return await this.mapOffer(offer);\n  }\n\n  /** ******************************\n   * WRITE FUNCTIONS\n   *******************************/\n\n  /**\n   * Make an offer\n   *\n   * @remarks Make an offer on the marketplace for an asset.\n   *\n   * @example\n   * ```javascript\n   * // Data of the offer you want to make\n   * const offer = {\n   *   // address of the contract the asset you want to make an offer for\n   *   assetContractAddress: \"0x...\",\n   *   // token ID of the asset you want to buy\n   *   tokenId: \"0\",\n   *   // how many of the asset you want to buy\n   *   quantity: 1,\n   *   // address of the currency contract that you offer to pay in\n   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,\n   *   // Total price you offer to pay for the mentioned token(s)\n   *   totalPrice: \"1.5\",\n   *   // Offer valid until\n   *   endTimestamp: new Date(),\n   * }\n   *\n   * const tx = await contract.offers.makeOffer(offer);\n   * const receipt = tx.receipt; // the transaction receipt\n   * const id = tx.id; // the id of the newly created offer\n   * ```\n   * @param offer - the offer data\n   * @returns The transaction receipt and the id of the newly created offer\n   * @twfeature Offers\n   */\n  makeOffer = /* @__PURE__ */buildTransactionFunction(async offer => {\n    const parsedOffer = await OfferInputParamsSchema.parseAsync(offer);\n    const chainId = await this.contractWrapper.getChainID();\n    const currency = isNativeToken(parsedOffer.currencyContractAddress) ? NATIVE_TOKENS[chainId].wrapped.address : parsedOffer.currencyContractAddress;\n    const normalizedTotalPrice = await normalizePriceValue(this.contractWrapper.getProvider(), parsedOffer.totalPrice, currency);\n    const overrides = await this.contractWrapper.getCallOverrides();\n    await setErc20Allowance(this.contractWrapper, normalizedTotalPrice, currency, overrides);\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"makeOffer\",\n      args: [{\n        assetContract: parsedOffer.assetContractAddress,\n        tokenId: parsedOffer.tokenId,\n        quantity: parsedOffer.quantity,\n        currency: currency,\n        totalPrice: normalizedTotalPrice,\n        expirationTimestamp: parsedOffer.endTimestamp\n      }],\n      parse: receipt => {\n        const event = this.contractWrapper.parseLogs(\"NewOffer\", receipt?.logs);\n        return {\n          id: event[0].args.offerId,\n          receipt\n        };\n      }\n    });\n  });\n\n  /**\n   * Cancel an offer\n   *\n   * @remarks Cancel an offer on the marketplace\n   *\n   * @example\n   * ```javascript\n   * // The ID of the offer you want to cancel\n   * const offerId = \"0\";\n   *\n   * await contract.offers.cancelOffer(offerId);\n   * ```\n   * @param offerId - the offer id\n   * @returns The transaction receipt\n   * @twfeature Offers\n   */\n  cancelOffer = /* @__PURE__ */buildTransactionFunction(async offerId => {\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"cancelOffer\",\n      args: [offerId]\n    });\n  });\n\n  /**\n   * Accept an offer\n   *\n   * @example\n   * ```javascript\n   * // The ID of the offer you want to accept\n   * const offerId = 0;\n   *\n   * await contract.offers.acceptOffer(offerId);\n   * ```\n   *\n   * @param offerId - The offer id\n   * @returns The transaction receipt\n   * @twfeature Offers\n   */\n  acceptOffer = /* @__PURE__ */buildTransactionFunction(async offerId => {\n    const offer = await this.validateOffer(BigNumber.from(offerId));\n    const {\n      valid,\n      error\n    } = await this.isStillValidOffer(offer);\n    if (!valid) {\n      throw new Error(`Offer ${offerId} is no longer valid. ${error}`);\n    }\n    const overrides = (await this.contractWrapper.getCallOverrides()) || {};\n    await handleTokenApproval(this.contractWrapper, this.getAddress(), offer.assetContractAddress, offer.tokenId, await this.contractWrapper.getSignerAddress());\n    return Transaction.fromContractWrapper({\n      contractWrapper: this.contractWrapper,\n      method: \"acceptOffer\",\n      args: [offerId],\n      overrides\n    });\n  });\n\n  /** ******************************\n   * PRIVATE FUNCTIONS\n   *******************************/\n\n  /**\n   * Throws error if offer could not be found\n   *\n   * @param offerId - offer to check for\n   */\n  async validateOffer(offerId) {\n    try {\n      return await this.getOffer(offerId);\n    } catch (err) {\n      console.error(`Error getting the offer with id ${offerId}`);\n      throw err;\n    }\n  }\n\n  /**\n   * Helper method maps the offer to the offer interface.\n   *\n   * @internal\n   * @param offer - The offer to map, as returned from the contract.\n   * @returns  The mapped interface.\n   */\n  async mapOffer(offer) {\n    let status = Status.UNSET;\n    const block = await this.contractWrapper.getProvider().getBlock(\"latest\");\n    const blockTime = block.timestamp;\n    switch (offer.status) {\n      case 1:\n        status = BigNumber.from(offer.expirationTimestamp).lt(blockTime) ? Status.Expired : Status.Active;\n        break;\n      case 2:\n        status = Status.Completed;\n        break;\n      case 3:\n        status = Status.Cancelled;\n        break;\n    }\n    return {\n      id: offer.offerId.toString(),\n      offerorAddress: offer.offeror,\n      assetContractAddress: offer.assetContract,\n      currencyContractAddress: offer.currency,\n      tokenId: offer.tokenId.toString(),\n      quantity: offer.quantity.toString(),\n      totalPrice: offer.totalPrice.toString(),\n      currencyValue: await fetchCurrencyValue(this.contractWrapper.getProvider(), offer.currency, offer.totalPrice),\n      asset: await fetchTokenMetadataForContract(offer.assetContract, this.contractWrapper.getProvider(), offer.tokenId, this.storage),\n      endTimeInSeconds: BigNumber.from(offer.expirationTimestamp).toNumber(),\n      status: status\n    };\n  }\n\n  /**\n   * Use this method to check if an offer is still valid.\n   *\n   * Ways an offer can become invalid:\n   * 1. The offer has expired\n   * 2. The offeror doesn't have enough balance of currency tokens\n   * 3. The offeror removed the approval of currency tokens on the marketplace\n   *\n   * @internal\n   * @param offer - The offer to check.\n   * @returns  True if the offer is valid, false otherwise.\n   */\n  async isStillValidOffer(offer) {\n    const now = BigNumber.from(Math.floor(Date.now() / 1000));\n    if (now.gt(offer.endTimeInSeconds)) {\n      return {\n        valid: false,\n        error: `Offer with ID ${offer.id} has expired`\n      };\n    }\n    const chainId = await this.contractWrapper.getChainID();\n    const currency = isNativeToken(offer.currencyContractAddress) ? NATIVE_TOKENS[chainId].wrapped.address : offer.currencyContractAddress;\n    const provider = this.contractWrapper.getProvider();\n    const ERC20Abi = (await import('@thirdweb-dev/contracts-js/dist/abis/IERC20.json')).default;\n    const erc20 = new ContractWrapper(provider, currency, ERC20Abi, {}, this.storage);\n    const offerorBalance = await erc20.read(\"balanceOf\", [offer.offerorAddress]);\n    if (offerorBalance.lt(offer.totalPrice)) {\n      return {\n        valid: false,\n        error: `Offeror ${offer.offerorAddress} doesn't have enough balance of token ${currency}`\n      };\n    }\n    const offerorAllowance = await erc20.read(\"allowance\", [offer.offerorAddress, this.getAddress()]);\n    if (offerorAllowance.lt(offer.totalPrice)) {\n      return {\n        valid: false,\n        error: `Offeror ${offer.offerorAddress} hasn't approved enough amount of token ${currency}`\n      };\n    }\n    return {\n      valid: true,\n      error: \"\"\n    };\n  }\n  async applyFilter(offers, filter) {\n    let rawOffers = [...offers];\n    if (filter) {\n      if (filter.offeror) {\n        const resolvedOfferor = await resolveAddress(filter.offeror);\n        rawOffers = rawOffers.filter(offeror => offeror.offeror.toString().toLowerCase() === resolvedOfferor?.toString().toLowerCase());\n      }\n      if (filter.tokenContract) {\n        const resolvedToken = await resolveAddress(filter.tokenContract);\n        rawOffers = rawOffers.filter(tokenContract => tokenContract.assetContract.toString().toLowerCase() === resolvedToken?.toString().toLowerCase());\n      }\n      if (filter.tokenId !== undefined) {\n        rawOffers = rawOffers.filter(tokenContract => tokenContract.tokenId.toString() === filter?.tokenId?.toString());\n      }\n    }\n    return filter?.count && filter.count < rawOffers.length ? rawOffers.slice(0, filter.count) : rawOffers;\n  }\n}\n\nexport { MarketplaceV3DirectListings as M, Status as S, MarketplaceV3EnglishAuctions as a, MarketplaceV3Offers as b };\n"],"names":["cleanCurrencyAddress","currencyAddress","isNativeToken","NATIVE_TOKEN_ADDRESS","ContractPlatformFee","constructor","contractWrapper","_defineProperty","FEATURE_PLATFORM_FEE","name","buildTransactionFunction","async","parsed","CommonPlatformFeeSchema","parseAsync","platformFeeInfo","Transaction","fromContractWrapper","this","method","args","platform_fee_recipient","platform_fee_basis_points","get","platformFeeRecipient","platformFeeBps","read","isTokenApprovedForTransfer","provider","transferrerContractAddress","assetContract","tokenId","owner","ERC165Abi","default","erc165","Contract","isERC721","isERC1155","Promise","all","supportsInterface","InterfaceId_IERC721","InterfaceId_IERC1155","_approvedAddress","ERC721Abi","asset","isApprovedForAll","approvedAddress","getApproved","e","toLowerCase","ERC1155Abi","console","error","err","handleTokenApproval","marketplaceAddress","from","ContractWrapper","getSignerOrProvider","options","storage","sendTransaction","Error","validateNewListingParam","param","invariant","undefined","assetContractAddress","buyoutPricePerToken","listingDurationInSeconds","startTimestamp","quantity","type","reservePricePerToken","mapOffer","listingId","offer","quantityDesired","pricePerToken","currencyContractAddress","currency","buyerAddress","offeror","quantityWanted","currencyValue","fetchCurrencyValue","mul","isWinningBid","winningPrice","newBidPrice","bidBuffer","BigNumber","eq","sub","MAX_BPS","div","gte","getAllInBatches","start","end","fn","batches","DEFAULT_QUERY_ALL_COUNT","push","DirectListingInputParamsSchema","z","object","AddressOrEnsSchema","BigNumberishSchema","AmountSchema","RawDateSchema","Date","endTimestamp","EndDateSchema","isReservedListing","boolean","Status","MarketplaceV3DirectListings","FEATURE_DIRECT_LISTINGS","parsedListing","listing","getAddress","getSignerAddress","normalizedPricePerToken","normalizePriceValue","getProvider","blockTime","getBlock","timestamp","lt","tx","reserved","parse","receipt","id","parseLogs","logs","setGasLimitMultiple","data","listings","map","createListing","prepare","encode","event","receiver","resolveAddress","validateListing","valid","isStillValidListing","concat","buyFor","value","overrides","getCallOverrides","setErc20Allowance","buyer","isBuyerApprovedForListing","pricePerTokenInCurrency","resolvedCurrencyAddress","currencyPrice","isZero","events","ContractEvents","encoder","ContractEncoder","interceptor","ContractInterceptor","estimator","GasCostEstimator","address","getTotalCount","getAll","filter","totalListings","toNumber","rawListings","startId","endId","flat","filteredListings","applyFilter","mapListing","getAllValid","getListing","isCurrencyApprovedForListing","currencyPriceForListing","status","UNSET","gt","Created","Expired","Active","Completed","Cancelled","toString","currencyValuePerToken","startTimeInSeconds","fetchTokenMetadataForContract","endTimeInSeconds","creatorAddress","listingCreator","_owner","ownerOf","balanceOf","seller","resolvedSeller","tokenContract","resolvedToken","_filter$tokenId","count","length","slice","EnglishAuctionInputParamsSchema","minimumBidAmount","buyoutBidAmount","timeBufferInSeconds","bidBufferBps","MarketplaceV3EnglishAuctions","FEATURE_ENGLISH_AUCTIONS","parsedAuction","auction","normalizedBuyoutAmount","normalizedMinBidAmount","auctionId","createAuction","validateAuction","currencyMetadata","fetchCurrencyMetadata","makeBid","utils","decimals","bidAmount","normalizedBidAmount","getWinningBid","isWinnner","tokenPrice","closeFor","message","includes","AuctionHasNotEndedError","winningBid","closeForSeller","closeForBuyer","totalAuctions","rawAuctions","filteredAuctions","mapAuction","getAuction","bid","_bidder","constants","mapBid","_currency","_bidAmount","getWinner","now","Math","floor","endTime","contractEvent","closed","getEvents","find","a","winningBidder","getBidBufferBps","getMinimumNextBid","currentBidBufferBps","currentBidOrReservePrice","minimumNextBid","add","auctionCreator","minimumBidCurrencyValue","buyoutCurrencyValue","bidderAddress","resolvedBidderAddress","bidAmountCurrencyValue","auctions","_filter$tokenId2","OfferInputParamsSchema","totalPrice","MarketplaceV3Offers","FEATURE_OFFERS","parsedOffer","chainId","getChainID","NATIVE_TOKENS","wrapped","normalizedTotalPrice","expirationTimestamp","offerId","validateOffer","isStillValidOffer","totalOffers","rawOffers","filteredOffers","getOffer","offerorAddress","ERC20Abi","erc20","offers","resolvedOfferor","_filter$tokenId3"],"sourceRoot":""}